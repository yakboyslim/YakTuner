--- Page 11 ---

This page contains a Simulink-style block diagram representing a software component.

## Function

The primary function of this module, titled "FUSL, Fuel temperature," is to calculate and provide various fuel temperature values and related status information within an automotive system. It processes a multitude of input signals, performs initialization and periodic operations at different rates (1 second and 100 milliseconds), and outputs several derived fuel temperature values, likely for different parts of the fuel system (e.g., Electric Fuel Pump, High Pressure Pump) and for general system use.

## Inputs

The module receives a comprehensive set of inputs, which are multiplexed into the functional blocks:

*   **Initialization Trigger:** `fc_INI`
*   **Scheduling/Control Signals:**
    *   `fc_OPM_1S` (Operation at 1-second cadence)
    *   `fc_OPM_100MS` (Operation at 100-millisecond cadence)
*   **System Status & Permissions:**
    *   `<ACTION_FARM_GetPermission_T3>`
    *   `<LV_ENG_LST_ST_STST>` (Engine Last Stop Start)
    *   `<LV_ERR_TFU_HPP>` (Error Fuel Temperature High Pressure Pump)
    *   `<LV_ES>` (Engine Speed status/signal)
    *   `<LV_FIRST_VLD_TOOTH>` (First Valid Tooth, likely for engine synchronization)
    *   `<LV_IGK>` (Ignition Key status)
    *   `<LV_PU>` (Power Up status)
    *   `<LV_PUG>` (Power Up Global status)
    *   `<LV_STST_STOP_CYC>` (Stop-Start Stop Cycle)
    *   `<LV_ST_END>` (Stop End status)
    *   `<LV_T_ES_NOT_PLAUS>` (Engine Speed Temperature Not Plausible)
*   **Measured/Modeled Temperature & Other Physical Values:**
    *   `<MFF_SP_FUP_CTL>` (Main Fuel Filter Spray Fuel Pump Control)
    *   `<N_32>` (Engine Speed, 32-bit value)
    *   `<TAM>` (Ambient Temperature)
    *   `<TCO>` (Coolant Temperature)
    *   `<TFU_EFP_CUS>` (Fuel Temperature Electric Fuel Pump Customer value)
    *   `<TFU_HPP_CUS>` (Fuel Temperature High Pressure Pump Customer value)
    *   `<TFU_HPP_CUS_1>` (Additional Fuel Temperature HPP Customer value)
    *   `<TFU_HPP_MES>` (Fuel Temperature High Pressure Pump Measured value)
    *   `<TOIL>` (Oil Temperature)
    *   `<TQ_AV>` (Available Torque)
    *   `<T_AST>` (Air Stream Temperature)
    *   `<T_ES>` (Engine Speed Temperature)
    *   `<VS>` (Vehicle Speed)
*   **Internal Feedback:** `feedback` (from the `operate_100ms` block)

## Outputs

The module generates several fuel temperature related outputs, along with an internal feedback signal:

*   `<TFU>` (General Fuel Temperature)
*   `<TFU_EFP>` (Fuel Temperature for Electric Fuel Pump)
*   `<TFU_EFP_1>` (Additional Fuel Temperature for Electric Fuel Pump)
*   `<TFU_HPP>` (Fuel Temperature for High Pressure Pump)
*   `<TFU_HPP_1>` (Additional Fuel Temperature for High Pressure Pump)
*   `<TFU_MDL_2>` (Modeled Fuel Temperature, possibly a secondary model output)
*   **Internal Feedback:** `feedback` (output from `operate_100ms` block, fed back to `INIT` and `operate_100ms`).

The large text block on the right also lists numerous internal variables (e.g., `FAC_TFU_FDOU`, `LV_TFU_STAT`, `TFU_COR_STAT_PUC`, etc.) which represent intermediate calculations, states, and derived values that contribute to the final outputs.

## Logic Flow

The module's logic flow is organized around scheduled execution rates and distinct functional blocks:

1.  **Initialization (Block X.1 - "INIT"):**
    *   **Trigger:** Activated by `fc_INI`. The "Recurrence" section specifies `Init: RST IGKON ERU2ES`, indicating it runs upon system reset, ignition on, and possibly other system states.
    *   **Inputs:** It receives the primary `input` bundle (all external signals) and the `feedback` signal from the `operate_100ms` block.
    *   **Function:** This block performs the initial setup of the fuel temperature calculation module. It likely initializes internal states, variables, and filters based on initial conditions and potentially past operational feedback.

2.  **1-Second Operation (Block X.2 - "operate_1s"):**
    *   **Trigger:** Activated by `fc_OPM_1S`. The "Recurrence" section indicates this runs at a 1-second cadence.
    *   **Inputs:** It receives the primary `input` bundle.
    *   **Function:** This block performs calculations or updates that are less time-critical and can be processed at a slower rate (e.g., once per second). This might include adaptive parameters, long-term averaging, or diagnostics.

3.  **100-Millisecond Operation (Block X.3 - "operate_100ms"):**
    *   **Trigger:** Activated by `fc_OPM_100MS`. The "Recurrence" section indicates this is the main operational loop, running every 100 milliseconds.
    *   **Inputs:** It receives the primary `input` bundle and its own `feedback` signal from the previous execution cycle.
    *   **Function:** This is the core operational block responsible for the primary fuel temperature calculations. It continuously processes sensor data and system states at a higher frequency to derive the various fuel temperature outputs. The self-feedback loop is crucial for dynamic calculations such as filtering, state estimation, or integration, allowing current calculations to depend on previous results.
    *   **Outputs:** This block produces the main outputs of the module (e.g., `<TFU>`, `<TFU_EFP>`) and generates the `feedback` signal that feeds back into itself and the `INIT` block.

**Overall Flow:**
The system starts with an initialization phase (X.1). Once initialized, the module continuously operates with two primary periodic tasks: a slower one (X.2) executing every 1 second, and a faster, core task (X.3) executing every 100 milliseconds. All three blocks receive relevant input signals, and the `operate_100ms` block utilizes a feedback mechanism to maintain and update its internal state for continuous, dynamic fuel temperature processing. The final outputs of the module are then provided to other parts of the automotive system.


--- Page 12 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink diagram, titled "43.3.1 Initialization" and associated with "FUSL, Fuel temperature", is to **initialize the various states, parameters, and operational flags for a Fuel Temperature Unit (TFU) or a related fuel system component**. It processes numerous system inputs and feedback signals to establish the correct initial conditions for the TFU, including measured values, diagnostic states, control ramps, and non-volatile memory parameters, ultimately providing a consolidated "init" bus containing the complete initialized status.

## Inputs
1.  **`fc_init`**: A function-call trigger or an event signal to initiate the initialization process.
2.  **`fc_RST`**: A reset signal, likely triggering a hard or soft reset of the TFU logic.
3.  **`<TCO>`**: An input signal, possibly related to a timer or a control object.
4.  **`<TAM>`**: Another input signal, potentially related to an actuation or timing module.
5.  **`<TFU_HPP_MES>`**: Measured data from the TFU's High-Pressure Pump (HPP), such as pressure or temperature.
6.  **`<ACTION_N_FARM_GetPermission>`**: A signal indicating permission or a request for a specific action, possibly related to a diagnostic or operational mode ("N_FARM").
7.  **`<TFU_HPP_CUS_1>`**: A custom or specific input signal related to the TFU High-Pressure Pump.
8.  **`input`**: A generic input bus that likely bundles several additional system-level inputs required for the initialization.
9.  **`feedback`**: This is a key input that consists of feedback signals, specifically `<TFU_MDL_2>` and `<TFU_H_RES_ST_RAMP>`. These signals suggest that the initialization can leverage previous states, enabling "warm" initialization or persistent state management.

## Outputs
1.  **`init` (Bus)**: This is the main output, a comprehensive bus containing all the initialized signals for the TFU system. The signals within this bus include:
    *   `<TFU_MDL_2>`, `<TFU_COR_STAT_PUC_PU>`, `<TFU_STAT>`, `<N_PUC_SAVE_TFU>`, `<TFU_PUC_SAVE>`, `<TFU_PUC>`, `TFU_EFP`, `<STATE_TFU>`, `TFU_HPP`, `FAC_TFU_STAT`, `<TFU_H_RES_ST_RAMP>`, `<TFU_IS_OFS_H_RES>`, `<LV_TFU_STATE_1_ST_RAMP>`, `<LV_TFU_STATE_2_ST_RAMP>`, `<TFU_OFS_T_ES_T3>`, `<ACTION_FARM_GetPermission_T3>`, `TFU_OFS_T_ES_DIF_LIM`, `TFU_OFS_T_ES_BAS`, `TFU_OFS_T_ES_FDOUT`, `FAC_TFU_OFS_T_ES_FDOUT`, `TFU_HPP_1`, `TFU_EFP_1`, `TFU`.
2.  **`igk_off_2_on`**: A control or status signal related to the "ignition off" state, likely indicating if a specific condition or event should be active.
3.  **`igk_off_2_o`**: Another control or status signal related to the "ignition off" state, possibly an output or a different aspect of the same logic.
4.  **`eru_2_es` (Bus)**: An output bus from the `ERU_2_ES` block, containing specific state information, likely related to an Engine Run-Up or Error Recovery Unit's (ERU) essential states (`LV_TFU_STATE_1_ST_RAMP`, `LV_TFU_STATE_2_ST_RAMP`).

## Logic Flow

The logical flow of this initialization subsystem proceeds as follows:

1.  **Main Initialization Trigger and Inputs:** The initialization process is primarily driven by the `fc_init` signal. It takes in various external system inputs like `fc_RST`, `TCO`, `TAM`, `TFU_HPP_MES`, `ACTION_N_FARM_GetPermission`, `TFU_HPP_CUS_1`, and the generic `input` bus. Crucially, it also receives feedback signals (`TFU_MDL_2`, `TFU_H_RES_ST_RAMP`) from potentially the previous operational cycle or another part of the system, indicating a stateful initialization.

2.  **Core TFU Logic (`fc()` block - TFU_MDL_2):** The large `fc()` block, labeled "TFU_MDL_2", represents the central computational unit for TFU initialization. It receives all the aforementioned inputs and feedback signals. Inside this block, complex calculations and state machine logic are executed to determine the correct initial values for a wide array of TFU-related parameters. These include:
    *   Various TFU model/mode states (`TFU_MDL_2`, `TFU_COR_STAT_PUC_PU`, `TFU_STAT`, `STATE_TFU`).
    *   Parameters related to saving data upon power-up cycles (`N_PUC_SAVE_TFU`, `TFU_PUC_SAVE`, `TFU_PUC`).
    *   Error and performance indicators (`TFU_EFP`, `FAC_TFU_STAT`).
    *   High-Pressure Pump related parameters (`TFU_HPP`, `TFU_HPP_1`).
    *   Ramp functions and state levels (`TFU_H_RES_ST_RAMP`, `TFU_IS_OFS_H_RES`, `LV_TFU_STATE_1_ST_RAMP`, `LV_TFU_STATE_2_ST_RAMP`).
    *   Offset temperature and engine start parameters (`TFU_OFS_T_ES_T3`, `TFU_OFS_T_ES_DIF_LIM`, `TFU_OFS_T_ES_BAS`, `TFU_OFS_T_ES_FDOUT`, `FAC_TFU_OFS_T_ES_FDOUT`).
    *   Other general TFU parameters (`TFU_1`, `TFU`).

3.  **Bus Creation and Distribution:** The numerous individual outputs generated by the main `fc()` block are then organized. A prominent vertical bar acts as a `BusCreator`, bundling many of these signals together.

4.  **Reset and Ignition-Off Control (`CLC_RESET` and `IGK_OFF_2_ON` blocks):**
    *   A control signal or bus `CLC_RESET` (X.1.1) is present, indicating that specific reset logic might be applied.
    *   The `IGK_OFF_2_ON` (X.1.2) block receives `TFU_MDL_2` (likely from the feedback path or directly from the main `fc()` block) and `TFU_H_RES_ST_RAMP`. This block specifically handles logic related to ignition-off events or states, producing relevant outputs like `N_PUC_SAVE_TFU`, `N_PU_SAVE_TFU`, a potentially modified `TFU_H_RES_ST_RAMP`, and the control/status flags `igk_off_2_on` and `igk_off_2_o`. This suggests a mechanism to manage system behavior or save states when the ignition is switched off.

5.  **ERU State Initialization (`ERU_2_ES` block):** The `ERU_2_ES` (X.1.3) block focuses on initializing specific states, taking `LV_TFU_STATE_1_ST_RAMP` and `LV_TFU_STATE_2_ST_RAMP` as inputs. It bundles its resulting initialized states into the `eru_2_es` output bus, likely for an Engine Run-Up or Error Recovery Unit.

6.  **Final Output Consolidation (`BusMerge`):** All relevant initialized signals, including those from the main `fc()` block (which are internally grouped as 'init' signals) and potentially others not explicitly shown as separate blocks, are fed into a `BusMerge` block. This block combines all these individual `init` signals into a single, structured output bus named `init`, representing the complete initialized state of the TFU system ready for other functional blocks or controllers.


--- Page 13 ---

This page contains a Simulink-like diagram, likely representing a model designed in dSPACE TargetLink or a similar tool, given the presence of blocks like 'ActionImport'. The diagram details the initialization logic for various automotive system parameters related to fuel temperature and pressure control during a system reset.

## Function

The primary function of this diagram is to initialize various internal states, flags, and calculated values related to Fuel Temperature (TFU), Electric Fuel Pump (EFP), and High-Pressure Pump (HPP) control at system reset. It sets default values, often zero, for many variables and performs initial calculations for others based on specific inputs and configuration parameters.

## Inputs

The diagram utilizes a combination of constant values, data store reads (green blocks), and specific system parameters/signals as its inputs:

*   **Constants:** `0`, `1` (used as direct values for initialization or comparison).
*   **Parameters/Signals:**
    *   `C_TFU_EFP_OFS`: Constant offset for the Electric Fuel Pump.
    *   `C_TFU_SENS_CONF`: Constant for Fuel Sensor Configuration.
    *   `NC_FID_ERR_TFU_HPP_MES`: Error flag for TFU High-Pressure Pump Measurement.
    *   `PRM_LV_PRMS`: Low Voltage Parameters, fed into an `ActionImport` block.
    *   `ACTION_FARM_GetPermission_T3`: Action signal for obtaining permission (input to `ActionImport`).
    *   `FAC_TFU_OFS_T_ES_FDOU`: Factor for TFU Offset Temperature Estimation FDOUT (used as a control signal).
*   **Data Store Reads (green blocks):**
    *   `<TAM>`: Ambient Temperature.
    *   `<TFU_CO>`: Fuel Temperature Unit Compensation value.
    *   `<TFU_HPP_CUS_1>`: Customer-specific High-Pressure Pump value.
    *   `<TFU_HPP_MES>`: High-Pressure Pump Measurement.

## Outputs

The outputs of this diagram are primarily Data Store Write blocks (blue rounded rectangles), which store the initialized values into specific system variables for later use.

*   `<TFU_COR_STAT_PUC_PU>`: Corrected Status for Pressure Unit Control (PUC) and Fuel Pressure (PU).
*   `<TFU_STAT>`: Fuel Temperature Unit Status.
*   `<N_PUC_SAVE_TFU>`: Number of PUC saves related to TFU.
*   `<TFU_PUC_SAVE>`: Saved PUC value for TFU.
*   `<TFU_PUC>`: Current PUC value for TFU.
*   `<STATE_TFU>`: Current State of the Fuel Temperature Unit.
*   `<FAC_TFU_STAT>`: Factor for TFU Status.
*   `<TFU_IS_OFS_H_RES>`: TFU is Offset High Resolution flag.
*   `<LV_TFU_STATE_1_ST_RAMP>`: Low Voltage TFU State 1 Start Ramp value.
*   `<LV_TFU_STATE_2_ST_RAMP>`: Low Voltage TFU State 2 Start Ramp value.
*   `<TFU_EFP>`: Electric Fuel Pump value.
*   `<TFU_EFP_1>`: Electric Fuel Pump 1 value.
*   `<TFU_MDL_2>`: TFU Model 2 value.
*   `<TFU_HPP_1>`: TFU High-Pressure Pump 1 value.
*   `<TFU_HPP>`: TFU High-Pressure Pump value.
*   `<TFU_H_RES_ST_RAMP>`: TFU High Resolution State Ramp value.
*   `<TFU>`: Final Fuel Temperature Unit value.
*   `<TFU_OFS_T_ES>`: TFU Offset Temperature Estimation.
*   `<TFU_OFS_T_ES_DIF_LIM>`: TFU Offset Temperature Estimation Differential Limit.
*   `<TFU_OFS_T_ES_FDOUT>`: TFU Offset Temperature Estimation FDOUT.
*   `<FAC_TFU_OFS_T_ES_FDOUT>`: Factor TFU Offset Temperature Estimation FDOUT.
*   `<TFU_OFS_T_ES_BAS>`: TFU Offset Temperature Estimation Basic value.

## Logic Flow

The logic flow can be broken down into several independent or semi-independent initialization sections:

1.  **Direct Zero/Default Initialization (Left Side):**
    *   Many critical status, save, and state variables related to Fuel Temperature (TFU) and Fuel Pressure Unit Control (PUC) are initialized to `0` from constant blocks. This includes `<TFU_COR_STAT_PUC_PU>`, `<TFU_STAT>`, `<N_PUC_SAVE_TFU>`, `<TFU_PUC_SAVE>`, `<TFU_PUC>`, `<STATE_TFU>`, `<FAC_TFU_STAT>`, `<TFU_IS_OFS_H_RES>`, `<LV_TFU_STATE_1_ST_RAMP>`, and `<LV_TFU_STATE_2_ST_RAMP>`. This ensures a clean slate upon reset.
    *   Similarly, several TFU offset and limit parameters (`<TFU_OFS_T_ES>`, `<TFU_OFS_T_ES_DIF_LIM>`, `<TFU_OFS_T_ES_FDOUT>`, `<TFU_OFS_T_ES_BAS>`) are also initialized to `0`.
    *   A special case for `FAC_TFU_OFS_T_ES_FDOU` (Factor TFU Offset Temperature Estimation FDOUT): a `Switch` block selects between a `0` and a `1` constant based on an input signal also named `FAC_TFU_OFS_T_ES_FDOU`. This implies a conditional initialization, where the output `<FAC_TFU_OFS_T_ES_FDOUT>` is set to `0` if the control signal is true, otherwise to `1`.

2.  **Electric Fuel Pump (EFP) Initialization (Top Right):**
    *   The Ambient Temperature (`<TAM>`) is read from a data store and implicitly treated as `0` for the purpose of summation with `C_TFU_EFP_OFS` (Electric Fuel Pump Offset).
    *   The resulting sum is then fed into a Mux block, whose output is duplicated to `TFU_EFP` and `TFU_EFP_1`.
    *   These values are then stored in `<TFU_EFP>` and `<TFU_EFP_1>` data stores, initializing the Electric Fuel Pump related values.

3.  **High-Pressure Pump (HPP) & Model Initialization (Middle Right):**
    *   A compensation value `<TFU_CO>` is read from a data store.
    *   This value is then fanned out using a Demultiplexer block to several outputs: `TFU_MDL_2`, `TFU_HPP_1`, `TFU_HPP`, and `TFU_H_RES_ST_RAMP`.
    *   These individual signals are then stored in their respective data stores: `<TFU_MDL_2>`, `<TFU_HPP_1>`, `<TFU_HPP>`, and `<TFU_H_RES_ST_RAMP>`. This suggests that `TFU_CO` serves as a baseline for initializing these related HPP and model values.

4.  **Main Fuel Temperature Unit (TFU) Initialization (Bottom Right):**
    *   An `ActionImport` block takes `NC_FID_ERR_TFU_HPP_MES` (HPP measurement error flag) and `PRM_LV_PRMS` (Low Voltage Parameters) to determine `ACTION_FARM_GetPermission_T3`.
    *   The output of the `ActionImport` block is passed through a `NOT` gate.
    *   The output of the `NOT` gate and `<TFU_HPP_MES>` (High-Pressure Pump Measurement) are inputs to a `Check ~= 0` block (a relational operator, likely `NOT_output ~= TFU_HPP_MES`). The boolean result of this comparison acts as the control signal for a `Switch` block.
    *   The `Switch` block receives two data inputs: `<TFU_HPP_CUS_1>` (Customer HPP value) and `C_TFU_SENS_CONF` (Fuel Sensor Configuration).
    *   If the control signal (output of `Check ~= 0`) is true, `<TFU_HPP_CUS_1>` is passed; otherwise, `C_TFU_SENS_CONF` is passed.
    *   The chosen value, labeled `TFU`, is then stored in the `<TFU>` data store, completing the initialization of the primary Fuel Temperature Unit value based on permission status, HPP measurements, and sensor configuration.


--- Page 14 ---

This page contains three distinct Simulink diagrams, which are components of an automotive control system, likely related to "Fuel temperature" (FUSL) management.

## Function
The primary function of these Simulink diagrams is to define the initialization logic for fuel temperature (TFU) related state variables during specific vehicle operational transitions (Ignition-On, Engine-Stop) and to implement a periodic calculation routine for fuel temperature management. This system ensures that fuel temperature-related parameters are correctly set at critical moments and continuously updated during operation.

## Inputs
### Figure 43.3.4: Initialization at Ignition-Key-Off-2-On
*   **LC_TFU_H_RES_ST_RAMP_INI**: A constant representing the initial value for the Fuel Unit Heating Resistance State Ramp.
*   **<TFU_MDL_2>**: A signal representing a value from Fuel Unit Model 2, likely an estimated or calculated fuel temperature related value.
*   **<TFU_H_RES_ST_RAMP>** (read): The current value of the Fuel Unit Heating Resistance State Ramp, used as an input to the initialization logic.

### Figure 43.3.5: Initialization at Engine-Run-2-Engine-Stop
*   No explicit external inputs other than internal constants (`0`) for resetting. The trigger for this initialization is the engine transitioning from Run to Stop.

### Figure 43.3.6: Calculation in 1 second recurrence
*   **1** (constant, labeled "input"): A fixed input, possibly serving as a trigger or a default value.
*   **<TAM>**: A signal representing Ambient Temperature or Air Mass, read from a data store.
*   **<TFU_EFP_CUS>**: A signal representing a customer-specific Electric Fuel Pump parameter or value, read from a data store.

## Outputs
### Figure 43.3.4: Initialization at Ignition-Key-Off-2-On
*   **<N_PUC_SAVE_TFU>**: The number of Power-Up Cycles saved for the Fuel Unit, initialized to `0`.
*   **<LV_TFU_STATE_1_ST_RAMP>**: Low Voltage Fuel Unit State 1 State Ramp, initialized to `0`.
*   **<LV_TFU_STATE_2_ST_RAMP>**: Low Voltage Fuel Unit State 2 State Ramp, initialized to `0`.
*   **<TFU_H_RES_ST_RAMP>** (written): The updated value of the Fuel Unit Heating Resistance State Ramp, set based on initialization logic.

### Figure 43.3.5: Initialization at Engine-Run-2-Engine-Stop
*   **<LV_TFU_STATE_1_ST_RAMP>**: Low Voltage Fuel Unit State 1 State Ramp, initialized to `0`.
*   **<LV_TFU_STATE_2_ST_RAMP>**: Low Voltage Fuel Unit State 2 State Ramp, initialized to `0`.

### Figure 43.3.6: Calculation in 1 second recurrence
*   **operate_1s**: An output signal representing the result or status of the 1-second recurring calculation, likely a boolean flag or a calculated value.

## Logic Flow

### 1. Initialization at Ignition-Key-Off-2-On (Figure 43.3.4)
This diagram describes the initialization process when the vehicle's ignition key is turned from Off to On:
*   The system sets three key state variables to `0`:
    *   `<N_PUC_SAVE_TFU>`: Likely a counter for power-up cycles or a stored flag.
    *   `<LV_TFU_STATE_1_ST_RAMP>`: A state ramp variable for the low voltage fuel unit.
    *   `<LV_TFU_STATE_2_ST_RAMP>`: Another state ramp variable for the low voltage fuel unit.
*   The initialization logic for `<TFU_H_RES_ST_RAMP>` (Fuel Unit Heating Resistance State Ramp) involves a multi-input selection block (labeled "Check ~= 0"). This block compares a condition to zero.
    *   It receives `LC_TFU_H_RES_ST_RAMP_INI` (a constant initial value), `<TFU_MDL_2>` (a model-derived value), and the existing `<TFU_H_RES_ST_RAMP>` value.
    *   Based on the "Check ~= 0" condition (which is typically a control signal indicating an initialization event or specific operating mode), one of these inputs is selected to determine the initial value for `<TFU_H_RES_ST_RAMP>`. For instance, it might select `LC_TFU_H_RES_ST_RAMP_INI` if a full reset is required.
*   The `f()` blocks indicate that functions are called or triggered using these newly initialized values, potentially to update other system states or start a process.

### 2. Initialization at Engine-Run-2-Engine-Stop (Figure 43.3.5)
This diagram outlines the initialization that occurs when the engine transitions from a running state to a stopped state:
*   Both `<LV_TFU_STATE_1_ST_RAMP>` and `<LV_TFU_STATE_2_ST_RAMP>` are reset to `0`. This ensures that these low voltage fuel unit state ramp variables are in a known, default state when the engine is no longer running, preparing them for the next engine start cycle.
*   Similar to the previous figure, `f()` blocks suggest that functions are executed or system states are updated based on these reset values.

### 3. Calculation in 1 second recurrence (Figure 43.3.6)
This diagram illustrates a calculation routine that is executed periodically, specifically every 1 second:
*   A constant input `1` (likely a trigger or a signal indicating active operation) is fed into a processing block.
*   This block also takes `<TAM>` (Ambient Temperature/Air Mass) and `<TFU_EFP_CUS>` (Customer-specific Electric Fuel Pump parameter) as inputs. This implies that the calculation is influenced by environmental conditions and specific fuel pump configurations.
*   The processing block generates two intermediate internal signals: `TFU_EFP` and `TFU_EFP_1`, which are derived from the inputs. This block likely contains logic to convert, combine, or select values for fuel pump control or temperature estimation.
*   These intermediate signals (`TFU_EFP` and `TFU_EFP_1`) are then fed into a subsystem or function block called `CLC_OPERATE_1S`. This block represents the core logic for the 1-second operation.
*   The `CLC_OPERATE_1S` block outputs `operate_1s`, which signifies the result of this periodic calculation. This output could be a status flag (e.g., operation successful), a command signal, or a calculated value crucial for the ongoing fuel temperature management system.


--- Page 15 ---

This page contains Simulink diagrams.

## Function
The image displays two distinct Simulink diagrams, both related to the management of fuel temperature within an automotive system.

The first diagram (Figure 43.3.7) is dedicated to the **calculation of the Fuel Temperature for the Electric Fuel Pump (TFU_EFP)**, specifically stating it's for the low-pressure pump. It determines this temperature by selecting between a customized value or a calculation based on ambient temperature and an offset, governed by a control switch.

The second diagram (Figure 43.3.8) represents a more comprehensive **calculation module executed with a 100-millisecond recurrence**. This module processes a wide range of inputs, including various temperature readings, control flags, and model parameters, to determine and output numerous values related to overall fuel temperature, high-pressure pump (HPP) status, pump unit control (PUC) states, and specific engine start temperature offsets. It appears to be a core control algorithm for dynamic fuel temperature management.

## Inputs

### For Figure 43.3.7 (TFU_EFP Calculation):
*   `<TFU_EFP_CUS>`: A customized or default fuel temperature value for the electric fuel pump.
*   `LC_SWI_TFU_CLC`: A boolean control signal that dictates which input value is used for the TFU_EFP calculation.
*   `C_TFU_EFP_OFS`: A constant offset value applied to the ambient temperature.
*   `<TAM>`: Ambient temperature.

### For Figure 43.3.8 (100ms Recurrence Calculation):
*   `<VS>`: Vehicle Speed.
*   `<TCO>`: Coolant Temperature.
*   `<TOIL>`: Oil Temperature.
*   `<TAM>`: Ambient Temperature.
*   `<TFU_HPP_MES>`: Measured High Pressure Pump Temperature.
*   `<TFU_HPP_CUS>`: Customized High Pressure Pump Temperature.
*   `<TFU_HPP_1>`: A derived or intermediate High Pressure Pump Temperature.
*   `<ACTION_FARM_GetPermission_T3>`: A permission or activation signal for an action.
*   `<feedback>`: A generic feedback signal.
*   `tfu_st_ramp`: Fuel temperature ramp state or setting.
*   `TFU_HPP`: High Pressure Pump Temperature.
*   `tfu_is_ofs`: Fuel temperature offset indicator/value.
*   `tfu_ofs_t_es`: Fuel temperature offset for engine start.
*   `TFU_MDL`: Fuel Temperature Model value.
*   `TFU`: Current Fuel Temperature.
*   `clc_t_stat_puc_pu`: Closed-loop control temperature status for the Pump Unit Control (PUC) power unit.
*   `<TFU_COR_STAT_PUC_PU>`: Corrected status of the PUC power unit (also an output, suggesting a feedback loop).
*   `<TFU_MDL_2>`: Another Fuel Temperature Model value.

## Outputs

### For Figure 43.3.7 (TFU_EFP Calculation):
*   `TFU_EFP`: The primary calculated fuel temperature for the electric fuel pump.
*   `TFU_EFP_1`: A potentially modified or limited version of TFU_EFP, or an intermediate output.

### For Figure 43.3.8 (100ms Recurrence Calculation):
*   **Passed-through inputs:** `<VS>`, `<TCO>`, `<TOIL>`, `<TAM>`, `<TFU_HPP_MES>`, `<TFU_HPP_CUS>`, `<TFU_HPP_1>`, `<ACTION_FARM_GetPermission_T3>`, `<feedback>`. These inputs are directly propagated to outputs.
*   `<TFU_COR_STAT_PUC_PU>`: Corrected status of the Pump Unit Control (PUC) power unit.
*   `<TFU_MDL_2>`: A fuel temperature model value.
*   `<TFU_HPP>`: Calculated High Pressure Pump Temperature.
*   `<TFU_STAT>`: Fuel Temperature Unit (TFU) status.
*   `<N_PUC_SAVE_TFU>`: Number of PUC saves related to TFU.
*   `<TFU_PUC_SAVE>`: PUC save state for TFU.
*   `<N_PU_SAVE_TFU>`: Number of power unit saves related to TFU.
*   `<TFU_PUC>`: Fuel Temperature Unit Pump Unit Control value.
*   `<TFU_PU_SAVE>`: Power unit save state for TFU.
*   `<TFU_PU>`: Fuel Temperature Unit Power Unit value.
*   `<STATE_TFU>`: Current state of the Fuel Temperature Unit.
*   `<TFU_COR_STAT_PUC_PU_PREV_FIL>`: Previously filtered corrected status of the PUC power unit.
*   `<FAC_TFU_STAT>`: Factor for TFU status.
*   `<LV_TFU_IS_OFS_ACT>`: Level indicating if TFU offset is active.
*   `<TFU_IS_OFS_H_RES>`: TFU offset with high resolution.
*   `<TFU_MDL>`: Fuel Temperature Unit model value.
*   `<TFU>`: Calculated Fuel Temperature.
*   `<TFU_OFS_T_ES>`: Fuel Temperature Unit offset temperature for engine start.
*   `<TFU_OFS_T_ES_DIF_LIM>`: Difference limit for TFU offset temperature at engine start.
*   `<TFU_OFS_T_ES_FDOUT>`: Fade-out value for TFU offset temperature at engine start.
*   `<FAC_TFU_OFS_T_ES_FDOUT>`: Factor for fade-out of TFU offset temperature at engine start.
*   `<TFU_OFS_T_ES_BAS>`: Basic value for TFU offset temperature at engine start.
*   `operate_100ms`: A signal confirming the execution or status of the 100ms operation.

## Logic Flow

### For Figure 43.3.7 (TFU_EFP Calculation):
1.  **Input Selection:** A constant value `1` is compared with the `LC_SWI_TFU_CLC` input using an equality operator. The result of this comparison (`LC_SWI_TFU_CLC == 1`) controls a Switch block (V.6.2).
    *   If the condition is true (i.e., `LC_SWI_TFU_CLC` is `1`), the customized temperature `<TFU_EFP_CUS>` is selected.
    *   If the condition is false, the sum of `C_TFU_EFP_OFS` (offset) and `<TAM>` (ambient temperature) is selected.
2.  **Limiting/Constraint:** The output of Switch V.6.2 is then processed by a block labeled V.6.6 ("Check ~= 0"). This block likely applies a lower limit (e.g., ensuring the temperature is not below a certain threshold or non-zero) or performs saturation, outputting the primary calculated `TFU_EFP`.
3.  **Final Output Determination:** The `TFU_EFP` value serves two purposes: it's an output itself, and it acts as both a data input and the control signal for a second Switch block (V.6.1).
    *   One data input to Switch V.6.1 is `TFU_EFP`.
    *   The other data input to Switch V.6.1 is the result of `TFU_EFP` added to an unspecified value (input from an unconnected port).
    *   The `TFU_EFP` control signal then dictates which of these two values is passed through as `TFU_EFP_1`. This structure suggests a conditional modification or selection based on the calculated TFU_EFP itself.

### For Figure 43.3.8 (100ms Recurrence Calculation):
1.  **Data Ingestion:** A multitude of environmental, sensor, and state parameters related to vehicle operation, coolant, oil, and various fuel temperature aspects (e.g., `<VS>`, `<TCO>`, `<TOIL>`, `<TAM>`, `<TFU_HPP_MES>`, `tfu_st_ramp`, etc.) are brought into the subsystem.
2.  **Core Algorithm Execution:** All relevant inputs are channeled into a central functional block named `CLC_operate_100ms` (X.3.1). This block represents a complex algorithm or a subsystem that encapsulates the main logic for closed-loop control and calculation of fuel system parameters. It operates at a fixed interval of 100 milliseconds.
3.  **Result Generation:** Within `CLC_operate_100ms`, the inputs are processed to calculate various output values, including specific fuel temperatures (`<TFU>`, `<TFU_HPP>`), system states (`<TFU_STAT>`, `<STATE_TFU>`), control signals (`<TFU_PUC>`, `<TFU_COR_STAT_PUC_PU>`), and engine start-related temperature offsets (`<TFU_OFS_T_ES>` and its derivatives).
4.  **Signal Propagation:** Several input signals are directly routed from the input bus to the output bus, indicating they are passed through without modification within this specific 100ms recurrence. These might be used for monitoring, diagnostics, or to feed other parts of the system.
5.  **Recurrence Acknowledgment:** An output signal `operate_100ms` is generated, passing through a `branch` block (V.5.7). This signal likely serves as an indicator or trigger that the 100ms calculation cycle has completed or is active.


--- Page 16 ---

This image contains a Simulink diagram that describes the calculation and correction of fuel temperature at the injector head within an automotive system.

## Function
The primary function of this Simulink diagram is to determine a highly accurate and corrected fuel temperature (`TFU`) at the injector head. It achieves this by starting with a basic fuel temperature value, applying various environmental and operating condition-based corrections, incorporating dynamic offsets and ramps, and finally deciding whether to use a measured sensor value or a calculated modeled value based on sensor plausibility.

## Inputs
*   **`clc_t_stat_puc_pu`**: A basic fuel temperature signal, likely derived from system operating states.
*   **`TFU_COR_STAT_PUC_PU`**: The fundamental fuel temperature value determined by the engine's operating state (normal, pull fuel cut-off, pull).
*   **`<VS>`**: Vehicle Speed, used for speed-dependent corrections.
*   **`<TOIL>`**: Engine Oil Temperature, used for warm-up related corrections.
*   **`<TAM>`**: Ambient Air Temperature, used for ambient temperature corrections and as a potential minimum.
*   **`<TCO>`**: Engine Coolant Temperature, used for coolant temperature corrections and sensor plausibility checks.
*   **`CLC_1`, `CLC_2`, `CLC_3`, `CLC_4`, `CLC_5`, `CLC_6`**: Control logic flags or state signals that enable/disable or modify behavior in various sub-systems.
*   **`LV_T_ES_NOT_PLAUS`**: A flag indicating if the engine speed is considered implausible.
*   **`T_ES`**: Engine Speed, a primary input for engine state-dependent offsets.
*   **`T_AST`**: Ambient Start Temperature (or similar), related to engine start conditions.
*   **`LV_ST_END`**: A flag indicating the end of an engine start event.
*   **`LV_FIRST_VLD_TOOTH`**: A flag indicating the detection of the first valid crankshaft tooth.
*   **`LV_STST_STOP_CYC`**: A flag indicating a start-stop cycle stop event.
*   **`LV_ENG_LST_ST_STST`**: The last engine state in a start-stop sequence.
*   **`TFU_OFS_T_ES_DIF_LIM_PREV`**: A feedback signal for the previous offset difference limit, used in dynamic offset calculations.
*   **`TFU_MDL_1`, `TFU_MDL_3`**: Different modeled fuel temperature inputs used in various sub-blocks.
*   **`LV_TFU_STATE_1_ST_RAMP`**: Feedback for the previous ramp state.
*   **`tfu_is_ofs`**: An input to the offset correction block.
*   **`LV_TFU_STATE_1_IS_RAMP`**: Feedback for the previous offset correction state.
*   **`C_TFU_SENS_CONF_DF`**: Configuration parameter for the TFU sensor.
*   **`NC_FID_ERR_TFU_HPP_CONF`**: Error flag for TFU sensor High-Pressure Pump (HPP) configuration.
*   **`TFU_HPP_CONF`**: Configuration value for the TFU HPP sensor.
*   **`LC_SWI_TFU_CLC`**: A switch control for the TFU calculation logic.
*   **`NC_FID_ERR_TFU_HPP_MES`**: Error flag for TFU HPP sensor measurement.
*   **`PRM_LV_TFU_PRMS`**: Parameters related to TFU sensor plausibility.
*   **`ACTION_FARM_GetPermission_T3`**: An action import for obtaining permission for a specific task, likely related to sensor operation.

## Outputs
*   **`TFU`**: The final, corrected fuel temperature at the injector head.
*   **`TFU_MDL_2`**: An intermediate modeled fuel temperature value.
*   **`tfu_ofs_t_es`**: The calculated offset based on engine speed and states.
*   **`TFU_HPP_1`**: A flag or value indicating the plausibility/availability status of the TFU HPP sensor.
*   **`CONF_TFU_SENS_CONF`**: Status of the TFU sensor configuration.

## Logic Flow

1.  **Base Fuel Temperature and Modeled Temperature (`TFU_MDL`)**:
    *   The `clc_t_stat_puc_pu` signal, along with `TFU_MDL_1` and ambient temperature (`TAM`), feeds into the `TFU_MIN_TAM` (X.3.1) block, which likely computes an initial modeled fuel temperature (`TFU_MDL`).
    *   The `TFU_COR_STAT_PUC_PU` provides a fundamental fuel temperature value based on the engine's current operating state.

2.  **Environmental and Operating Condition Corrections**:
    *   Four dedicated correction factors are calculated using 1D/2D lookup tables (represented by the graph icons `IP_TFU_...`) based on key vehicle parameters:
        *   `Tvs-Cor.` uses Vehicle Speed (`VS`).
        *   `Twarm_up-Cor.` uses Oil Temperature (`TOIL`), addressing engine warm-up effects.
        *   `Tam-Cor.` uses Ambient Temperature (`TAM`).
        *   `Tco-Cor.` uses Coolant Temperature (`TCO`).
    *   These four correction values are summed with the `TFU_COR_STAT_PUC_PU` to form a raw corrected fuel temperature.

3.  **Dynamic Offset and Ramping Calculations**:
    *   **`TFU_OFS_T_ES` (X.3.1.2)**: This block calculates an offset (`tfu_ofs_t_es`) and related limits based on various engine status signals (like `T_ES`, `LV_T_ES_NOT_PLAUS`, etc.). This likely accounts for transient engine conditions.
    *   **`TFU_ST_RAMP` (X.3.1.3)**: Controlled by `CLC_3`, this block processes `TFU_MDL` to generate a ramped fuel temperature (`tfu_st_ramp`), smoothing out sudden changes or implementing time-based dynamics.
    *   **`TFU_IS_OFS_COR` (X.3.1.4)**: Controlled by `CLC_4`, this block takes `tfu_is_ofs` and internal feedback to compute another offset correction.

4.  **Limiting and Refined Modeled Fuel Temperature**:
    *   The raw corrected fuel temperature (from step 2) is fed into the `TFU_LIM_PUC` (X.3.1.5) block. This block also considers `TFU_MDL_3`, `TAM`, `tfu_is_ofs` (from X.3.1.4), `tfu_st_ramp` (from X.3.1.3), and control flags `CLC_1`, `CLC_2`. This block applies limits and further refines the modeled fuel temperature based on these dynamic inputs and operational constraints. The output of this block is the "modelled" fuel temperature value.

5.  **Sensor Plausibility and Value Selection**:
    *   **`TFU_SENS_CONF` (V.6.4)**: This block evaluates inputs like `C_TFU_SENS_CONF_DF`, `NC_FID_ERR_TFU_HPP_CONF`, and `TFU_HPP_CONF` to determine the configuration status of the TFU sensor (`CONF_TFU_SENS_CONF`).
    *   **`TFU_HPP` Logic**: A dedicated sub-system evaluates the plausibility and provides the value of the actual TFU sensor. This involves inputs such as `LC_SWI_TFU_CLC`, `NC_FID_ERR_TFU_HPP_MES`, `PRM_LV_TFU_PRMS`, `ACTION_FARM_GetPermission_T3`, and `TCO` (for plausibility checks, e.g., comparing TFU to coolant temperature). This logic outputs `TFU_HPP` (the sensor-derived fuel temperature) and `TFU_HPP_1` (a flag indicating sensor availability/plausibility: `1` for available/plausible, `0` for unavailable/implausible).
    *   **Final Selection**: A switch block (implemented using `Check ~= 0` and `NOT` gates to control a multiplexer) decides the final `TFU` output:
        *   If `TFU_HPP_1` is `1` (sensor available/plausible), the control signal to the switch is `0`, causing the switch to select `TFU_HPP` (the sensor-derived fuel temperature).
        *   If `TFU_HPP_1` is `0` (sensor unavailable/implausible), the control signal to the switch is `1`, causing the switch to select the output of `TFU_LIM_PUC` (the modelled fuel temperature).

6.  The selected value from step 5 is output as the final `TFU`.


--- Page 17 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink subsystem is the "Determination of the basic fuel temperature" (`FUSL, Fuel temperature`). It calculates a corrected fuel temperature value, `TFU_COR_STAT_PUC_PU`, by employing a state machine that selects between different calculation algorithms (Static, PU-State, or PUC-State) based on various input parameters. A low-pass filter is integrated into the process to ensure smooth transitions and avoid abrupt jumps in the calculated fuel temperature when switching between these algorithms.

## Inputs
The subsystem receives the following input signals:

*   **<LV_PU>**: Load or voltage parameter (appears as two distinct inputs on the diagram, likely for separate internal uses or different instances).
*   **<TQ_AV>**: Actual Torque value.
*   **<N_32>**: Engine speed (possibly sampled at 32ms intervals or related to a specific RPM range).
*   **<TAM>**: Ambient temperature.
*   **<MFF_SP_FUP_CTL>**: Mass Fuel Flow Setpoint for Fuel Pump Control (likely a desired fuel mass flow or a signal related to fuel pump operation).
*   **<TFU_COR_STAT_PUC_PU>**: Feedback of the previously calculated/filtered corrected fuel temperature. This is essential for iterative calculations and filter memory.
*   **<TFU_COR_STAT_PUC_PU_PREV_FIL>**: Feedback of a previously filtered value of the corrected fuel temperature, further indicating internal state or filter memory.

## Outputs
The subsystem generates the following output signals:

*   **<TFU_COR_STAT_PUC_PU>**: The primary calculated and filtered corrected fuel temperature. This signal is also used as feedback.
*   **<N_PUC_SAVE_TFU>**: Saved engine speed related to PUC state (appears twice, possibly different data types or purposes).
*   **<TFU_PUC_SAVE>**: Saved fuel temperature related to PUC state.
*   **<N_PU_SAVE_TFU>**: Saved engine speed related to PU state.
*   **<TFU_PU_SAVE>**: Saved fuel temperature related to PU state.
*   **<TFU_PUC>**: Fuel temperature calculated based on the PUC algorithm.
*   **<TFU_STAT>**: Fuel temperature calculated based on the Static algorithm.
*   **<TFU_PU>**: Fuel temperature calculated based on the PU algorithm.
*   **<TFU_COR_STAT_PUC_PU_PREV_FIL>**: The current filtered value, which will be the "previous filtered value" for the next calculation cycle. This is also used as feedback.
*   **<STATE_TFU>**: The current operating state of the internal state machine (Static, PU, or PUC).
*   **<FAC_TFU_STAT>**: A factor or flag related to the Static fuel temperature calculation.

The final output `clc_t_stat_puc_pu` (a blue data store/global variable block) is assigned the value of `TFU_COR_STAT_PUC_PU`.

## Logic Flow

1.  **Input Gathering**: The main subsystem, `CLC_TFU_COR_STAT_PUC_PU`, collects real-time vehicle and engine operational data, including various `LV_PU` signals, `TQ_AV` (torque), `N_32` (engine speed), `TAM` (ambient temperature), and `MFF_SP_FUP_CTL` (fuel flow setpoint).
2.  **State Feedback Integration**: Crucially, the system incorporates feedback loops. The previously calculated corrected fuel temperature (`TFU_COR_STAT_PUC_PU`) and its prior filtered value (`TFU_COR_STAT_PUC_PU_PREV_FIL`) are fed back into the subsystem. This feedback is vital for stateful logic, filtering, and ensuring continuity in the temperature calculation.
3.  **State Machine Decision**: Inside the `CLC_TFU_COR_STAT_PUC_PU` block, an internal state machine operates. Based on the current input conditions (e.g., engine speed, torque, other operational parameters) and potentially its own internal state, this state machine dynamically determines which specific fuel temperature calculation algorithm (Static, PU, or PUC) is most appropriate to use for the current operating conditions.
4.  **Algorithm Execution & Intermediate Outputs**: The selected algorithm calculates a raw fuel temperature. The block also outputs intermediate values and states like `TFU_PUC`, `TFU_STAT`, `TFU_PU` (representing temperatures from different algorithms), and various `SAVE` parameters (`N_PUC_SAVE_TFU`, `TFU_PUC_SAVE`, etc.) which likely store values for subsequent calculations or state persistence. The current state of the state machine is also output as `STATE_TFU`.
5.  **Low-Pass Filtering**: The calculated fuel temperature, specifically the one designated as `TFU_COR_STAT_PUC_PU`, undergoes a low-pass filtering process. This filtering is explicitly designed to smooth out any abrupt changes or "jumps" that might occur in the fuel temperature value when the state machine switches between different calculation algorithms. The feedback `TFU_COR_STAT_PUC_PU_PREV_FIL` supports this continuous filtering.
6.  **Corrected Fuel Temperature Output**: The smoothed and corrected fuel temperature, `TFU_COR_STAT_PUC_PU`, is then output from the subsystem. This is the primary result of the determination process.
7.  **Global Data Store Assignment**: Finally, the calculated and filtered `TFU_COR_STAT_PUC_PU` value is written to a global data store or assigned to a global variable named `clc_t_stat_puc_pu`. This makes the determined basic fuel temperature available for other modules within the larger automotive control system.


--- Page 18 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, titled "Calculation of TFU_COR_STAT_PUC_PU" (FUSL, Fuel temperature), is designed to calculate a corrected fuel temperature status. It identifies and processes different operational phases related to fuel temperature (`STAT`, `PUC`, and `PU`), calculates a specific fuel temperature value for each active phase, and then applies a final correction using a 2D lookup table to determine the overall corrected fuel temperature status. The system incorporates filtering, state-dependent logic, and the saving of previous values to ensure robust and accurate temperature estimation.

## Inputs

*   **`<LV_PU>`**: Raw input signal for the "PU" phase, likely representing a measured voltage or level.
*   **`<LV_PUC>`**: Raw input signal for the "PUC" phase, similar to `<LV_PU>`.
*   **`<TQ_AV>`**: Raw input signal for average torque or similar engine load parameter.
*   **`<STATE_TFU>`**: Current state of the Fuel Temperature Unit (TFU) or system.
*   **`<MFF_SP_FUP_CTL>`**: Control signal or flag related to fuel pressure or flow.
*   **`<TAM>`**: Ambient temperature or another relevant temperature input.
*   **`<N_32>`**: A common internal counter or timer signal, possibly representing elapsed time or a cycle count. It's used across multiple sub-calculations.
*   **`<N_PUC_SAVE_TFU>`**: Saved counter/timer value for the "PUC" phase.
*   **`<TFU_PUC_SAVE>`**: Saved fuel temperature value for the "PUC" phase.
*   **`<N_PU_SAVE_TFU>`**: Saved counter/timer value for the "PU" phase.
*   **`<TFU_PU_SAVE>`**: Saved fuel temperature value for the "PU" phase.
*   **`<TFU_COR_STAT_PUC_PU_PREV_FIL>`**: Previously calculated and filtered value of the corrected fuel temperature status, used for feedback or history.
*   **`fc_STAT`**: Control flag/condition for the "STAT" phase.
*   **`fc_PUC`**: Control flag/condition for the "PUC" phase.
*   **`fc_PU`**: Control flag/condition for the "PU" phase.
*   **`fc_save_PUC`**: Control flag/condition for saving "PUC" phase data.
*   **`fc_save_PU`**: Control flag/condition for saving "PU" phase data.
*   **`C_TFU_COR_STAT_PUC_PU_GRD_UP`**: Calibration parameter for the upper bound/gradient of the final 2D lookup table.
*   **`C_TFU_COR_STAT_PUC_PU_GRD_DOWN`**: Calibration parameter for the lower bound/gradient of the final 2D lookup table.

## Outputs

*   **`<FAC_TFU_STAT>`**: A factor or specific output related to the "STAT" phase fuel temperature calculation.
*   **`<TFU_STAT>`**: Calculated fuel temperature for the "STAT" phase.
*   **`<TFU_PUC>`**: Calculated fuel temperature for the "PUC" phase.
*   **`<TFU_PU>`**: Calculated fuel temperature for the "PU" phase.
*   **`<TFU_COR_STAT_PUC_PU>`**: The final, overall corrected fuel temperature status.

## Logic Flow

The diagram processes inputs through several parallel paths corresponding to different fuel temperature operational phases, merges the results, and applies a final correction.

1.  **Initial Input Filtering and Pre-processing**:
    *   The raw input signals `<LV_PU>` and `<LV_PUC>` are first passed through respective filter blocks (`CLC_LV_PU_FIL`, `CLC_LV_PUC_FIL`) to produce filtered `LV_PU` and `LV_PUC` signals. This likely smooths out noise or handles transient values.
    *   The `<TQ_AV>` signal undergoes processing via `C_TQ_AV_TFU_PU_COR` to yield `TQ_AV`.
    *   These filtered/processed signals, along with other inputs like `<STATE_TFU>`, control flags (`fc_STAT`, `fc_PUC`, `fc_PU`, `fc_save_PUC`, `fc_save_PU`), and system counter `<N_32>`, are then routed to the specific phase calculation blocks.

2.  **Phase-Specific Fuel Temperature Calculation**:
    The system has three main parallel paths, one for each operational phase:
    *   **Tstat Path (Top)**:
        *   `fc_STAT` and `<N_32>` are fed into a function block (f()), which likely handles state-dependent logic or timing for the STAT phase.
        *   The output of this function, along with `<MFF_SP_FUP_CTL>` and `<TAM>`, are inputs to the `CLC_TFU_STAT` subsystem.
        *   `CLC_TFU_STAT` calculates the fuel temperature for the "STAT" phase, producing `<FAC_TFU_STAT>` and `<TFU_STAT>`. `<TFU_STAT>` is then passed to the `Merge` block.
    *   **Tpuc Path (Middle)**:
        *   `fc_PUC` and `<N_32>` are fed into another function block (f()), specific to the PUC phase.
        *   Separately, `fc_save_PUC` and `<N_32>`, along with the previous corrected fuel temperature status `<TFU_COR_STAT_PUC_PU_PREV_FIL>`, are fed into a `SAVE_PUC` block. This block likely stores (`N_PUC_SAVE_TFU`) and retrieves (`TFU_PUC_SAVE`) values needed for PUC phase calculations based on the save condition.
        *   The output of the f() block (`<TFU_PUC>`), `N_PUC_SAVE_TFU`, and `TFU_PUC_SAVE` are inputs to the `CLC_TFU_PUC` subsystem.
        *   `CLC_TFU_PUC` calculates the fuel temperature for the "PUC" phase, outputting `<TFU_PUC>`, which is sent to the `Merge` block. (The accompanying text indicates filtering of short PUC-Phases here).
    *   **Tpu Path (Bottom)**:
        *   This path is analogous to the `Tpuc` path. `fc_PU` and `<N_32>` go into an f() block.
        *   `fc_save_PU`, `<N_32>`, and `<TFU_COR_STAT_PUC_PU_PREV_FIL>` are used by the `SAVE_PU` block to store (`N_PU_SAVE_TFU`) and retrieve (`TFU_PU_SAVE`) values for the PU phase.
        *   The output of the f() block (`<TFU_PU>`), `N_PU_SAVE_TFU`, and `TFU_PU_SAVE` are inputs to the `CLC_TFU_PU` subsystem.
        *   `CLC_TFU_PU` calculates the fuel temperature for the "PU" phase, outputting `<TFU_PU>`, which is sent to the `Merge` block.

3.  **Merging and Final Correction**:
    *   The calculated phase-specific fuel temperatures (`<TFU_STAT>`, `<TFU_PUC>`, `<TFU_PU>`) are fed into a `Merge` block. This block, often implicitly or explicitly tied to a state machine (such as `<STATE_TFU>`), selects or combines the appropriate fuel temperature value based on the current active operational phase.
    *   The output of the `Merge` block is then fed into a 2D lookup table block labeled "GRD" (V.5.4). This lookup table performs a final correction or mapping of the merged fuel temperature value. It takes `u` as its primary input, with `x_in`, `dLU`, and `dLD` likely defining the lookup table's x-axis and gradient parameters.
    *   The final output of the GRD block is `x_out`, which represents the overall corrected fuel temperature status, `<TFU_COR_STAT_PUC_PU>`.
    *   The calibration parameters `C_TFU_COR_STAT_PUC_PU_GRD_UP` and `C_TFU_COR_STAT_PUC_PU_GRD_DOWN` are linked to this GRD block, likely defining its calibration curves or operating limits.


--- Page 19 ---

This page contains two identical Simulink diagrams. I will analyze one of them (Figure 43.3.13) as its context is explicitly provided, and the functionality is the same for both.

## Function

The primary function of this Simulink diagram is to filter short pulses (both ON and OFF) from a binary input signal, `LV_PU`. It ensures that only sustained ON phases and sustained OFF phases of a "calibrateable duration" (defined by `C_DLY_PU_ON_OFF`) are passed through to the output, `LV_PU_FIL`. This effectively acts as a debouncing mechanism or a pulse width filter for digital signals, preventing momentary glitches or rapid state changes from affecting downstream logic.

## Inputs

*   **<LV_PU>**: A Boolean or discrete signal representing the raw "PU-Phase" state. This is the signal to be filtered.
*   **C_DLY_PU_ON_OFF**: A calibration parameter representing the minimum duration (delay time) an ON or OFF state must persist for it to be considered valid and affect the output. This is typically a time value.

## Outputs

*   **LV_PU_FIL**: A Boolean or discrete signal representing the filtered "PU-Phase" state. This output will only change state if the input `LV_PU` has held its new state for at least the `C_DLY_PU_ON_OFF` duration.

## Logic Flow

The system uses two specialized delay blocks and an RS Flip-Flop to achieve the filtering:

1.  **Input Signal Distribution:** The raw input signal `<LV_PU>` is simultaneously fed into two delay blocks: `PUC_On_Delay` and `PUC_Off_Delay`. Both delay blocks also receive the `C_DLY_PU_ON_OFF` parameter as their delay time (`T`).

2.  **`PUC_On_Delay` (for setting the output):**
    *   This block generates an output `y` which goes high **only if** its input `<LV_PU>` has been continuously high for at least the `C_DLY_PU_ON_OFF` duration.
    *   If `<LV_PU>` goes low, `y` goes low immediately.
    *   This `y` output is connected to the `SET` input of the `FF` (RS Flip-Flop).

3.  **`PUC_Off_Delay` (for resetting the output):**
    *   This block generates an output `y1` which goes low **only if** its input `<LV_PU>` has been continuously low for at least the `C_DLY_PU_ON_OFF` duration.
    *   If `<LV_PU>` goes high, `y1` goes high immediately.
    *   This `y1` output is then fed into a `NOT` gate.

4.  **`NOT` Gate:**
    *   The output of the `NOT` gate (which is `NOT y1`) is connected to the `RST` (Reset) input of the `FF` (RS Flip-Flop).
    *   Therefore, the `RST` input goes high **only if** `<LV_PU>` has been continuously low for `C_DLY_PU_ON_OFF` duration (because `y1` goes low, and `NOT y1` goes high).
    *   If `<LV_PU>` goes high, `RST` goes low immediately (because `y1` goes high, and `NOT y1` goes low).

5.  **RS Flip-Flop (`FF`):**
    *   The `FF` holds its current output state `Q` (which is `LV_PU_FIL`).
    *   **To set `LV_PU_FIL` to High:** The `SET` input must be high, and `RST` must be low. This occurs when `LV_PU` has been high for `C_DLY_PU_ON_OFF` (`SET` goes high) and `LV_PU` has just transitioned high or is holding high (`RST` is low).
    *   **To reset `LV_PU_FIL` to Low:** The `RST` input must be high, and `SET` must be low. This occurs when `LV_PU` has been low for `C_DLY_PU_ON_OFF` (`RST` goes high) and `LV_PU` has just transitioned low or is holding low (`SET` is low).
    *   **Filtering Action:** If `LV_PU` changes state but does not remain in the new state for the `C_DLY_PU_ON_OFF` duration, neither the `SET` nor the `RST` input of the `FF` will become active for a sufficient period to change the `LV_PU_FIL` output, thus effectively filtering out short pulses or glitches. The `FF` maintains its last valid state during these short transitions (when both `SET` and `RST` inputs are low).

In essence, this logic delays the propagation of both rising and falling edges of the `<LV_PU>` signal until they prove to be stable for a minimum duration `C_DLY_PU_ON_OFF`, thereby producing a robust, filtered output `LV_PU_FIL`.


--- Page 21 ---

This page contains two distinct Simulink diagrams, both related to the overall "FUSL, Fuel temperature" system, as indicated by the overarching title. I will analyze both diagrams sequentially.

---

## Analysis of Figure 43.3.15: Hot- and Cold-Map

### Primary Function
This diagram calculates an interpolated fuel temperature status (`<TFU_STAT>`) and an interpolation factor (`FAC_TFU_STAT`). It determines the fuel temperature status by blending between two different 2D lookup tables (maps) – one for "cold" conditions and one for "hot" conditions – based on the current engine speed and an actual fuel temperature input. The blending is controlled by an interpolation factor derived from ambient temperature and calibration parameters.

### Key Inputs
*   **`<MFF_SP_FUP_CTL>`**: Fuel temperature (likely actual measured fuel temperature or a control setpoint). This serves as the x-axis input for the 2D lookup tables.
*   **`<N_32>`**: Engine speed. This serves as the y-axis input for the 2D lookup tables.
*   **`<TAM>`**: Ambient temperature, a key input for the interpolation factor calculation.
*   **`C_TFU_STAT_OFS`**: A calibration parameter, likely an offset value used in the interpolation factor calculation.
*   **`C_TFU_STAT_STND`**: A calibration parameter, likely a standard or reference value used in the interpolation factor calculation.

### Key Outputs
*   **`<TFU_STAT>`**: The calculated fuel temperature status, which is an interpolated value between the "cold" and "hot" map outputs.
*   **`FAC_TFU_STAT`**: The calculated interpolation factor (ranging typically from 0 to 1), indicating the weighting between the "cold" and "hot" map values.

### Logic Flow
1.  **Map Lookups for Cold and Hot Conditions:**
    *   The `IP_TFU_STAT_COLD (V.7.7)` 2D lookup table (map) takes `<MFF_SP_FUP_CTL>` (x-axis) and `<N_32>` (y-axis) to output `P_val_COLD`, representing the fuel temperature status under "cold" conditions.
    *   The `IP_TFU_STAT_HOT (V.7.7)` 2D lookup table also takes `<MFF_SP_FUP_CTL>` (x-axis) and `<N_32>` (y-axis) to output `P_val_HOT`, representing the fuel temperature status under "hot" conditions.
2.  **Interpolation Factor (`FAC_TFU_STAT`) Calculation:**
    *   The ambient temperature `<TAM>` is summed with the offset calibration parameter `C_TFU_STAT_OFS` (V.5.4 addition block).
    *   The offset calibration parameter `C_TFU_STAT_OFS` is also summed with the standard calibration parameter `C_TFU_STAT_STND` (V.5.4 addition block).
    *   The result of `(<TAM> + C_TFU_STAT_OFS)` is divided by `(C_TFU_STAT_OFS + C_TFU_STAT_STND)` using a `V.5.3` division block. This output is `FAC_TFU_STAT`, the factor for interpolation.
3.  **Interpolated Fuel Temperature Status Calculation (Intermediate):**
    *   The difference between `P_val_COLD` and `P_val_HOT` is calculated (`P_val_COLD - P_val_HOT`) using a `V.5.4` subtraction block.
    *   This difference is then multiplied by `FAC_TFU_STAT` using a `V.5.3` multiplication block.
    *   Finally, this product is added to `P_val_HOT` using a `V.5.4` addition block. This computes the linearly interpolated value: `TFU_Interpolated = P_val_HOT + FAC_TFU_STAT * (P_val_COLD - P_val_HOT)`.
4.  **Conditional Selection and Final `<TFU_STAT>` Output:**
    *   `P_val_COLD` and `P_val_HOT` are compared for equality using an `==` block. The output is a boolean (true if equal, false if not).
    *   A `Switch` block (V.6.4, labeled "Check ~= 0") takes the boolean comparison result as its control input. It also takes `P_val_HOT` and the `TFU_Interpolated` value as its data inputs.
    *   If `P_val_COLD == P_val_HOT` (the difference is zero), the switch selects `P_val_HOT` (as the interpolation would yield the same value).
    *   If `P_val_COLD != P_val_HOT` (the difference is not zero), the switch selects the `TFU_Interpolated` value.
    *   The selected value from the `Switch` block then passes through a `V.6.1` block (likely a buffer or gain) and a generic function block `f()` to produce the final `<TFU_STAT>` output.

---

## Analysis of Figure 43.3.16: Calculation of the basic fuel temperature via the PUC-map

### Primary Function
This diagram calculates a "basic fuel temperature" (`<TFU_PUC>`) specific to a "PUC operating state" (likely related to a Pick-Up Correction or Power Up Cycle). It uses previously saved values of fuel temperature and engine speed in a 2D lookup table, and then adjusts the result based on the current engine speed.

### Key Inputs
*   **`<TFU_PUC_SAVE>`**: A previously saved fuel temperature value. This serves as the x-axis input for the 2D lookup table.
*   **`<N_PUC_SAVE_TFU>`**: A previously saved engine speed value. This serves as the y-axis input for the 2D lookup table.
*   **`<N_32>`**: The current engine speed. This input is used as an additive correction or influence on the map-derived value.

### Key Outputs
*   **`<TFU_PUC>`**: The calculated basic fuel temperature for the PUC operating state.

### Logic Flow
1.  **PUC Map Lookup:**
    *   The `IP_TFU_PUC (V.5.15)` 2D lookup table takes the saved fuel temperature `<TFU_PUC_SAVE>` (x-axis) and the saved engine speed `<N_PUC_SAVE_TFU>` (y-axis) as inputs.
    *   It outputs a `P_val`, which is an intermediate basic fuel temperature value derived from the PUC map.
2.  **Current Engine Speed Correction:**
    *   The `P_val` from the lookup table is summed with the current engine speed `<N_32>` using a `V.6.7` addition block. This implies that the current engine speed directly modifies or corrects the base temperature value obtained from the map.
3.  **Final `<TFU_PUC>` Output:**
    *   The result of the sum `(P_val + <N_32>)` then passes through a `V.6.1` block (likely a buffer or gain) and a generic function block `f()` to produce the final `<TFU_PUC>` output.


--- Page 22 ---

This page contains three Simulink diagrams labeled Figure 43.3.17, Figure 43.3.18, and Figure 43.3.19.

## Function
The primary function of these Simulink diagrams is to calculate and manage fuel temperature (TFU) values during different engine operating phases, specifically referred to as "PU" (Power Up/Operating Phase) and "PUC" (Pre-Update/Pre-Charge, or similar pre-operating phase).

*   **Figure 43.3.17** calculates the basic fuel temperature (`TFU_PU`) for the PU phase. It uses a lookup table (referred to as a "PU-map") to apply a correction based on the difference between a saved engine speed and the current engine speed, adding this correction to a previously saved fuel temperature.
*   **Figure 43.3.18** is responsible for storing the current engine speed (`N_32`) and a filtered fuel temperature (`TFU_COR_STAT_PUC_PU_PREV_FIL`) specifically for the PUC phase.
*   **Figure 43.3.19** performs a similar storage function but for the PU phase, saving the current engine speed and filtered fuel temperature for subsequent use in the `TFU_PU` calculation.

This system is part of a larger "Fuel temperature" (FUSL) control logic, likely ensuring accurate fuel temperature estimation or regulation across different engine states.

## Inputs
**For Figure 43.3.17 (TFU_PU Calculation):**
*   `<N_32>`: Current engine speed.
*   `<N_PU_SAVE_TFU>`: Engine speed value saved during a previous PU phase (output from Figure 43.3.19).
*   `<TFU_PU_SAVE>`: Fuel temperature value saved during a previous PU phase (output from Figure 43.3.19).

**For Figure 43.3.18 (TFU_PUC Storage):**
*   `<N_32>`: Current engine speed.
*   `<TFU_COR_STAT_PUC_PU_PREV_FIL>`: Corrected, static, previous filtered fuel temperature (used for both PUC and PU phases).

**For Figure 43.3.19 (TFU_PU Storage):**
*   `<N_32>`: Current engine speed.
*   `<TFU_COR_STAT_PUC_PU_PREV_FIL>`: Corrected, static, previous filtered fuel temperature (used for both PUC and PU phases).

## Outputs
**For Figure 43.3.17 (TFU_PU Calculation):**
*   `<TFU_PU>`: The calculated basic fuel temperature for the PU operating phase.

**For Figure 43.3.18 (TFU_PUC Storage):**
*   `N_PUC_SAVE_TFU`: Stored engine speed value specifically for the PUC phase.
*   `TFU_PUC_SAVE`: Stored fuel temperature value specifically for the PUC phase.

**For Figure 43.3.19 (TFU_PU Storage):**
*   `N_PU_SAVE_TFU`: Stored engine speed value specifically for the PU phase.
*   `TFU_PU_SAVE`: Stored fuel temperature value specifically for the PU phase.

## Logic Flow

The system's logic flow is composed of three interconnected parts:

**1. Calculation of Basic Fuel Temperature for the PU-map (Figure 43.3.17):**
    *   **Step 1: Calculate Engine Speed Deviation:** The current engine speed (`<N_32>`) is subtracted from a previously saved engine speed (`<N_PU_SAVE_TFU>`) which represents the engine speed at the point of entering the PU phase or a relevant snapshot.
    *   **Step 2: Lookup Temperature Correction:** The calculated engine speed deviation (`<N_PU_SAVE_TFU> - <N_32>`) serves as the input (`x_val`) to a 1-D lookup table named `IP_TFU_PU` (the "PU-map"). This lookup table outputs a correction value (`IP_val`) corresponding to the given speed deviation.
    *   **Step 3: Scale Correction Factor:** The `IP_val` (correction from the lookup table) is multiplied by a gain factor `V.6.7`.
    *   **Step 4: Apply Temperature Correction:** The scaled correction factor is then added to a previously saved fuel temperature (`<TFU_PU_SAVE>`). This `TFU_PU_SAVE` represents the fuel temperature captured at the point of entering the PU phase or a relevant snapshot.
    *   **Step 5: Final Scaling:** The result of the temperature correction is further scaled by another gain factor `V.6.1`.
    *   **Step 6: Output Basic Fuel Temperature:** The final scaled value is output as `<TFU_PU>`, which is the calculated basic fuel temperature for the current PU operating phase.
    *   *Condition*: The text notes this calculation is only done if a PU-Phase follows directly after a PUC-Phase.

**2. Storage of Values for TFU_PUC (Figure 43.3.18):**
    *   **Step 1: Input Data:** The current engine speed (`<N_32>`) and the general filtered fuel temperature (`<TFU_COR_STAT_PUC_PU_PREV_FIL>`) are provided.
    *   **Step 2: Store Engine Speed:** The current engine speed (`<N_32>`) is saved into a dedicated data store or memory location identified as `N_PUC_SAVE_TFU`. This value represents the engine speed specifically for the PUC phase.
    *   **Step 3: Store Fuel Temperature:** The filtered fuel temperature (`<TFU_COR_STAT_PUC_PU_PREV_FIL>`) is saved into a dedicated data store or memory location identified as `TFU_PUC_SAVE`. This value represents the fuel temperature specifically for the PUC phase.
    *   *Trigger*: This storage operation is explicitly mentioned to be "triggered by the state machine," likely when the system enters or is operating within the PUC state. The `f()` block suggests a function-call triggered subsystem or a similar event-driven execution.

**3. Storage of Values for TFU_PU (Figure 43.3.19):**
    *   **Step 1: Input Data:** Similar to the PUC storage, the current engine speed (`<N_32>`) and the general filtered fuel temperature (`<TFU_COR_STAT_PUC_PU_PREV_FIL>`) are provided.
    *   **Step 2: Store Engine Speed:** The current engine speed (`<N_32>`) is saved into a dedicated data store or memory location identified as `N_PU_SAVE_TFU`. This value represents the engine speed specifically for the PU phase.
    *   **Step 3: Store Fuel Temperature:** The filtered fuel temperature (`<TFU_COR_STAT_PUC_PU_PREV_FIL>`) is saved into a dedicated data store or memory location identified as `TFU_PU_SAVE`. This value represents the fuel temperature specifically for the PU phase.
    *   *Trigger*: Like the PUC storage, this operation is also "triggered by the state machine," likely when the system enters or is operating within the PU state. These stored values (`N_PU_SAVE_TFU` and `TFU_PU_SAVE`) are then used as inputs for the `TFU_PU` calculation shown in Figure 43.3.17.


--- Page 23 ---

This page contains a Simulink diagram that incorporates a Stateflow chart.

## Function

The primary function of this Simulink diagram is to determine and manage the active fuel temperature calculation algorithm (Static, PU-Phase, or PUC-Phase) based on various operating conditions and phase transitions. It also controls signals for saving critical data related to these phases for future calculations. This process ensures the correct fuel temperature model is applied under different engine operation scenarios (e.g., cold start, warm-up, transient conditions).

## Inputs

The key inputs to this system are:

*   **LV_PU (1):** A boolean flag indicating the occurrence or activation of a "PU-Phase" (likely a "Performance Uplift" or similar transient phase).
*   **LV_PUC (2):** A boolean flag indicating the occurrence or activation of a "PUC-Phase" (likely a "Performance Uplift Correction" or another specific transient phase).
*   **TQ_AV (3):** An average torque value, used in specific conditions for phase management.
*   **C_TQ_AV_TFU_PU_COR (4):** A calibrated constant or threshold for average torque, used to correct or sustain the PU-Phase calculation.

## Outputs

The key outputs from this system are:

*   **STATE_TFU (1):** The current overall state or phase of the fuel temperature algorithm (e.g., Static, PU, PUC).
*   **fc_STAT (2):** A boolean flag indicating that the "Static" fuel temperature calculation (using hot/cold-map) should be active.
*   **fc_PUC (3):** A boolean flag indicating that the "PUC-map" fuel temperature calculation should be active.
*   **fc_PU (4):** A boolean flag indicating that the "PU-map" fuel temperature calculation should be active.
*   **fc_save_PUC (5):** A trigger signal or flag to initiate saving of values relevant for a subsequent PUC-Phase calculation.
*   **fc_save_PU (6):** A trigger signal or flag to initiate saving of values relevant for a subsequent PU-Phase calculation.

Additionally, there are several exported constants representing possible states or configurations:
*   **NC_STATE_TFU_STAT:** Named constant for the Static state.
*   **NC_STATE_TFU_PU:** Named constant for the PU-Phase state.
*   **NC_STATE_TFU_PUC:** Named constant for the PUC-Phase state.
*   **NC_STATE_TFU_PU_AFTER_PUC:** Named constant for a specific PU-Phase state that occurs after a PUC-Phase.

## Logic Flow

The core logic is implemented within the central Stateflow chart, which manages the transitions and activation of different fuel temperature calculation phases based on input conditions.

1.  **Initialization/Default State:**
    *   Normally, the system defaults to the "Static" calculation, indicated by `fc_STAT` being active. This uses a standard hot- and cold-map for fuel temperature. `STATE_TFU` would likely be `NC_STATE_TFU_STAT`.

2.  **PU-Phase Occurrence (`LV_PU == 1`):**
    *   If a PU-Phase occurs (`LV_PU` becomes active), the system might transition.
    *   Upon entering a PU-Phase (or in anticipation of a PUC-Phase), values like engine speed (N_32) and static fuel temperature are stored via a "SAVE_PUC" subfunction. This action is likely triggered by `fc_save_PUC`. The aim here is to prepare data for a potential subsequent PUC-Phase.
    *   If a PU-Phase follows *directly* after a PUC-Phase, and if `TQ_AV > C_TQ_AV_TFU_PU_COR`, then the calculation uses the "PU-map" (`fc_PU` is active). In this specific scenario, necessary values for the PU-Phase calculation are stored by a "SAVE_PU" subfunction, likely triggered by `fc_save_PU`.
    *   The "PU-map" calculation can remain active as long as `TQ_AV < C_TQ_AV_TFU_PU_COR`, even if `LV_PUC` is inactive. This suggests a hysteresis or sustained state based on torque conditions, possibly to cover part-load phases during a PUC-Phase or gear shifts.

3.  **PUC-Phase Occurrence (`LV_PUC == 1`):**
    *   If a PUC-Phase occurs (`LV_PUC` becomes active), the system transitions to use the "PUC-map" calculation (`fc_PUC` is active).
    *   The necessary values for this calculation would have been stored either when a previous PU-Phase was entered or directly when the PUC-Phase was entered (if no preceding PU-Phase). This confirms the importance of the `fc_save_PUC` mechanism.

4.  **State and Flag Updates:**
    *   Based on the active state determined by the Stateflow chart (Static, PU, PUC, or PU_AFTER_PUC), the `STATE_TFU` output is set to the corresponding named constant (`NC_STATE_TFU_STAT`, `NC_STATE_TFU_PU`, `NC_STATE_TFU_PUC`, or `NC_STATE_TFU_PU_AFTER_PUC`).
    *   The `fc_STAT`, `fc_PUC`, and `fc_PU` flags are activated or deactivated to indicate which specific fuel temperature calculation method is to be used.
    *   The `fc_save_PUC` and `fc_save_PU` flags are set at specific entry points or under certain conditions to trigger the saving of relevant engine data for upcoming phase calculations.

In essence, the system acts as a state machine that dynamically switches between different fuel temperature models to maintain accuracy and efficiency under varying engine operating conditions, utilizing torque and phase flags as critical decision parameters.


--- Page 24 ---

This page contains two types of diagrams commonly found within the MathWorks Simulink environment: a Stateflow chart and a Simulink block diagram. Both are analyzed below.

## Analysis of Stateflow Chart (Figure 43.3.21: State_Machine)

### Function
This Stateflow chart defines the state logic for a "Fuel Unit" (TFU) system, managing its operational phases through a series of discrete states and transitions based on input conditions. It primarily controls the progression through different "Power Up" (PU) related states.

### Inputs
*   **STATE_TFU**: The current state of the TFU (e.g., `NC_STATE_TFU_STAT`, `NC_STATE_TFU_PU`, `NC_STATE_TFU_PUC`, `NC_STATE_TFU_PU_AFTER_PUC`). This is both an input (for transition conditions) and an output (as it's set).
*   **LV_PU**: A boolean flag indicating a "Power Up" request.
*   **LV_PUC**: A boolean flag indicating a "Power Up Confirm" condition.
*   **TQ_AV**: Available Torque, likely an engine load or torque output parameter.
*   **C_TQ_AV_TFU_PU_COR**: A constant threshold for available torque, used for TFU power up correction.

### Outputs
*   **STATE_TFU**: The updated state of the TFU, which is set to one of the defined constants (`NC_STATE_TFU_STAT`, `NC_STATE_TFU_PU`, `NC_STATE_TFU_PUC`, `NC_STATE_TFU_PU_AFTER_PUC`) upon entering a state.
*   **fc_save_PU**: A function call or event triggered upon entering the `PU` state.
*   **fc_save_PUC**: A function call or event triggered upon entering the `PUC` state.
*   **fc_PU**: A function call or event triggered upon entering the `PU_AFTER_PUC` state.
*   **fc_STAT**: A function call or event triggered upon entering the `STAT` state.

### Logic Flow
The chart represents a sequential state machine with four main states: `STAT`, `PU`, `PUC`, and `PU_AFTER_PUC`. The transitions between these states are guarded by logical conditions.

1.  **From `STAT` state (Static):**
    *   If `LV_PU` is true (Power Up requested), the system transitions to the `PU` state.
    *   Upon entering `PU`, `STATE_TFU` is set to `NC_STATE_TFU_PU`, and `fc_save_PU` is executed.

2.  **From `PU` state (Power Up):**
    *   If `LV_PUC` is true (Power Up Confirmed), the system transitions to the `PUC` state.
    *   Upon entering `PUC`, `STATE_TFU` is set to `NC_STATE_TFU_PUC`, and `fc_save_PUC` is executed.

3.  **From `PUC` state (Power Up Confirm):**
    *   If `LV_PUC` AND `LV_PU` AND `TQ_AV > C_TQ_AV_TFU_PU_COR` are all true, the system transitions to the `PU_AFTER_PUC` state. This indicates a validated and torque-sufficient power-up.
    *   Alternatively, if `LV_PUC` is false AND `LV_PU` is false, the system transitions back to the `STAT` state. This acts as a reset if power-up conditions are no longer met.
    *   Upon entering `PU_AFTER_PUC`, `STATE_TFU` is set to `NC_STATE_TFU_PU_AFTER_PUC`, and `fc_PU` is executed.

4.  **From `PU_AFTER_PUC` state (Power Up After Power Up Confirm):**
    *   If `LV_PUC` is false AND `LV_PU` is false, the system transitions back to the `STAT` state. This signifies the completion or deactivation of the power-up sequence.
    *   Upon entering `STAT` (from either `PUC` or `PU_AFTER_PUC`), `STATE_TFU` is set to `NC_STATE_TFU_STAT`, and `fc_STAT` is executed.

## Analysis of Simulink Block Diagram (Figure 43.3.22: Calculation of T_ES based TFU offset with fade-out based on T_AST)

### Function
This Simulink diagram calculates a dynamic offset for a Temperature-related Fuel Unit (TFU) based primarily on the Engine Start Temperature (T_ES). It incorporates a fade-out mechanism using the Engine Actuator System Temperature (T_AST) and applies rate limiting (gradient control) to ensure smooth transitions of the offset value, considering various engine conditions and plausibility checks.

### Inputs
*   **T_ES**: Engine Start Temperature.
*   **LV_T_ES_NOT_PLAUS**: Boolean flag, `1` if T_ES is detected as not plausible.
*   **LV_FIRST_VLD_TOOTH**: Boolean flag, `1` during the first valid tooth signal (indicating initial engine cranking/rotation).
*   **C_T_ES_TFU_OFS_RST_MIN**: Constant, minimum reset value for the TFU offset based on T_ES.
*   **C_TFU_OFS_GRD_INC_SLOW**: Constant, slow positive gradient (ramp-up rate) for the TFU offset.
*   **C_TFU_OFS_GRD_INC_FAST**: Constant, fast positive gradient (ramp-up rate) for the TFU offset.
*   **C_TFU_OFS_GRD_DEC_SLOW**: Constant, slow negative gradient (ramp-down rate) for the TFU offset.
*   **C_TFU_OFS_GRD_DEC_FAST**: Constant, fast negative gradient (ramp-down rate) for the TFU offset.
*   **TFU_OFS_T_ES_DIF_PREV**: Previous value of the TFU offset difference (likely for feedback to the rate limiter).
*   **LV_STST_STOP_CYC**: Boolean flag, `1` if a Stop/Start cycle is active.
*   **LV_ENG_LST_ST_ST_ACT**: Boolean flag, `1` if the engine was recently involved in a start/stop activity.
*   **LC_TFU_OFS_T_ES_IGK_ACT**: Constant/Boolean, related to ignition key activity.
*   **T_AST**: Engine Actuator System Temperature (used for the fade-out factor).
*   **LV_ST_END**: Boolean flag, `1` if a specific engine state/mode has ended.
*   **IP_val**: An intermediate value, potentially another correction or base offset summed with `TFU_OFS_T_ES_COR`.
*   **IP_TFU_OFS_T_ES_FDOU**: An alternative intermediate fade-out offset, used when `LV_ST_END` is active.

### Outputs
*   **TFU_OFS_T_ES**: The final calculated and rate-limited TFU offset based on T_ES.
*   **TFU_OFS_T_ES_DIF_LIM**: A limited difference of the TFU offset, potentially for monitoring or diagnostic purposes.

### Logic Flow

1.  **Plausibility & Reset Condition Logic:**
    *   An `OR` gate (V.6.1) combines `LV_T_ES_NOT_PLAUS` with the result of a comparison: `LV_FIRST_VLD_TOOTH < C_T_ES_TFU_OFS_RST_MIN`. If T_ES is implausible, or if the first valid tooth signal is below a minimum reset threshold, a reset or specific initial handling is triggered.
    *   Another `OR` gate (V.6.1) combines `LV_STST_STOP_CYC`, `LV_ENG_LST_ST_ST_ACT`, and `LC_TFU_OFS_T_ES_IGK_ACT`. This composite signal indicates specific engine operating conditions (e.g., during start-stop events) that might influence the selection of ramp rates for the offset.

2.  **Base TFU Offset Correction (`TFU_OFS_T_ES_BAS`):**
    *   The `T_ES` input is fed into a 1-D Lookup Table (`f()`, V.5.15) to determine `TFU_OFS_T_ES_COR`, which is the base static temperature correction.
    *   This `TFU_OFS_T_ES_COR` is then summed with `IP_val` in a Sum block to calculate `TFU_OFS_T_ES_BAS` (Basic TFU Offset).

3.  **Fade-out Factor Calculation (`FAC_TFU_OFS_T_ES_T_AST`):**
    *   The `T_AST` input is fed into another 1-D Lookup Table (`f()`, V.5.15) to produce `FAC_TFU_OFS_T_ES_T_AST`. This factor is typically between 0 and 1, designed to gradually reduce the effect of the temperature offset as `T_AST` increases, signifying engine warm-up.

4.  **Fade-out Application (`TFU_OFS_T_ES_FDOU`):**
    *   The `TFU_OFS_T_ES_BAS` is multiplied by `FAC_TFU_OFS_T_ES_T_AST` in a Product block (V.5.3) to yield `TFU_OFS_T_ES_FDOU` (Fade-out TFU Offset).
    *   A Switch block (represented by the multiplexer-like symbol with `LV_ST_END`) selects between `TFU_OFS_T_ES_FDOU` and `IP_TFU_OFS_T_ES_FDOU`. If `LV_ST_END` is true, `IP_TFU_OFS_T_ES_FDOU` is used; otherwise, `TFU_OFS_T_ES_FDOU` is used. This implies special fade-out behavior or initialization at the end of a state or cycle.

5.  **Gradient Limiting (Ramp Rate Control):**
    *   Several "Switch" blocks (V.6.4, with condition "Check ~= 0") dynamically select the appropriate "Limit Up" (`LU`) and "Limit Down" (`LD`) ramp rates from the constants (`C_TFU_OFS_GRD_INC_SLOW/FAST`, `C_TFU_OFS_GRD_DEC_SLOW/FAST`). The selection conditions for these switches are implicit but would be based on the engine operating state (e.g., whether the engine is in a rapid warm-up phase, a cool-down, or normal operation, potentially using the output from the OR gate in step 1).
    *   The selected `LU` and `LD` values, along with the output from step 4 (the desired fade-out offset) and `TFU_OFS_T_ES_DIF_PREV`, are fed into a Rate Limiter block (V.6.10, symbolized by `x_out` and `dx/dt`). This block ensures that the final `TFU_OFS_T_ES` signal does not change faster than the allowed `LU` (for increase) or `LD` (for decrease) rates, providing smooth transitions.
    *   The output of this Rate Limiter is the final `TFU_OFS_T_ES`.

6.  **Limited Difference Output (`TFU_OFS_T_ES_DIF_LIM`):**
    *   A block calculates and limits the difference between the current `TFU_OFS_T_ES` and `TFU_OFS_T_ES_DIF_PREV`, outputting `TFU_OFS_T_ES_DIF_LIM`. This can be used for feedback, diagnostics, or other control logic.


--- Page 25 ---

This page does contain a Simulink diagram.

## Function

This Simulink diagram implements a **Fuel Temperature Unit (TFU) correction function specifically active during the engine start phase.** Its primary purpose is to manage and adjust the reported fuel temperature (`TFU`) value during cold start conditions or transitions, ensuring a smooth and controlled ramp-up or setting of the fuel temperature based on various operational states and calculated values. This prevents sudden changes and aids in stable engine operation right after ignition.

The functionality is further explained by the accompanying text:
*   Before start: If the calculated TFU (`Calc-TFU`) is greater than a reference temperature (`TCO`), the TFU is held at `TCO`. If `Calc-TFU` is less than `TCO`, TFU is directly set to `Calc-TFU`.
*   After engine start (`LV_ST_END == 1`): The TFU value is gradually ramped from `TCO` to `Calc-TFU` using a defined increment (`C_TFU_COR_INC`). Once `Calc-TFU` is reached, TFU remains at `Calc-TFU`.
*   The function can be deactivated after the start phase, allowing the TFU to revert to its directly calculated value without any ramping.

## Inputs

The key inputs to this system are:

*   **`<input>`**: A generic input, likely representing a calculated or initial fuel temperature, or a related reference value (`Calc-TFU` or `TCO` as per text).
*   **`<TFU_MDL>`**: A modeled or calculated fuel temperature, likely the `Calc-TFU` mentioned in the text.
*   **`<feedback>`**: A feedback signal from the output `<LV_TFU_STATE_1_ST_RAMP>`, indicating a previous state or value of the ramping process.
*   **`<LV_ST_END>`**: A boolean flag (Load Value - Start End) indicating if the engine start sequence is complete (`LV_ST_END == 1`).
*   **`<T_AST>`**: A processed temperature value derived from the `<input>` and another unnamed signal (via multiplexer '1'), likely serving as the initial or reference temperature (`TCO`) for the ramp.
*   **`<TFU_MDL_2>`**: Another variant or source of modeled fuel temperature, potentially for comparison or specific conditions.
*   **`<TFU_H_RES_ST_RAMP>`**: A signal related to hysteresis or resistance in the ramping process (likely an internal state from a previous cycle).
*   **`<LV_TFU_STATE_1_ST_RAMP>`**: A state variable related to the fuel temperature ramp, fed back from the previous step.
*   **`<LV_TFU_STATE_2_ST_RAMP>`**: Another state variable related to the fuel temperature ramp, fed back from the previous step.

## Outputs

The key outputs of this system are:

*   **`<tfu_st_ramp>`**: The primary output representing the corrected and ramped fuel temperature value during the start phase.
*   **`<LV_TFU_STATE_1_ST_RAMP>`**: A state variable reflecting the current state of the fuel temperature ramping logic. This signal is also fed back as an input (`<feedback>`) for the next calculation cycle.

## Logic Flow

1.  **Initial Temperature/Reference Input (`<T_AST>` Generation):**
    *   A multiplexer labeled '1' combines the generic `<input>` with another internal signal (which is not explicitly labeled on its own wire but seems to be part of the `CLC_TFU_ST_RAMP2` input group). This multiplexer outputs `<T_AST>`, which serves as a crucial initial or reference temperature (likely `TCO`) for the subsequent TFU correction logic.

2.  **Core TFU Ramping and Correction (`CLC_TFU_ST_RAMP2` Block):**
    *   This is the central processing unit, taking a multitude of inputs:
        *   **Operational State:** `<LV_ST_END>` informs the block whether the engine start phase is ongoing or finished. This directly dictates which part of the TFU correction logic (pre-start or post-start ramping) is active.
        *   **Reference Temperatures:** `<T_AST>` (initial/reference temperature, e.g., `TCO`) and `<TFU_MDL>` (calculated fuel temperature, e.g., `Calc-TFU`).
        *   **Internal State/Feedback:** `<TFU_H_RES_ST_RAMP>`, `<LV_TFU_STATE_1_ST_RAMP>`, and `<LV_TFU_STATE_2_ST_RAMP>` are state variables or parameters that allow the block to maintain memory of its previous operational state, current ramp value, and potentially thresholds for the ramping function (e.g., `C_TFU_COR_INC`). These inputs are crucial for implementing the step-by-step ramping behavior.
    *   Inside `CLC_TFU_ST_RAMP2`, the logic described in the text is applied:
        *   **Before Start:** TFU is set to `TCO` if `Calc-TFU > TCO`, or to `Calc-TFU` if `Calc-TFU < TCO`.
        *   **After Start (`LV_ST_END == 1`):** TFU ramps from `TCO` towards `Calc-TFU` by adding `C_TFU_COR_INC` in each step until `Calc-TFU` is reached.
        *   The function also manages its deactivation based on `C_TFU_CLC_ST_END` if the correction is no longer needed after the start phase.
    *   The block then computes `tfu_st_ramp` (the current corrected fuel temperature) and updates its internal state variables (`TFU_H_RES_ST_RAMP`, `<LV_TFU_STATE_1_ST_RAMP>`, `<LV_TFU_STATE_2_ST_RAMP>`) for the next iteration.

3.  **Output Processing (`f()` Block and External Output):**
    *   The `tfu_st_ramp` value calculated by `CLC_TFU_ST_RAMP2` is passed through a block labeled `f()`. This block might apply a simple transformation (e.g., unit delay, gain, or simply rename the signal) before outputting it as the final external output `<tfu_st_ramp>`.

4.  **State Feedback Loop:**
    *   The output `<LV_TFU_STATE_1_ST_RAMP>` from `CLC_TFU_ST_RAMP2` is fed back to the `<feedback>` input on the left side of the diagram. This creates a feedback loop, ensuring that the ramping function is stateful and can correctly increment or manage the TFU over time, remembering its previous values and progression. This closed-loop behavior is essential for controlled ramping.


--- Page 26 ---

This page contains a Simulink-like diagram, typical for automotive embedded software development, outlining a control strategy for fuel temperature ramping.

## Function

The primary function of this diagram is to manage and control the "start ramp" for fuel temperature (TFU). This process ensures a smooth and controlled transition of the fuel temperature from an initial state (likely engine coolant temperature, TCO, as indicated in the text descriptions) to a calculated target fuel temperature. The system dynamically selects between different ramp calculation methods or modeled values based on the current state of the engine (e.g., start phase, ramp active, ramp completed) and external conditions. It incorporates mechanisms for resetting the ramp logic and determining when the ramp should be disabled, allowing the system to use the direct calculated fuel temperature.

## Inputs

*   **`<LV_ST_END>` (Logic Value - Start End):** A boolean signal likely indicating the conclusion of a general start sequence.
*   **`<LV_TFU_STATE_2_ST_RAMP>` (Logic Value - TFU State 2 Start Ramp):** A boolean signal representing a specific state within the TFU start ramp logic (State 2).
*   **`<TFU_H_RES_ST_RAMP>` (TFU High Resolution Start Ramp):** A numeric input, likely the current value or an initial estimate for the high-resolution fuel temperature ramp.
*   **`<TFU_MDL_2>` (TFU Modeled 2):** A numeric input representing a modeled fuel temperature from the last recurrence, which is initialized with TCO (Coolant Temperature Out).
*   **`<TFU_MDL>` (TFU Modeled):** Another numeric input representing a modeled fuel temperature, potentially used for different stages or comparisons.
*   **`<T_AST>` (Time - Absolute Start Time):** A numeric input representing time, possibly elapsed time since engine start or a system timer.
*   **`C_T_TFU_CLC_ST_END` (Constant - TFU Calculation Start End Time):** A numeric constant defining a time threshold for the TFU calculation start end.
*   **`IGK_OFF_2_ON` (Ignition OFF 2 ON):** A boolean signal, likely indicating a system state related to ignition, used for resetting internal flags.
*   **`ERU_2_ES` (Engine Run Unit 2 Error State):** A boolean signal, likely indicating an engine runtime error state, also used for resetting internal flags.

## Outputs

*   **`<LV_TFU_STATE_2_ST_RAMP>` (Logic Value - TFU State 2 Start Ramp):** This signal appears as both an input and an output, suggesting it's an updated or controlled state variable for the TFU start ramp state 2.
*   **`TFU_H_RES_ST_RAMP` (TFU High Resolution Start Ramp):** An updated numeric value representing the high-resolution fuel temperature ramp.
*   **`TFU_RES_ST_RAMP` (TFU Resulting Start Ramp):** The final numeric output of the merged ramp value, representing the controlled fuel temperature during the ramp phase.
*   **`<LV_TFU_STATE_1_ST_RAMP>` (Logic Value - TFU State 1 Start Ramp):** A boolean signal representing a specific state within the TFU start ramp logic (State 1).
*   **`t_fu_st_ramp` (TFU Start Ramp):** A boolean or numeric output indicating the status or activity of the TFU start ramp function.

## Logic Flow

The diagram presents a state-based control logic, likely executed periodically, using conditional blocks (`if`, `else`), switches, and feedback loops.

1.  **Top Path - TFU High-Resolution Ramp Calculation & State 2 Control:**
    *   **FFP_2 Control:** A block labeled `FFP_2` (likely a Flip-Flop or state machine) is reset by `IGK_OFF_2_ON` and `ERU_2_ES`. This means the ramp calculation state can be reset under specific engine conditions.
    *   **State 2 Condition Evaluation:** Inputs `<LV_ST_END>` and `<LV_TFU_STATE_2_ST_RAMP>` are fed into a switch (V.6.4, "Check ~= 0"). The output of this switch, along with `FFP_2`, determines the condition for an `if-else` block (`cond_if`, V.6.0).
    *   **Ramp Phase Selection:**
        *   **IF `cond_if` is true (Ramp for Start Phase):** The logic proceeds to `TFU_Ramp_for_start_phase` (X.3.1.3.1.1). This block calculates the TFU ramp from TCO to `Calc.-TFU` (calculated TFU), especially if `Calc.-TFU > TCO` at start. It takes `<TFU_H_RES_ST_RAMP>` and `TFU_tmp` as inputs and outputs an updated `TFU_H_RES_ST_RAMP` and `TFU_tmp`.
        *   **ELSE (Ramp Not Started Yet):** The logic proceeds to `TFU_Ramp_not_started_yet` (X.3.1.3.1.2). This block takes `TFU_MDL_2` (modeled TFU initialized with TCO) as input and outputs `TFU_H_RES_ST_RAMP` and `TFU_tmp`.
    *   **Output Merge:** The `TFU_H_RES_ST_RAMP` and `TFU_tmp` outputs from both conditional paths are merged to produce the final `TFU_RES_ST_RAMP` output, which is the resulting fuel temperature ramp value. The `TFU_tmp` output also feeds back into the merge block.

2.  **Lower Path - TFU Modeled Value & State 1 Control:**
    *   **FFP_1 Control:** Similar to `FFP_2`, `FFP_1` is also reset by `IGK_OFF_2_ON` and `ERU_2_ES`, indicating a parallel or related reset mechanism for another aspect of the ramp logic.
    *   **State 1 Condition Evaluation:** Inputs `<TFU_MDL>` and `<LV_TFU_STATE_1_ST_RAMP>` are fed into another switch (V.6.4, "Check ~= 0"). The output of this switch, along with `FFP_1`, determines the condition for a second `if-else` block (`cond_if`, V.6.0).
    *   **Ramp End Check & State 1 Update:**
        *   **IF `cond_if` is true (Calculate TFU Start Ramp):** The logic proceeds to `Calc_TFU_st_ramp` (V.6.0). This block evaluates if the ramp has reached `Calc.-TFU` and if `TFU` should now equal `Calc.-TFU`. It outputs the boolean `LV_TFU_STATE_1_ST_RAMP`.
        *   **ELSE (TFU Start Ramp Active):** The output of `FFP_1` is inverted by a `NOT` gate (V.5.4) and then feeds into `TFU_st_ramp_active` (V.6.4). The `LV_TFU_STATE_1_ST_RAMP` is also fed back into the "Check ~= 0" switch.

3.  **Ramp Disable / Final TFU Decision:**
    *   **Time-Based Disable:** The absolute start time `<T_AST>` is compared to a constant `C_T_TFU_CLC_ST_END` using a less-than comparator (V.5.3). This checks if a specified time after start has passed.
    *   **Disable Function:** The output of this comparison, along with an internal logic block, feeds into a switch (V.5.4, threshold: 0.5). This switch is associated with the function "Disable starting function at given time after start and then TFU = Calc.-TFU".
    *   **Output `t_fu_st_ramp`:** The final output `t_fu_st_ramp` indicates whether the start ramp function is active or if the system has transitioned to directly using the calculated TFU.

In essence, the system continuously evaluates engine conditions and time to determine which fuel temperature value (a ramping value or a modeled/calculated value) to output, managing the transition smoothly during the vehicle's operation.


--- Page 27 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink subsystem is to generate and manage two related fuel temperature ramp signals: a high-resolution ramp (`TFU_H_RES_ST_RAMP`) and a lower-resolution, quantized version (`TFU_tmp`). It achieves this by incrementally adding a correction value to a base ramping signal, and then deriving the two temperature representations from the result. This is likely part of a fuel temperature estimation or simulation module within an automotive engine control unit (ECU).

## Inputs
1.  **`<TFU_H_RES_ST_RAMP>`**: This is an incoming high-resolution fuel temperature ramp signal, acting as the base value for the current calculation. The `< >` notation often signifies an external or global signal.
2.  **`C_TFU_COR_INC`**: A constant or parameter representing an incremental correction value, likely in degrees Celsius, to be added to the fuel temperature ramp. The "V.5.5" suggests it's a versioned calibration parameter.

## Outputs
1.  **`TFU_H_RES_ST_RAMP`**: The updated, high-resolution fuel temperature ramp value. As shown in the accompanying plot, this signal has a finer resolution (implied by 0.1 °C increment per recurrence).
2.  **`TFU_tmp`**: A temporary or lower-resolution fuel temperature signal. The plot indicates this signal is quantized with a resolution of 0.75 °C, representing a coarser, stepped version of the high-resolution ramp.

## Logic Flow
1.  **Initial Ramping Value**: The subsystem receives an existing high-resolution fuel temperature ramp value, `<TFU_H_RES_ST_RAMP>`. This value likely represents the fuel temperature at the previous time step or the current base for incrementing.
2.  **Correction Addition**: A constant correction increment, `C_TFU_COR_INC`, is added to the incoming `<TFU_H_RES_ST_RAMP>` value by the summation block (labeled "V.5.4"). This sum generates a new, updated temperature value. This is the core mechanism for creating the ramping behavior.
3.  **High-Resolution Output Path**: The result of the summation is passed to a block labeled "1". In this context, this "1" block likely represents a direct signal pass-through, a unit delay (if this is an iterative process where the output feeds back as the input for the next cycle, implying the sum is the *next* `TFU_H_RES_ST_RAMP`), or potentially a memory element. This path then produces the `TFU_H_RES_ST_RAMP` output, which is the fine-grained, incremented fuel temperature.
4.  **Lower-Resolution Output Path**: Simultaneously, the result of the summation is also routed to another block labeled "1". On this path, the signal is processed (implicitly or within the output block itself) to generate `TFU_tmp`. Given the description and the plot (Figure 43.3.25), this processing involves quantizing or rounding the high-resolution value to a coarser resolution of 0.75 °C. This results in the stepped `TFU_tmp` signal.
5.  **Output**: Both the `TFU_H_RES_ST_RAMP` and `TFU_tmp` signals are then output from this subsystem, likely for use by other modules within the automotive control system.

The `f()` block visible in the diagram is not directly connected to the described signal flow and its specific function within this particular diagram is not explicit without further context.


--- Page 28 ---

This page contains multiple Simulink-like diagrams. The primary diagram for analysis, based on the accompanying detailed textual description, is Figure 43.3.28, which describes the "TFU-Correction during idle speed phase". Figure 43.3.27 shows a simpler "Ramping not active" scenario, likely an alternative state or mode of operation. This analysis will focus on Figure 43.3.28 and its detailed logic.

## Function
The primary function of this Simulink diagram (Figure 43.3.28) is to calculate and apply a dynamic offset correction to the Fuel Temperature Unit (TFU) value specifically during the engine's idle speed phase. This TFU correction is implemented through a ramp-in and ramp-out mechanism, ensuring a smooth and controlled application and removal of the offset, and limiting the correction to a defined maximum value to maintain system stability.

## Inputs
*   `<VS>`: (Vehicle Status/Speed) Likely a boolean or enumerated signal indicating the vehicle's operational status or speed conditions, potentially used to enable/disable the correction.
*   `<N_32>`: (Engine Speed) An analog or scaled digital signal representing the current engine rotational speed, crucial for determining if the engine is in an idle speed phase.
*   `<TFU_IS_OFS_H_RES>`: (TFU Idle Speed Offset, High Resolution) Represents the target or desired fuel temperature offset to be applied during idle. This is a high-resolution value.
*   `<TFU_MDL_2>`: (TFU Model Value) The base or uncorrected fuel temperature value, likely derived from a physical model of the fuel system.
*   `<tfu_st_ramp>`: (TFU Status Ramping) A status signal indicating the current state of the TFU ramping process (e.g., active, inactive, ramping up, ramping down).
*   `<LV_TFU_STATE_1_ST_RAMP>`: (Level TFU State 1 Status Ramping) Provides specific state information related to the TFU ramping, possibly a particular stage or condition of the ramping logic.
*   `<feedback>`: A generic feedback signal, which could represent internal states, flags, or calculated values that influence the correction logic.

## Outputs
*   `<LV_TFU_IS_OFS_ACT>`: (Level TFU Idle Speed Offset Active) The current, actively applied value of the idle speed offset, which reflects the result of the ramp-in/ramp-out logic.
*   `<TFU_IS_OFS_H_RES>`: (TFU Idle Speed Offset, High Resolution) This signal is shown as both an input to and an output from the `CLC_TFU_IS_OFS_COR` subsystem. This indicates it might be passed through, buffered, or used internally and then re-exposed for other system components.
*   `<tfu_is_ofs_cor>`: (TFU Idle Speed Offset Corrected) The primary output of the diagram. This is the final corrected fuel temperature value after the calculated offset has been applied, considering all ramping, limiting, and logical conditions.

## Logic Flow
1.  **Input Collection:** The system continuously monitors and collects multiple input signals, including engine speed, vehicle status, the raw modeled fuel temperature, the target idle speed offset, and various ramping control/feedback signals.
2.  **Core Correction Subsystem Entry:** All collected inputs are channeled into a central subsystem block identified as `CLC_TFU_IS_OFS_COR` (Calculation of TFU Idle Speed Offset Correction), labeled with a functional reference (X.3.1.4.1), implying it contains the detailed implementation of the correction algorithm.
3.  **Idle Speed Correction Condition Evaluation:** Within the `CLC_TFU_IS_OFS_COR` subsystem, the system first evaluates if the conditions for applying an idle speed correction are met (e.g., engine is truly at idle, and the correction is commanded or necessary based on `<VS>`, `<N_32>`, and other internal logic).
4.  **Offset Ramp-in Logic:** If the idle speed correction conditions are fulfilled *and* a specific delay time, `C_TFU_IS_OFS_DLY`, has elapsed, the TFU offset value is gradually "ramped-in". This means the offset is smoothly increased over time until it reaches the target value (likely derived from `<TFU_IS_OFS_H_RES>`). This prevents abrupt changes in the fuel temperature signal.
5.  **Value Limiting:** Throughout the application of the offset, the calculated correction value is constrained. It is "limited to an defined max. value" to prevent over-correction or to ensure the fuel temperature remains within safe or effective operating limits.
6.  **Offset Ramp-out Logic:** Should the conditions for idle speed correction *no longer be fulfilled* (e.g., engine accelerates, vehicle moves), the system initiates a "ramp-out" phase. This ramp-out occurs *after* a second delay time, `C_TFU_IS_OFS_RAMP_OUT_DLY`, has passed. During ramp-out, the applied offset is gradually decreased until the overall `tfu_is_ofs_cor` value returns to the "normal" modeled TFU value (i.e., `TFU_MDL_2` without the offset), effectively phasing out the correction.
7.  **Intermediate Output Generation:** The subsystem provides an output `LV_TFU_IS_OFS_ACT`, representing the currently active and ramped offset value. It also outputs `<TFU_IS_OFS_H_RES>`, likely for monitoring or as a reference.
8.  **Final Corrected TFU Calculation:** The main output of the `CLC_TFU_IS_OFS_COR` block is `tfu_is_ofs_cor`, which is the result of applying the dynamically ramped and limited offset to the base TFU value.
9.  **Post-processing (Implicit):** The `tfu_is_ofs_cor` signal is then directed to a generic function block `f()`. This suggests an optional final processing step or a simple pass-through before the signal is made available as the ultimate corrected TFU output of this specific diagram.


--- Page 30 ---

This page contains a Simulink-like diagram, likely representing a control logic for an automotive system.

## Function
The primary function of this diagram is to manage the activation, deactivation, and calculation of an idle speed correction offset. It evaluates various conditions related to the engine start ramp, vehicle speed, and internal model states to determine if the idle speed correction should be active. When active, it calculates an offset; when inactive, it ramps down the offset. This entire logic appears to be part of a fuel temperature (FUSL) related subsystem, implying the offset might compensate for temperature effects on idle speed.

## Inputs
*   **`LC_TFU_IS_OFS_ACT_ST_RAMP`**: A boolean flag indicating a condition related to the start ramp and idle speed correction activation. (Interpretation: Assumed to be true when the start ramp condition *allows* idle speed correction activation, despite its potentially ambiguous label "active Start Ramp blocks idle speed cor.".)
*   **`LV_TFU_STATE_1_ST_RAMP`**: Current state of the engine's start ramp (e.g., 0 for active, 1 for not active).
*   **`C_TFU_IS_OFS_ACT_ST_RAMP`**: A constant or calibration parameter used for comparison with `LV_TFU_STATE_1_ST_RAMP`.
*   **`<VS>`**: Current vehicle speed.
*   **`C_TFU_IS_OFS_VS_MIN`**: Minimum vehicle speed threshold required for idle speed correction activation.
*   **`<TFU_MDL_2>`**: A model-specific variable or measurement, possibly related to engine state or another control parameter.
*   **`C_TFU_IS_OFS_DLY`**: A constant or calibration parameter used as a threshold for deactivating the correction function.
*   **`IS_CDN_ACT`**: A condition for activating the idle speed ramping function.
*   **`<TFU_IS_OFS_H_RES>`**: A high-resolution offset input, likely for the idle speed ramping function.
*   **`<N_32>`**: A 32-bit value, typically representing engine speed or a related RPM value.
*   **`<tIS_st_ramp>`**: A time or duration parameter related to the start ramp.

## Outputs
*   **`LV_TFU_IS_OFS_ACT`**: A boolean flag indicating the active status of the overall idle speed correction function.
*   **`<TFU_IS_OFS_H_RES>`**: The high-resolution offset value, possibly a modified version of the input or passed through the "If" block.
*   **`tfu_is_ofs`**: The final calculated and applied idle speed offset value.

## Logic Flow
1.  **Correction Function Activation Logic (Setting the Flip-Flop):**
    *   **Start Ramp Condition:** An `OR` gate evaluates two conditions:
        *   `LC_TFU_IS_OFS_ACT_ST_RAMP`: This signal (interpreted as "start ramp condition *allows* correction") directly contributes to enabling the function.
        *   The output of a `>` comparison: `LV_TFU_STATE_1_ST_RAMP > C_TFU_IS_OFS_ACT_ST_RAMP`. Assuming `C_TFU_IS_OFS_ACT_ST_RAMP` is 0 and `LV_TFU_STATE_1_ST_RAMP = 0` means "ST-Ramp active", this comparison (`LV_TFU_STATE_1_ST_RAMP > 0`) would mean "ST-Ramp is *NOT* active".
        *   Thus, the `OR` gate output is true if either the allowing condition (`LC_TFU_IS_OFS_ACT_ST_RAMP`) is met OR the ST-Ramp is not currently active.
    *   **Speed Condition:** The vehicle speed `<VS>` is compared to a minimum threshold `C_TFU_IS_OFS_VS_MIN`. If `<VS>` is greater than this minimum, this condition is met.
    *   **Combined Activation:** The output of the `OR` gate and the speed condition (`<VS> > C_TFU_IS_OFS_VS_MIN`) are combined by an `AND` gate. This means both the start ramp/allowing condition and the speed condition must be met for activation.
    *   **Debounce/Filtering:** The output of the `AND` gate passes through two debounce or filter blocks (V.5.3) to prevent spurious activation signals.
    *   **SR Flip-Flop Set:** The filtered signal serves as the `SET` input for the `SR Flip-Flop` (V.5.5).

2.  **Correction Function Deactivation Logic (Resetting the Flip-Flop):**
    *   **Deactivation Condition:** A comparison is made between `<TFU_MDL_2>` and `C_TFU_IS_OFS_DLY`. If `<TFU_MDL_2>` is less than or equal to `C_TFU_IS_OFS_DLY`, the deactivation condition is met.
    *   **Debounce/Filtering:** This condition also passes through a debounce/filter block (V.5.3).
    *   **SR Flip-Flop Reset:** The filtered signal serves as the `RST` input for the `SR Flip-Flop` (V.5.5).

3.  **Correction Function Active State:**
    *   The `SR Flip-Flop` (V.5.5) latches the active state. Its `Q` output, `LV_TFU_IS_OFS_ACT`, is set to true when the `SET` condition occurs (and `RST` is false) and reset to false when the `RST` condition occurs. This `LV_TFU_IS_OFS_ACT` signal indicates whether the idle speed correction function is currently operating.

4.  **Offset Calculation and Ramping (Conditional Execution):**
    *   An `If` block (V.6.0) uses the `LV_TFU_IS_OFS_ACT` signal (likely as its `cond_if` input) to determine the offset calculation path.
    *   **If `LV_TFU_IS_OFS_ACT` is true (Correction Function Active):**
        *   The `IDLE_SPEED_RAMPING_FUNCTION` (X.3.1.4.1.1) is executed. It takes inputs such as `IS_CDN_ACT`, `<N_32>` (e.g., engine speed), and `<tIS_st_ramp>`. This function calculates the desired `tfu_is_ofs` (offset value), likely incrementing and limiting it as per the accompanying text description. The output `tfu_is_ofs` is then fed to a `Merge` block. The input `<TFU_IS_OFS_H_RES>` is also passed through from this branch.
    *   **If `LV_TFU_IS_OFS_ACT` is false (Correction Function Inactive):**
        *   According to the description, the offset value is decremented and its influence is ramped out. The diagram shows a path from `tfu_is_ofs` (likely its previous value) to a subtraction block (representing decrement) and then to the `Merge` block.
    *   **Merge:** The `Merge` block (V.6.0) selects the appropriate `tfu_is_ofs` value from either the active ramping function path or the decremented path, providing the final `tfu_is_ofs` output.

This diagram demonstrates a robust state-based control logic for managing an idle speed correction offset, incorporating activation and deactivation conditions with filtering, and conditional execution of the offset calculation/ramping algorithm.


--- Page 31 ---

This page contains two Simulink-style diagrams, Figures 43.3.31 and 43.3.32, which together describe a system for managing and limiting fuel temperature, especially during specific engine operating conditions.

## Function
The primary function of these interconnected diagrams is to dynamically adjust and limit the fuel temperature (or fuel heating value) within an automotive system. It calculates an idle speed-dependent offset for fuel temperature and then applies this offset, along with other operational parameters like coolant temperature and a "PUC operating state" flag, to constrain the fuel heating to prevent overheating or to meet specific emissions/performance targets during the post-start-up cycle (PUC).

## Inputs
The key inputs to this system are:

*   **`<N_32>`**: An engine speed or similar rotational input, used as an axis for lookup tables.
*   **`IS_CDN_ACT`**: A boolean flag indicating an "idle speed condition active" or a general activation condition for ramp control.
*   **`C_TFU_IS_OFS_RAMP_OUT_DLY`**: A configurable delay time for the ramp-out phase of the offset.
*   **`C_TFU_IS_OFS_MAX_H_RES`**: The maximum permissible value for the high-resolution fuel temperature offset.
*   **`C_TFU_IS_OFS_MIN_H_RES`**: The minimum permissible value for the high-resolution fuel temperature offset.
*   **`x_val` (for increment and decrement)**: An input, likely representing a current fuel temperature deviation or an error signal, used by lookup tables to determine adjustment rates.
*   **`<tfu_st_ramp>`**: A base value or a ramp status signal for the initial offset calculation.
*   **`input`**: The nominal or requested fuel heating value.
*   **`<LV_PUC>`**: A boolean flag indicating whether the "PUC (Post-Start Up Cycle/Operating Condition)" is active.
*   **`<TCO>`**: The engine coolant temperature.
*   **`<TFU_PUC_SAVE>`**: A stored fuel temperature value or limit relevant for PUC conditions.
*   **`clc_t_stat_puc_pu`**: A static or calibration-based fuel temperature value specifically for PUC limitation.

## Outputs
The main output of the combined system is:

*   **`<TFU_COR_STAT_PUC_PU>`**: The final, corrected, and limited fuel heating or fuel temperature value after considering idle speed offsets and PUC state limitations.

## Logic Flow

The system's logic can be divided into two main parts, corresponding to the two figures:

### Part 1: Idle Speed Offset Calculation (Figure 43.3.31)

1.  **Determine Increment/Decrement Rates:** Based on an input `x_val` (which likely represents a deviation from a target fuel temperature or a condition variable) and `<N_32>` (engine speed), two 1D lookup tables, `IP_TFU_IS_OFS_INC` and `IP_TFU_IS_OFS_DEC`, determine the rates at which a fuel temperature offset should increase or decrease.
2.  **Ramp Control Logic:** The `IS_CDN_ACT` signal, in conjunction with `C_TFU_IS_OFS_RAMP_OUT_DLY`, controls a delay block (`T V.5.3`). This logic likely manages the timing for when a "ramp-out" (e.g., a gradual decrease) of the offset should begin or end.
3.  **Offset Accumulation:** The increment and decrement rates are fed into respective blocks ("Increment for idle speed correction" and "Decrement for idle speed correction"). These blocks are typically integrators or rate limiters that accumulate the offset over time. The incremented value is added, and the decremented value is subtracted in subsequent summing blocks (`V.6.7`). A `Check ~= 0` block might ensure that the decrement only occurs when a certain condition is met or the value is not zero.
4.  **Offset Limitation:** The calculated offset is then passed to a saturation block, "Limitation of the offset value" (`V.6.5`). This block enforces hard limits on the offset, ensuring it stays between `C_TFU_IS_OFS_MAX_H_RES` (maximum high-resolution offset) and `C_TFU_IS_OFS_MIN_H_RES` (minimum high-resolution offset). The output of this stage is `<TFU_IS_OFS_H_RES>`.
5.  **Final Offset Value:** The limited offset `<TFU_IS_OFS_H_RES>` is added to a base or ramp status value, `<tfu_st_ramp>`, to produce the final idle speed-dependent fuel temperature offset, `tfu_is_ofs`.

### Part 2: Fuel Temperature Limitation in PUC State (Figure 43.3.32)

1.  **PUC Condition Evaluation:** The `f()` block processes several inputs: `<LV_PUC>` (PUC active flag), `<TCO>` (coolant temperature), and `<TFU_PUC_SAVE>` (a stored PUC-related fuel temperature value). This block likely determines a specific limiting value or condition based on these parameters, outputting `<TFU_MDL_2>`. While `<TFU_MDL_2>` is shown as an output, its direct connection to `CLC_TFU_LIM_PUC` is not drawn but implied by the overall function.
2.  **Fuel Heating Limitation:** The central "CLC_TFU_LIM_PUC" block (Calculated Fuel Temperature Limitation for PUC) receives the nominal `input` fuel heating value, the static PUC temperature `clc_t_stat_puc_pu`, and the idle speed offset `tfu_is_ofs` from the first diagram.
3.  **Application of Limits:** As per the textual description "the fuel heating is limited to the minimum of coolant temperature and the stored value of TFU_COR_STAT_PUC_PU", the `CLC_TFU_LIM_PUC` block likely performs a minimum selection or a complex clamping operation. It compares the current fuel heating with values derived from the coolant temperature (`<TCO>`, potentially via `<TFU_MDL_2>`) and specific PUC-related limits (`clc_t_stat_puc_pu` and implicitly `<TFU_PUC_SAVE>`). The `tfu_is_ofs` acts as an additional adjustment to this limitation.
4.  **Final Limited Output:** The block outputs the `<TFU_COR_STAT_PUC_PU>`, which is the fuel heating value after all the necessary limitations and corrections for the PUC operating state have been applied.


--- Page 32 ---

This page contains two distinct Simulink diagrams, both related to the calculation and limitation of fuel temperature (FUSL).

## ## Function

The first diagram, titled "43.3.3.1.5.1 Calculation of final TFU model output (TFU_MDL_2)", is responsible for calculating an initial fuel temperature model output by applying physical maximum limits, incorporating a temperature control command, and conditionally selecting a saved value based on a low voltage power-up check.

The second diagram, titled "43.3.3.1.6 Minimum limitation of fuel temperature by ambient air temperature", refines the fuel temperature further by applying a minimum limit based on the ambient air temperature. This ensures the fuel temperature does not drop below a specified threshold, which varies depending on whether the ambient temperature is above or below a certain high threshold.

## ## Inputs

**For Diagram 1: Calculation of final TFU model output (TFU_MDL_2)**
*   `phys_max`: Represents the physical maximum allowed fuel temperature.
*   `TFU`: An initial or raw fuel temperature value.
*   `<TCO>`: A temperature control setpoint or command for the fuel temperature.
*   `<TFU_PUC_SAVE>`: A stored or saved fuel temperature value, likely used for initialization or recovery during system power-up.
*   `<tfu_is_ofs>`: A boolean or flag indicating if the Fuel Temperature Unit (TFU) is out-of-service (not actively used in the visible part of this diagram).
*   `<LV_PUC>`: A flag or condition indicating a Low Voltage Power-Up Check is active or required.

**For Diagram 2: Minimum limitation of fuel temperature by ambient air temperature**
*   `f()`: A functional input, likely representing a calculated lower limit for fuel temperature that depends on ambient air temperature.
*   `<TFU_MDL_2>`: The calculated fuel temperature model output from the first diagram.
*   `<TAMB>`: The current ambient air temperature.
*   `C_TFU_MIN_TAM_H`: A constant threshold representing a high ambient temperature, used to determine the applicable minimum limitation logic.

## ## Outputs

**For Diagram 1: Calculation of final TFU model output (TFU_MDL_2)**
*   `<TFU_MDL_2>`: The calculated final fuel temperature model output, after initial limiting and conditional selection.

**For Diagram 2: Minimum limitation of fuel temperature by ambient air temperature**
*   `<tfu_min_mdl_3>`: The final fuel temperature value after applying the ambient air temperature-based minimum limitation.

## ## Logic Flow

**Diagram 1: Calculation of final TFU model output (TFU_MDL_2)**

1.  **Physical Upper Limit:** The input `TFU` (initial fuel temperature) is fed into a 'min' block along with `phys_max`. This calculates `MX = min(TFU, phys_max)`, ensuring that the fuel temperature does not exceed its physical maximum limit.
2.  **Controlled Saturation:** A 'Limit' block (functioning as a dynamic saturation block) takes `TFU` as the value to be limited (`u`). Its lower limit (`MN`) is set by `<TCO>`, and its upper limit (`MX`) is the result from step 1. The output `y` is `max(<TCO>, min(TFU, min(TFU, phys_max)))`. This means `y` represents `TFU` clamped between the control command `<TCO>` and the determined upper physical limit.
3.  **Conditional Value Selection (Power-Up Check):** A switch block (labeled "Check ~= 0 V.6.4") acts as a multiplexer.
    *   If the control input `<LV_PUC>` is true (non-zero), indicating an active Low Voltage Power-Up Check, the switch selects and outputs `<TFU_PUC_SAVE>`.
    *   Otherwise (if `<LV_PUC>` is false or zero), the switch selects and outputs `y` (the saturated temperature from step 2).
4.  **Final Output:** The output of the switch block is assigned to `<TFU_MDL_2>`, which is the final calculated fuel temperature for this stage.

**Diagram 2: Minimum limitation of fuel temperature by ambient air temperature**

1.  **Ambient Temperature Condition Evaluation:** The ambient air temperature `<TAMB>` is compared with the constant `C_TFU_MIN_TAM_H` using a "less than or equal to" (`<=`) relational operator (V.6.9). This generates a boolean (1 or 0) signal indicating whether the ambient temperature is at or below the high threshold.
2.  **Conditional Minimum Limit Selection:** A switch block (labeled "Check ~= 0 V.6.10") uses the boolean output from step 1 as its control input.
    *   If `(TAMB <= C_TFU_MIN_TAM_H)` is true (ambient is cold or moderate), the switch selects the input `f()`. This `f()` is presumably a minimum limit for fuel temperature derived from the ambient temperature.
    *   If `(TAMB <= C_TFU_MIN_TAM_H)` is false (ambient is warm, `TAMB > C_TFU_MIN_TAM_H`), the switch selects `<TFU_MDL_2>`.
3.  **Apply Overall Minimum Limit:** The output of the switch block (let's call it `Selected_Min_Candidate`) is fed into a 'max' block (V.6.11) along with `<TFU_MDL_2>`.
    *   If `TAMB <= C_TFU_MIN_TAM_H`: The output `<tfu_min_mdl_3>` becomes `max(f(), <TFU_MDL_2>)`. This ensures that `<TFU_MDL_2>` is not allowed to fall below the ambient-derived limit `f()`.
    *   If `TAMB > C_TFU_MIN_TAM_H`: The output `<tfu_min_mdl_3>` becomes `max(<TFU_MDL_2>, <TFU_MDL_2>)`, which simply equals `<TFU_MDL_2>`. In this warm ambient condition, no additional minimum limitation is imposed by this specific ambient logic.
4.  **Final Output:** The result of the 'max' block is `<tfu_min_mdl_3>`, representing the fuel temperature after ensuring it meets the ambient air temperature-based minimum limitation.


--- Page 38 ---

This page contains a Simulink-style signal flow diagram, characteristic of automotive embedded software development.

## Function

The primary function of this module, titled "FUSL, Fuel temperature (Appl. Inc.)", is to process, calculate, and manage fuel temperature-related information within an automotive system. It handles system initialization, non-volatile memory (NVM) operations (store, restore, initialize), and performs timed execution of logic for fuel temperature sensing, calculation, and potentially tanking event detection. The module integrates a wide array of vehicle-specific inputs to derive robust fuel temperature values and related status signals.

## Inputs

The module receives a comprehensive set of inputs, categorized as triggers for internal functions and general sensor/vehicle data:

**Initialization and NVM Triggers:**
*   `<fc_IGKON>`: Ignition On signal.
*   `<fc_RST>`: System Reset signal.
*   `<fc_NVMINI>`: Non-Volatile Memory Initialization trigger.
*   `<fc_NVMRES>`: Non-Volatile Memory Restore trigger.
*   `<fc_NVMSTO>`: Non-Volatile Memory Store trigger.
*   `<fc_INI>`: General Initialization trigger.
*   `fc_OPM_20MS`: 20ms Operation Mode / Task trigger.
*   `fc_OPM_100MS`: 100ms Operation Mode / Task trigger.

**Sensor and Vehicle Data Inputs:**
1.  `B_fstcanok`: Boolean, Fuel System CAN communication status OK.
2.  `tans`: Analog, Ambient temperature (general).
3.  `B_hst`: Boolean, Status of heating element (e.g., fuel heater).
4.  `B_kl15`: Boolean, Ignition terminal 15 status (main ignition power).
5.  `B_stend`: Boolean, Engine Stop End status.
6.  `B_stendz`: Boolean, Engine Stop End status (variant Z).
7.  `B_tfstok`: Boolean, Fuel Temperature Sensor status OK.
8.  `B_tmmn`: Boolean, Engine Main Operating Mode status.
9.  `B_tospg`: Boolean, Throttle Valve Operating Program status.
10. `B_tumnpl`: Boolean, Engine Nominal Speed status.
11. `dmkrhdev_w`: Analog, Mass air flow rate.
12. `E_tmbkser`: Enumerated, Fuel Tank Series identifier.
13. `kfflaflin_w`: Analog, Fuel flow rate into engine.
14. `tabst_w`: Analog, Absolute ambient temperature.
15. `tanhkm_w`: Analog, Relative humidity.
16. `tfst`: Analog, Raw Fuel Temperature Sensor value.
17. `tka`: Analog, Catalytic converter temperature.
18. `tmot`: Analog, Engine coolant temperature.
19. `tnse_w`: Analog, Engine speed.
20. `tnsez_w`: Analog, Engine speed (variant Z).
21. `tosp`: Analog, Throttle valve position.
22. `tumg`: Analog, Ambient temperature (variant).
23. `vfzg_w`: Analog, Vehicle speed.
24. `B_sshev`: Boolean, Fuel tank system heating/ventilation valve status.
25. `LV_EFP_WKU`: Analog, Electric Fuel Pump voltage.
26. `lepwmfan`: Analog, Fuel pump Pulse Width Modulation (PWM) fan duty cycle.
27. `dmkrwpi_w`: Analog, Mass fuel return flow.
28. `B_tabstv`: Boolean, Temperature sensor validity status.
29. `RadBli_rActr_VW`: Analog, Radar sensor activation signal (VW specific).
30. `RadBli_rActr_VW_SC`: Boolean, Radar sensor activation status change (VW specific).
31. `RadBli_vCmpmt_VW_SC`: Boolean, Radar sensor compartment status change (VW specific).
32. `RadBli_vCmpmt_VW`: Analog, Radar sensor compartment value (VW specific).

## Outputs

The module generates several processed fuel temperature-related outputs:

1.  `B_getankt`: Boolean, Fuel tanking event detected/status (also used internally).
2.  `B_tfstausw`: Boolean, Fuel temperature selection/switch status.
3.  `B_tmbkser`: Boolean, Fuel tank series/variant status.
4.  `tflvrhdp`: Analog, Fuel level raw data.
5.  `tktm`: Analog, Fuel tank fill level time.
6.  `tfstvz`: Analog, Calculated/validated Fuel Temperature Value.
7.  `tksvhdapbs`: Analog, Absolute fuel tank volume (e.g., in liters).
8.  `tmotbksabs`: Analog, Motor tank absolute value (possibly related to fuel in engine bay).
9.  `ttankabs`: Analog, Absolute tank value (general).
10. `tfuelmx`: Analog, Calculated Fuel Mixture Temperature.
11. `tflvmpi`: Analog, Fuel volume Multi-Point Injection (MPI) specific.
12. `tfvuradtbks`: Analog, Fuel volume before tank fill (for delta calculations).

## Logic Flow

The logical flow of the diagram outlines the execution and data processing within the fuel temperature module:

1.  **System Initialization and NVM Handling:**
    *   Upon system events like Ignition On (`<fc_IGKON>`) or System Reset (`<fc_RST>`), or explicit initialization triggers (`<fc_INI>`, `<fc_NVMINI>`), the `INI X.1` and `NVMY_INI X.2` function blocks are executed. These blocks set initial states and parameters for the fuel temperature system and initialize non-volatile memory areas.
    *   During shutdown or other specific conditions, `<fc_NVMSTO>` triggers the `NVMY_STO X.4` block to store critical fuel temperature related data into non-volatile memory, ensuring persistence across power cycles.
    *   Upon power-up or specific requests, `<fc_NVMRES>` triggers the `NVMY_RES X.3` block to restore data from non-volatile memory, reinstating the last known operational state.

2.  **Timed Operational Modes:**
    *   The module operates with two primary periodic tasks:
        *   **20ms Task (`fc_OPM_20MS`):** This trigger activates the `TFST_20MS X.5` block. This block likely performs high-frequency, time-critical calculations related to fuel temperature. It takes a multitude of direct sensor inputs (e.g., `tfst`, `tmot`, `tans`), vehicle status signals (`B_kl15`, `vfzg_w`), and other operational parameters. It also processes `B_getankt` (fuel tanking status) as an input and passes it through as an output, suggesting it might detect or update this status based on real-time data.
        *   **100ms Task (`fc_OPM_100MS`):** This trigger activates the `OPM_100MS X.6` block. This block receives the `B_getankt` signal (potentially updated by `TFST_20MS`) as an input. This task likely handles less critical, or aggregated calculations, filtering, or long-term state updates related to fuel temperature or tanking events that do not require 20ms resolution.

3.  **Signal Aggregation and Management:**
    *   All outputs from the periodic task blocks (`TFST_20MS X.5`, `OPM_100MS X.6`) and the NVM/Initialization blocks (`INI X.1`, `NVMY_INI X.2`, `NVMY_RES X.3`, `NVMY_STO X.4`) converge at a "Merge" point.
    *   The merged signals are then fed into a "Signal Manager V.6.7" block. This block is crucial for ensuring data integrity and consistency. It typically performs functions such as:
        *   **Signal Validation:** Checking for plausibility, range limits, and sensor faults.
        *   **Error Handling:** Providing default values or error flags for invalid signals.
        *   **Scaling and Conversion:** Adapting signal formats or units for the output interface.
        *   **Output Preparation:** Finalizing the signals according to the specified output interfaces for other ECU modules.

4.  **External Outputs:**
    *   The "Signal Manager" produces the final, processed fuel temperature values and related status signals that are then made available as outputs from this module to other parts of the automotive control system.


--- Page 39 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, part of the FUSL_M408B subsystem (Fuel temperature application), is primarily responsible for the **initialization of specific BKS (likely an abbreviation for a system component or data block) variables and internal states of low-pass filters** during system reset (RST) or ignition on (IGKON) events. It sets initial values for various fuel temperature and related operating condition parameters.

## Inputs
The subsystem receives a single input bus (`In`) which contains the following individual signals:
*   **`<tumg>`**: Likely an engine temperature or a similar operating condition.
*   **`<tmot>`**: Engine coolant temperature or similar motor temperature.
*   **`<tans>`**: Ambient temperature or another relevant temperature sensor reading.
*   **`<ttankabs>`**: Absolute tank temperature.

Additionally, several internal constant values (all set to '0') are used for initialization:
*   `B_getankt`
*   `B_tfstausw`
*   `B_tmbkser`
*   `tktm`
*   `B_tmodini`
*   `B_stendre`
*   `B_tmodbksc`

## Outputs
The subsystem produces a single output bus (`Out`) which contains the following initialized signals:
*   **`tumgtbks`**: A multiplexed signal representing initialized states of several boolean/flag variables.
*   **`tmotbks`**: An initialized engine operating mode or temperature status.
*   **`tflvrhdp`**: Initialized fuel temperature related variable (likely a raw or conditioned fuel temperature).
*   **`tfuelmx`**: Initialized mixed fuel temperature or maximum fuel temperature.
*   **`tflvrhdp_flt_ini`**: Initial state for a low-pass filter related to `tflvrhdp`.
*   **`tflvmpi_flt_ini`**: Initial state for a low-pass filter related to `tflvmpi` (an intermediate calculated fuel temperature).

## Logic Flow

1.  **Input Demultiplexing:** The incoming `In` bus is demultiplexed into its constituent signals: `tumg`, `tmot`, `tans`, and `ttankabs`.

2.  **`tumgtbks` Initialization:**
    *   A set of seven boolean or flag variables (`B_getankt`, `B_tfstausw`, `B_tmbkser`, `tktm`, `B_tmodini`, `B_stendre`, `B_tmodbksc`) are all initialized to a constant value of `0` (likely representing 'false' or 'inactive' state).
    *   These seven signals are then multiplexed together to form the `tumgtbks` output signal, establishing their default initial states.

3.  **`tmotbks` Calculation:**
    *   The `tumg` input signal is fed into a block labeled `f()` (likely a function call or a sub-algorithm).
    *   This `f()` block processes `tumg` to produce the `tmotbks` output, which is then added to the output bus.

4.  **Conditional Fuel Temperature Calculation (`tflvrhdp`, `tfuelmx`, `tflvmpi`):**
    *   The `tmot` input is compared against a constant `SY_MP1` using a 'greater than' operator.
    *   The result of this comparison (a boolean) controls a `cond_if` block, which represents conditional logic (if-else structure).
    *   Within this conditional logic, the `tmot` signal is further processed.
    *   The `tmot` and `tans` signals are both fed into a block named `Calc_of_tflvmpi` (likely a function or lookup table, indicated by `X.1.1`). This block calculates `tflvmpi` (an intermediate fuel temperature variable).
    *   The exact internal logic of `cond_if` is not fully visible, but it processes these values to determine the `tflvrhdp` and `tfuelmx` output signals, possibly selecting between `tmot`, `tflvmpi`, or other derived values based on the condition.

5.  **Low-Pass Filter State Initialization:**
    *   The `tmot` signal is directly assigned to `tflvrhdp_flt_ini`. This sets the initial state of a low-pass filter associated with `tflvrhdp` to the current engine temperature (`tmot`), as explained by the accompanying text.
    *   Similarly, the calculated `tflvmpi` signal (from `Calc_of_tflvmpi`) is directly assigned to `tflvmpi_flt_ini`. This sets the initial state of a low-pass filter associated with `tflvmpi` to its calculated value. The blocks labeled `1` likely represent direct assignments or unity gain, ensuring the initial value is passed through.

6.  **Output Multiplexing:** All the calculated and initialized signals (`tumgtbks`, `tmotbks`, `tflvrhdp`, `tfuelmx`, `tflvrhdp_flt_ini`, `tflvmpi_flt_ini`) are then grouped together into a single output bus (`Out`) by a multiplexer, which exits the subsystem.


--- Page 40 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink diagram, titled "Calc_of_tflvmpi", is to calculate a derived fuel temperature, `tflvmpi`, by taking the sum of two input temperatures (`tmot` and `tans`) and dividing that sum by a constant value of 2.0. This calculation effectively computes the average of the two input temperatures. The context suggests this is part of a fuel temperature application within an automotive system, likely used for engine control unit (ECU) calculations related to fuel injection or fuel property estimation.

## Inputs
*   **tmot (1):** This input represents the motor temperature.
*   **tans (2):** This input represents an ambient or sensor temperature.

## Outputs
*   **tflvmpi (1):** This output represents the calculated fuel temperature.

## Logic Flow
1.  **Input Reading:** The subsystem receives two input signals: `tmot` and `tans`.
2.  **Summation:** The `tmot` and `tans` signals are fed into an 'Add' block. This block performs the summation of the two inputs, resulting in an intermediate sum: `Sum = tmot + tans`.
3.  **Constant Value:** A constant value of `2.0` is introduced into the diagram.
4.  **Division:** The result of the summation (`Sum`) is then divided by the constant value `2.0` using a 'Divide' block. This operation calculates: `tflvmpi = Sum / 2.0`.
5.  **Output:** The final result of the division, `tflvmpi`, is output from the subsystem.

*(Note: The `f()` block is present in the diagram but is not connected to the signal flow determining `tflvmpi`, therefore it does not participate in this specific calculation as depicted.)*


--- Page 41 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, named "NVMY_INI" (Non-Volatile Memory Initialization), is primarily responsible for reading or initializing several absolute sensor values related to the fuel system and engine temperature from Non-Volatile Memory (NVM). These retrieved/initialized values are then processed by an internal function block, and the final result is output by the subsystem. It serves as an initialization routine for persistent fuel system parameters.

## Inputs
From the perspective of this specific subsystem diagram, there are no explicit external input ports (Inport blocks) shown. The data sources are internal to the subsystem, originating from the Non-Volatile Memory access blocks.
The conceptual inputs are:
*   **tksvhdpabs**: Absolute fuel tank pressure sensor value from NVM (initialized to 0 if not available).
*   **tmotkbsabs**: Absolute engine temperature sensor value from NVM (initialized to 0 if not available).
*   **ttankabs**: Absolute fuel tank temperature sensor value from NVM (initialized to 0 if not available).
*   **tfstvz**: Fuel temperature sensor value from NVM (initialized to 0 if not available).
*   **tksvmpiabs**: Another absolute fuel system related value from NVM (initialized to itself, implying a previous value or a specific initialization logic if not available).

## Outputs
The diagram has one explicit output:
*   **Out (1)**: This is the primary output of the `NVMY_INI` subsystem, representing the result of processing all the NVM-derived values by the `V.6.1` function block.

The intermediate outputs from the NVMY blocks, which feed into the `V.6.1` block, are:
*   `tksvhdpabs`
*   `tmotkbsabs`
*   `ttankabs`
*   `tfstvz`
*   `tksvmpiabs`

## Logic Flow
1.  **NVM Parameter Retrieval and Initialization**: The diagram starts by accessing five distinct NVM variables using dedicated `NVMY[read/init]` blocks: `tksvhdpabs`, `tmotkbsabs`, `ttankabs`, `tfstvz`, and `tksvmpiabs`.
    *   Each `NVMY[read/init]` block attempts to read its corresponding parameter from Non-Volatile Memory.
    *   If a parameter cannot be read (e.g., due to NVM corruption or being the first start-up), it is initialized to a default value specified within the block (e.g., `init:0` for most, and `init:tksvmpiabs` for the last one, implying a self-referential or specific default strategy).
    *   Each block outputs the retrieved or initialized value.
2.  **Signal Aggregation**: The five individual signals output from the `NVMY[read/init]` blocks are then collected and passed to a subsequent processing block. The thick vertical line visually represents this collection of signals, likely as a virtual bus or grouped input.
3.  **Data Processing**: These aggregated signals serve as inputs to a function block labeled `V.6.1`. This block (a custom function, a subsystem, or a MATLAB Function block) performs an unspecified processing operation on the five NVM-derived values. The "V.6.1" likely denotes a version or specific implementation of the algorithm.
4.  **Subsystem Output**: The result generated by the `V.6.1` processing block is then routed to the "Out" port (labeled "1"), which represents the final output of the `NVMY_INI` subsystem to its parent system or caller.


--- Page 42 ---

This page contains a Simulink diagram.

## Function

The primary function of this Simulink diagram, labeled "NVMY_RES" (likely Non-Volatile Memory Result or Resolution), is to read and process multiple temperature-related variables stored in Non-Volatile Memory (NVM). Given the context "FUSL, Fuel temperature (Appl. Inc.)", it is highly probable that this module computes or derives a fuel temperature value or a related critical temperature parameter, possibly using redundancy or different measurement/estimation methods based on the various NVM-stored absolute temperature values.

## Inputs

All inputs originate from "NVMY[read/init]" blocks, indicating they are variables read from Non-Volatile Memory. The `init` part suggests these variables are also initialized if not present or valid. All listed variables are of `size: 1` and specify a `V.6.5` version, indicating single-value parameters.

1.  **`tksvhdpabs`**: A temperature value from NVM. (e.g., "Temperature, Kelvin, Sensor, VHD, Pressure, Absolute")
2.  **`tmotkbsabs`**: A motor-related temperature value from NVM. (e.g., "Temperature, Motor, Kelvin, Base, Sensor, Absolute")
3.  **`ttankbs`**: A fuel tank temperature value from NVM. (e.g., "Temperature, Tank, Base, Sensor")
4.  **`ttankabs`**: Another fuel tank temperature value from NVM. (e.g., "Temperature, Tank, Absolute, Sensor")
5.  **`tfstvz`**: A temperature-related value from NVM. (e.g., "Temperature, Fuel, Sensor, Time, Value, Z-axis") - less clear, but 'tf' often denotes 'temperature fuel'.
6.  **`tksvmpiabs`**: A temperature value from NVM. (e.g., "Temperature, Kelvin, Sensor, VMPI, Absolute")

## Outputs

1.  **`Out`**: This is the final processed output signal from the "V.6.1" processing block. It represents the result of the computations performed on the collected NVM temperature data, likely the derived fuel temperature or a related key value.

## Logic Flow

The logical flow of the diagram proceeds as follows:

1.  **NVM Data Acquisition:** Six independent "NVMY[read/init]" blocks are used to retrieve specific temperature-related variables from Non-Volatile Memory. Each block outputs a single variable (`tksvhdpabs`, `tmotkbsabs`, `ttankbs`, `ttankabs`, `tfstvz`, `tksvmpiabs`). The "[read/init]" functionality suggests that these values are read if available, or initialized to a default value if not.
2.  **Signal Aggregation:** All six retrieved NVM temperature variables are then directed towards a central vertical line, which acts as a bus or an aggregation point for these signals. Notably, the `ttankbs` signal passes through a triangular block labeled '1' before joining the bus. This '1' typically represents a gain of one (pass-through) or a unit delay, but in this context, it might visually emphasize the signal or serve as a labeled connection point before the bus.
3.  **Core Processing Block:** The aggregated bus, containing all six temperature variables, serves as the input to a large processing block labeled "V.6.1". This block encapsulates the primary logic or algorithm that uses these multiple NVM temperature values to perform a specific calculation or determination. The 'f()' symbol in the top-right corner of the diagram boundary might indicate that this entire subsystem is a function.
4.  **Final Result:** The "V.6.1" block produces a single output signal, simply labeled "Out". This output represents the final result of the NVM temperature data processing, consistent with the module's overall objective related to fuel temperature.


--- Page 43 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink subsystem, named "NVMY_STO" (Non-Volatile Memory Store), is to manage the persistent storage and retrieval of several critical application parameters into/from Non-Volatile Memory (NVM). It acts as an interface to store current values of these parameters and make the stored values available for other parts of the system, ensuring data persistence across power cycles. Given the context "FUSL, Fuel temperature (Appl. Inc.)", these parameters are likely related to fuel temperature management or diagnostics.

## Inputs
The subsystem receives a single input, which appears to be a bundled bus of signals. This bus is then split into the following individual signals, each intended for non-volatile storage:

*   **tksvhdpabs**: (Likely a temperature sensor value, e.g., 'temperature sensor water-heating pump absolute' or similar automotive specific abbreviation)
*   **tmotbksabs**: (Likely 'temperature motor block absolute' or related engine temperature)
*   **ttankabs**: (Likely 'temperature tank absolute', possibly fuel tank temperature)
*   **tfstvz**: (Likely 'temperature fuel supply sensor value zero' or similar fuel system parameter)
*   **tfltmpi**: (Likely 'temperature fuel manifold pressure input' or another fuel system temperature/pressure value)

## Outputs
The subsystem outputs the values currently stored in the Non-Volatile Memory for each of the input parameters. These outputs are then bundled together, possibly for further processing or use by other parts of the overall system. The individual outputs are:

*   The stored value of **tksvhdpabs**
*   The stored value of **tmotbksabs**
*   The stored value of **ttankabs**
*   The stored value of **tfstvz**
*   The stored value of **tfltmpi**

These outputs feed into a block labeled `f()`, which likely signifies a function call or a further processing stage within the larger system.

## Logic Flow
1.  **Input Reception:** A single input port, designated as 'In' (likely a bus carrying multiple signals), enters the `NVMY_STO` subsystem.
2.  **Signal Demultiplexing:** This input bus is demultiplexed (or individual signals are picked off the bus) into five distinct signals: `<tksvhdpabs>`, `<tmotbksabs>`, `<ttankabs>`, `<tfstvz>`, and `<tfltmpi>`.
3.  **Non-Volatile Memory Interaction:** Each of these five individual signals is fed into its own dedicated "NVMY[store]" block.
    *   **Write Operation (Implicit):** The "in" port of each "NVMY[store]" block receives the current value of its respective signal. The primary role of such a block is to write this current value to a pre-defined Non-Volatile Memory location. This write operation typically happens periodically or on specific events (e.g., ignition off, critical value change).
    *   **Read Operation (Explicit):** The "out" port of each "NVMY[store]" block provides the value currently stored in its corresponding NVM location. This usually means that upon initialization (e.g., power-on), the block reads the last stored value from NVM and outputs it. During runtime, it continuously outputs the value that is currently stored or being written.
    *   **Configuration:** Each "NVMY[store]" block is configured with metadata:
        *   `Name`: The specific parameter name (e.g., `tksvhdpabs`).
        *   `size: 1`: Indicates that each parameter stores a single value.
        *   `init: 0`: Specifies the initial value (or default value) if the NVM location is uninitialized or corrupted.
        *   `V.6.5`: Likely refers to a version number or a standard of the NVM storage mechanism or component used.
4.  **Output Aggregation:** The values output from each of the five "NVMY[store]" blocks are then routed towards a single output path. These values are likely bundled together again into an output bus, which then connects to a subsequent block labeled `f()`. This `f()` block represents the point where these persistently stored and retrieved values are consumed by other parts of the application or algorithm for further calculations or control actions.


--- Page 44 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, labeled "TFST_20MS" (likely "Fuel Temperature Status" or "Tank Filling Status" executed at 20ms intervals) within the "FUSL, Fuel temperature (Appl. Inc.)" context, primarily functions to **detect and signal a refueling event** (`B_getankt`) and manage related fuel tank status conditions. It monitors various system inputs, including ignition status, fuel tank sensor validity, and CAN communication, to determine and latch a fuel system state, which then leads to the detection of a refueling process.

## Inputs
*   **Unnamed Input (to CWTMODBKS block):** An unlabelled signal entering the `CWTMODBKS` block, likely a raw sensor reading or a status word related to the fuel system.
*   **bit_sel:** Configuration input for bit selection, probably for decoding the `CWTMODBKS` signal.
*   **\<B_tffstok\>:** Boolean signal indicating if the fuel tank filling status is considered OK.
*   **\<B_fstcanok\>:** Boolean signal indicating if the fuel tank system's CAN communication is OK.
*   **\<B_kl15\>:** Boolean signal representing the status of Ignition Terminal 15 (e.g., engine ON/OFF).
*   **TRAPFST:** Input to a "Trap Fuel Status" block, likely a signal related to detecting a specific state change or condition in the fuel system.
*   **TWATFST:** Input to a "Wait Fuel Status" block, possibly a timeout or a flag for a waiting period related to fuel status.
*   **cond_if (multiple instances):** Conditional boolean inputs used in `if`-like logic blocks to steer the flow or set intermediate states.

## Outputs
*   **Out (labeled '1'):** The primary numerical or boolean output of the entire subsystem, likely reflecting the final detected fuel system status or the `B_getankt` signal.
*   **B_getankt:** Boolean signal, translating from German as "refueled," indicating that a refueling event has been recognized.
*   **B_tffstausw:** Boolean signal, likely representing a "Fuel Tank Filling Status Evaluation/Selection" (an internal status for other modules).
*   **\<tffst\>:** Processed fuel tank filling status signal, potentially debounced or filtered.

## Logic Flow

The logical flow can be broken down into several stages:

1.  **Initial Status Decoding and Pre-Conditions (Left side):**
    *   An unnamed input signal is processed by the `CWTMODBKS` block, potentially with configuration from `bit_sel` and a constant `0`. The `num_dec` block then decodes this into a numerical value (V.7.3).
    *   Boolean inputs `<B_tffstok>` and `<B_fstcanok>` are logically combined with an `AND` gate.
    *   The `<B_kl15>` (Ignition ON) signal is inverted by a `NOT` gate (meaning Ignition OFF).
    *   The output of the `AND` gate is then combined with the `NOT <B_kl15>` by an `OR` gate. This creates a condition: (Fuel Tank OK AND CAN OK) OR (Ignition is OFF).
    *   This combined boolean condition, along with the `TRAPFST` signal and a `feedback` signal (derived later from `tffstvz`), is fed into a `T` block (likely a trigger or edge detector).

2.  **State Latching and Timer/Trigger Logic (Middle Section):**
    *   The output of the `T` block serves as the Set (S) input for an `FF` (Flip-Flop) block. This indicates that once the pre-conditions are met, a state is latched.
    *   The Reset (R) input of the `FF` is activated if `TWATFST` is true, or if the output of the `num_dec` block is true, or if a specific `cond_if` is true. This mechanism allows the latched state to be reset under certain conditions (e.g., timeout, new mode, or specific trigger).
    *   The `Q` output of the `FF` block represents the current latched state of the system, signaling that certain initial conditions have been met and sustained.

3.  **Intermediate Status Derivation (`B_tffstausw`, `tffstvz`):**
    *   The `Q` output of the `FF` block influences two `cond_if` blocks.
    *   One `cond_if` block, using `Q` and a constant `0`, produces the `B_tffstausw` signal (Fuel Tank Filling Status Evaluation/Selection), which is an internal status indicator.
    *   Another path takes the `NOT Q` and `OR`s it with a `cond_if` signal. This result is then `AND`ed with another `cond_if` signal to generate `tffstvz` (Fuel Tank Filling Status Pre-condition/Delay).

4.  **Fuel Status Transformation and Feedback (Mid-Right Section):**
    *   The `tffstvz` signal is fed back to the initial `OR` gate (before the `T` block), creating a feedback loop. This feedback allows the currently determined `tffstvz` to influence subsequent evaluations of the conditions for setting the Flip-Flop, potentially adding hysteresis or sequential behavior.
    *   `tffstvz` also passes through a `TFSTOET` block. This block likely performs further processing on `tffstvz`, such as edge detection, filtering, or debouncing, to produce `<tffst>` (the processed fuel tank filling status signal).

5.  **Refueling Event Detection (`B_getankt`) (Right Side):**
    *   The `<tffst>` signal (processed status) is compared with the `tffstvz` signal (pre-condition/delay status) using a `>` (greater than) comparison block.
    *   If `<tffst>` is greater than `tffstvz`, it signifies a change indicating a refueling event. This triggers the "Tankvorgang erkannt" block, which outputs the `B_getankt` signal ("Refueling event recognized").

6.  **Final System Output:**
    *   The `B_getankt` signal is directed to the main `Out` block, making it a key output of the entire subsystem. Other internal signals like `B_tffstausw` are also derived.


--- Page 45 ---

This page does contain a Simulink diagram.

## Function

This Simulink diagram, labeled "43.4.6 OPM_100MS" and titled "FUSL, Fuel temperature (Appl. Inc.)", is designed to calculate or estimate the fuel temperature (`tfuelmx`) within an automotive system. It processes numerous inputs related to engine status, various temperatures, tank fill levels, and other vehicle operational parameters through a series of filtering, conditioning, and calculation steps. The overall function is to provide a robust and accurate fuel temperature value, likely for engine control or diagnostic purposes. The model incorporates feedback loops, suggesting dynamic temperature estimation or adaptive filtering.

## Inputs

The diagram takes the following key inputs:

*   **System Status/Flags:**
    *   `B_sshev`, `B_stendz`, `B_stend`: Various engine/system status flags.
    *   `B_tumnpl`, `B_tabstv`: Specific operational mode or status flags.
    *   `B_kl15_dly`: Delayed ignition (KL15) signal.
    *   `B_tmodini_prev`: Previous engine mode initialization status.
    *   `B_getankt`: Fuel tank filled status.
    *   `LV_EFP_WKU`: Electrical fuel pump working unit status.
    *   `B_kl15`: Ignition (KL15) signal.
    *   `SY_MPI`: Multi-Point Injection status/signal.
    *   `RadBli_rActr_VW`, `RadBli_rActr_VW_SC`: Radiator fan related signals/values.
    *   `RadBli_vCmptmt_VW`, `RadBli_vCmptmt_VW_SC`: Radiator compartment related signals/values.

*   **Temperature Readings/Estimates:**
    *   `tumg`: Ambient temperature.
    *   `vizg_w`: Vehicle specific temperature or status.
    *   `B_tmmn`: Minimum temperature.
    *   `B_tahst_w`: Engine coolant temperature (from head or similar).
    *   `dmkmrpi_w`: Engine speed related temperature or value.
    *   `tosp`: Oil temperature or sensor value.
    *   `tmod`: Engine temperature or module specific temperature.
    *   `kfllafln_w`: Fuel quantity learning factor or similar.
    *   `tans`: Intake air temperature.
    *   `B_hst`: Heat soak temperature or historical temperature.
    *   `tabst_w`: Temperature absolute.
    *   `tanhm_w`: Air humidity temperature or a related value.
    *   `tfslrv`: Fuel temperature from level sensor or similar.
    *   `tfst`: Fuel temperature raw or initial estimate.

*   **Feedback/Internal States (external to a subsystem, but potentially internal in a larger context):**
    *   `B_tospgpl`: Temperature related to fuel system pressure.
    *   `B_tmodbksc`: Filtered engine temperature or mode.
    *   `tflvrhdp`: Filtered fuel temperature for hydraulic pump.
    *   `tfllvmpi`: Filtered fuel level/volume for MPI.

## Outputs

The primary output of the entire Simulink diagram is:

*   `tfuelmx`: The final calculated or estimated fuel temperature.

Intermediate outputs from subsystems like `B_stend_kl15`, `B_stendre`, `tumgtbks`, `ttankabs`, `trolhvdp`, `tfllvmpi`, etc., are passed between blocks within this diagram but do not exit the top-level system.

## Logic Flow

The diagram follows a highly modular and interconnected data-flow logic, primarily composed of several green subsystem blocks (likely masked subsystems or model reference blocks) representing specific functions, along with basic Simulink logic gates, delays, and switches.

1.  **Initial Status & Tank Information Processing (Left Side, Top/Middle):**
    *   `TUMGBKS` (X.6.1) takes various system status inputs (`B_sshev`, `B_stendz`, `B_stend`, `tumg`, `B_tumnpl`, `B_tabstv`, `B_kl15_dly`, `B_tmodini_prev`) and processes them to generate filtered status outputs like `B_stend_kl15`, `B_stendre`, and `tumgtbks`. These likely set the operational context.
    *   `TTANKMOD` (X.6.2) processes inputs related to tank filling (`B_getankt`), system values (`vizg_w`, `B_tmmn`, `B_tahst_w`), and receives feedback on `ttankabs` (tank absolute level) and `B_tumgfill` (from `TUMGBKS`). It outputs processed tank information (`itankbks`, `tktm`, `ttankabs`, `dttankst`).
    *   An `f(c)` block (associated with `ACTIVE_7`) aggregates a wide range of status and temperature inputs (`B_stend_kl15`, `B_stendre`, `B_sshev`, `E_tmbkser`, `B_stendz`, `B_stend`, `tnsez_w`, `tfka`, `tumg`, `B_hst`, `tabst_w`, `tanhm_w`). This block likely performs a significant conditioning or initial calculation to produce various temperature and status values (`tdlffbks_w`, `B_tmbkser`, `tflvrhdp`, `tkast`, `tkatubks`, `B_rzttmbks`, `B_zttmgr`, `feltaa`, `ttetaar`).

2.  **Engine and System Temperature Processing (Left Side, Bottom/Middle):**
    *   `TWOELR` (X.6.3) processes engine-related values (`dmkmrhdev_w`, `tosp`, `tmod`, `tumgtbks`, `B_tospgpl`) to output `tfsp` and `tmot`, likely representing filtered or calculated engine/oil temperatures.

3.  **Conditional Logic and Filtering (Central Area):**
    *   A set of logic gates (`NOT` V.6.3, `AND` V.5.4) and switches (`V.6.8`, `V.6.2`) combined with delay blocks (`V.6.4`) are used to create conditional signals based on `B_kl15`, `LV_EFP_WKU`, and `SY_MPI`. This suggests mode-dependent behavior or delayed activation/deactivation of certain paths.
    *   `SELECT_KFFLAFIN` (X.6.7) uses `kflafln_w` and `dmkmrpi_w` to determine `kflaflncor`, likely a corrected or selected fuel learning factor.
    *   `MDLMPITEMP` (X.6.6) takes inputs like `tmotbks`, `tans`, `tflvrhdp`, `dmkmrpi_w`, and `tumgtbks` to generate `trohvmp`, possibly related to manifold pressure or intake air heating/cooling.
    *   `TEMPFILTER` (X.6.5) is a substantial filtering block, taking numerous status and temperature inputs (`kflaflncor`, `tmotbks`, `ttankbks`, `tumgtbks`, `tflvrhdp`, `B_tospgpl`, etc.). It produces many filtered outputs (`fazbksy_w`, `fabsltbks`, `tkadlfks`, `B_tmodbksc`, `tksvmpiabs`, `tstbks`, `tdlffmpi`, `tfflmpi`, `tfllvmpi`). This block is crucial for refining various temperature and system state estimates.

4.  **Component Temperature and Post-Processing (Right Side):**
    *   `MDLDITEMP` (X.6.5, another instance or similar module) processes `tmotbks`, `vizg_w`, an active enable signal (`lepwnfan`), `ttankbks`, `kflaflncor`, `tdlffbks_w`, `B_stend`, various `RadBli` signals, `tumgtbks`, and feedback `tfuelmx`. It outputs `trohvdp` and `ffwkbks`, potentially related to radiator or other system component temperatures and their influence on fuel temperature. The feedback of `tfuelmx` implies an iterative or self-adjusting calculation.
    *   `POSTDRIVE` (X.6.4) takes processed temperatures and status values (`B_tmodbksc`, `B_getankt`, `tflvrhdp`, `tksvhpabs`, `tmotbks`, `ttankbks`, `tfllvmpi`). It generates further refined outputs (`tksvhpabs`, `tmotbksabc`, `ttankab`, `tksvmpiabs`). This stage likely performs final adjustments or integration of various temperature estimates.

5.  **Final Fuel Temperature Calculation (Bottom Right):**
    *   `CLC_TFUELMX` (X.6.9) is the final computation block, taking `tflvrhdp` (filtered fuel temperature for hydraulic pump) and `tfllvmpi` (filtered fuel level/volume for MPI) as inputs. It produces the ultimate output `tfuelmx`, which is the system's calculated fuel temperature.

The diagram demonstrates a complex interplay of physical signals and logical states, with filtering, delays, and conditional logic used to robustly determine the fuel temperature, accounting for various operating conditions and component influences. Feedback loops suggest a dynamic estimation approach.


--- Page 46 ---

This page contains two Simulink diagrams, which are analyzed below.

## 43.4.6.1 TUMGBKS Analysis

### Function
This Simulink diagram, `TUMGBKS` (likely standing for "Umgebungstemperatur BKS" - Ambient Temperature BKS, within the "FUSL, Fuel temperature" application context), is designed to select, process, and output a filtered ambient temperature. It determines various status flags related to ambient temperature processing, mode selection, and initialization for a fuel temperature model. The logic involves configuration bit extraction, debouncing of signals, and a thermal model/rate limiter to provide a stable and representative ambient temperature (`tumg`, `teitaa`, `tktm`).

### Inputs
*   **CWTMODBKS**: Configuration word, typically an integer or bitmask, used to enable/disable features or select operating modes.
*   **CWTMODBKS2**: Another configuration word, similar in function to CWTMODBKS.
*   **B_tumpl**: Boolean flag, possibly indicating "temperature planning" or an ambient temperature pre-control state.
*   **B_kli15_dly**: Boolean flag, representing a delayed ignition (Terminal 15) status.
*   **B_tabstv**: Boolean flag, likely related to a table or status activation.
*   **B_tmm_w**: Boolean flag, possibly "Temperature Model Weight" or a weighting factor enable.
*   **B_tmm_n**: Boolean flag, likely "Temperature Model N-factor" or a numerical factor enable.
*   **ZTTUMGBKS**: A raw ambient temperature value or a selection criterion for temperature.
*   **IV**: Initial Value for the main thermal model/rate limiter (V.5.3 block).
*   **dT**: Delta Time or step size for the main thermal model/rate limiter.
*   **1000MS**: A constant value (1000 milliseconds), likely a timer period, time constant, or reset value for a block.
*   **B_tmodini_prev**: Previous state of the temperature model initialization flag.

### Outputs
*   **tumg**: The primary processed and filtered ambient temperature (analog value).
*   **tumgtbks**: Boolean flag, indicating the validity or activation of the output `tumg`.
*   **B_tumgfil**: Boolean flag, indicating if the ambient temperature signal is currently being filtered or considered active.
*   **B_stendre**: Boolean flag, likely "Standby End" or "Steady End" status.
*   **B_sshev**: Boolean flag, an intermediate status.
*   **B_stend**: Boolean flag, a processed "Standby End" status.
*   **B_stend_kl15**: Boolean flag, derived from KL15 and standby conditions.
*   **B_tmodini**: Boolean flag, indicating the initialization status of the temperature model.
*   **teitaa**: A filtered temperature output from the main V.5.3 thermal model/integrator block.
*   **tktm**: A raw or intermediate temperature output from the main V.5.3 thermal model/integrator block.

### Logic Flow

1.  **Configuration Bit Extraction**: `CWTMODBKS` and `CWTMODBKS2` are decomposed using `GET BIT` blocks (V.7.0) to extract individual boolean flags (`bit_sel`) and numerical values (`num_dec`). These bits control the conditional logic throughout the diagram.

2.  **`B_tumpl` and Initialization Logic**: An inverted `B_tumpl` is combined with other signals (including an inverted `B_tumpl` and a `TCTUMGBKS` block output) via `AND` gates. This complex logic likely implements a debounce or an enabling condition related to temperature planning.

3.  **`B_stendre` and Standby Conditions**:
    *   `B_kli15_dly` and an extracted bit from `CWTMODBKS` are `AND`ed.
    *   `B_tabstv` and an inverted extracted bit from `CWTMODBKS2` are `AND`ed.
    *   These results are `OR`ed, and the output is passed through a rate limiter (V.5.3) to produce `B_stendre`.
    *   Further logic (a `Check ~= 0` block V.6.6) combines `B_stendre` with other flags (`B_stendz`, `B_sshev`) to yield `B_stend` and `B_sshev`.

4.  **`B_tumgfil` Determination**: Multiple configuration bits, `B_kli15_dly`, and the processed `B_stendre` are logically combined (using `AND` and `OR` gates). The resulting signal `B_tumgfili` then passes through another rate limiter (V.5.3) to produce `B_tumgfil`. This signal likely indicates when the ambient temperature is actively being considered for filtering.

5.  **Ambient Temperature Selection (`T`)**:
    *   The `ZTTUMGBKS` block (V.6.4) and a 2D lookup table `KFTETK` (V.7.3) are involved. `KFTETK` uses `B_tmm_w` for both its `x_val` and `y_val` inputs, implying either a single-axis lookup where the input is used for both indexing, or a specific mode where `x` and `y` are the same. Its output is `IP_val`.
    *   A constant `0`, an inverted `B_tmm_w`, and `B_tmm_n` (output of an `OR` gate) are fed into a `Check ~= 0` block (V.6.6) along with `IP_val`. This complex arrangement selects the appropriate raw ambient temperature `T` that will be fed into the primary thermal model.

6.  **Main Thermal Model / Integrator (Large V.5.3 Block)**:
    *   This is a key block, likely implementing a low-pass filter, a rate limiter, or a simple thermal model. It takes `IV` (initial value), `dT` (delta time), and the selected ambient temperature `T` as inputs. `B_tumgfil` acts as a reset (`R`) for this block, implying that the model can be reset or re-initialized based on this flag.
    *   The `1000MS` constant is also an input, possibly as a time constant or a sampling frequency.
    *   The block outputs a processed temperature `y`, which is then explicitly labeled as `teitaa` and `tktm`.

7.  **`tumgtbks` Output Generation**: Various status flags and the `IP_val` from `KFTETK` are combined within a `Check ~= 0` block (V.6.6) to generate the boolean output `tumgtbks`. This flag asserts when the filtered ambient temperature `tumg` (and thus `teitaa`, `tktm`) is considered valid and active.

8.  **`B_tmodini` (Temperature Model Initialization)**: `B_stend_kl15` and `B_tmodini_prev` are combined with an inverted `GET BIT` output via an `AND` gate. This result then passes through a `NOT` gate and an `if` block (V.6.0) to determine the current state of `B_tmodini`, which likely triggers or controls the initialization of the temperature model.

---

## 43.4.6.2 TTANKMOD Analysis

### Function
This Simulink diagram, `TTANKMOD` (Tank Temperature Model), is designed to calculate and update the estimated fuel tank temperature (`ttankbks`). It integrates inputs from ambient temperature, fuel level, vehicle conditions, and various configuration settings. The model employs lookup tables to determine thermal coefficients and a thermal integrator/low-pass filter to simulate the dynamic thermal behavior of the fuel tank.

### Inputs
*   **CWTMODBKS**: Configuration word (same as used in TUMGBKS), providing mode-specific settings.
*   **B_getankt**: Boolean flag, indicating if the vehicle has just been refueled or "tanked".
*   **B_tumgfili**: Boolean flag, indicating active ambient temperature filtering (originates from TUMGBKS).
*   **B_tmm_t**: Boolean flag, a specific temperature model setting or condition.
*   **ttankabs**: Absolute fuel tank temperature, possibly a raw sensor reading or a baseline value.
*   **tumgtbks**: Processed and validated ambient temperature (output from TUMGBKS).
*   **tabst_w**: Weighting factor for ambient temperature, likely related to static or "standstill" conditions.
*   **tum_w**: Weighting factor for ambient temperature, possibly related to dynamic or "moving" conditions.
*   **v_val**: Vehicle speed or a related velocity parameter.
*   **tankh_w**: Fuel tank fill level (e.g., height, volume percentage).
*   **teitaa**: Filtered ambient temperature (output from TUMGBKS), used as an input to the thermal model.
*   **tktm**: Raw or intermediate temperature (output from TUMGBKS), also used as an input to the thermal model.
*   **ttankbks1**: Input representing the current estimated tank temperature, likely a feedback from the previous iteration or the output of the internal integrator.

### Outputs
*   **ttankbks**: The final calculated and updated fuel tank temperature (analog value).
*   **dtankst**: The calculated difference or change in tank temperature (analog value).
*   **bdn**: Boolean output, likely a status flag related to tank temperature calculation conditions.
*   **tktm**: Processed temperature output (passed through, related to `teitaa`).
*   **teitaa**: Processed temperature output (passed through, derived from the main thermal model).

### Logic Flow

1.  **Configuration Bit Extraction**: `CWTMODBKS` is processed by `GET BIT` blocks (V.7.0) to extract specific boolean flags (`bit_sel`) that control activation logic.

2.  **Activation Logic for `B_tmm_n` and `B_tmm_t`**:
    *   An inverted `B_getankt` signal is `AND`ed with specific extracted bits from `CWTMODBKS` to determine `B_tmm_n`.
    *   `B_getankt` (not inverted) is `AND`ed with other extracted bits from `CWTMODBKS` to determine `B_tmm_t`.
    *   These flags, along with `B_tumgfili` (from TUMGBKS), are combined via `OR` and `AND` gates to generate `B_tmm_n`, which feeds into the thermal model. This logic likely handles conditions like refueling, which can significantly impact tank temperature.

3.  **Temperature Difference Calculation (`dtankst`)**: The `ttankabs` (absolute tank temperature) is subtracted from `tumgtbks` (processed ambient temperature from TUMGBKS) using a subtractor block (V.7.2). The result, `dtankst`, represents the immediate temperature difference driving heat exchange.

4.  **Static/Ambient Thermal Coefficient (KLFTTANKST)**:
    *   A 2D lookup table, `KLFTTANKST` (V.7.3), determines a coefficient based on `tabst_w` (x-axis) and `tum_w` (y-axis).
    *   The output `IP_val` is `vfz_g`, which is likely a weighting or scaling factor for the thermal influence of ambient conditions on the tank, particularly when stationary or moving slowly.

5.  **Dynamic Thermal Factor (KFTETK)**:
    *   Another 2D lookup table, `KFTETK` (V.7.3), takes `v_val` (vehicle speed/velocity, x-axis) and `tankh_w` (tank fill level, y-axis) as inputs.
    *   The output `IP_val` is `teitaar`, representing a dynamic thermal factor influenced by vehicle movement and fuel volume.

6.  **Core Thermal Model / Integrator (Large V.5.3 Block)**:
    *   This block, similar to the one in TUMGBKS, acts as the central thermal model. It takes `teitaar` (dynamic thermal factor) and `tktm` (from TUMGBKS) as inputs. The `1000MS` constant is also an input, likely a time constant or a sampling rate for the internal integration.
    *   The output `y` from this block represents the filtered or dynamically modeled tank temperature. This `y` is then explicitly labeled `teitaa`.

7.  **Final Tank Temperature Calculation (`ttankbks`)**:
    *   The output `y` from the V.5.3 thermal model (labeled `ttankbks1` as input to the sum block) is added to `dtankst` (the calculated temperature difference) using a sum block (V.7.2).
    *   The result is the final `ttankbks`, the estimated fuel tank temperature, which is then outputted.

8.  **`bdn` Output Generation**: The `B_tumgfili` flag (from TUMGBKS) is combined with an intermediate signal (output of an `AND` gate) to produce the boolean output `bdn`. This flag likely signifies a specific condition or validity state of the tank temperature calculation.


--- Page 47 ---

This page contains two Simulink-like diagrams, labeled "43.4.6.3 TWOELBKS" and "43.4.6.4 SELECT_KFFLAFIN". I will analyze each separately.

---

### **Diagram: 43.4.6.3 TWOELBKS**

## Function
This subsystem is designed to determine a corrected or selected engine operating temperature, output as `tmotbks`. It integrates various temperature measurements (engine oil, coolant, ambient) and applies logic based on operational conditions (e.g., cold temperatures, idle-near range, interior heating) and sensor availability/configuration, likely for fuel temperature compensation or engine protection strategies within an automotive system. It also generates a boolean flag `B_tmtobks` indicating a specific temperature selection condition.

## Inputs
*   **B_tospgpl** (Boolean, labelled '5'): A flag indicating the validity or usage of ambient temperature `tosp`.
*   **dmkrhdev_w** (Scalar, labelled '1'): A measured or derived value, possibly related to heating deviation.
*   **DMKRTBKS** (Parameter/Scalar): A threshold or constant used for comparison with `dmkrhdev_w`.
*   **tosp** (Scalar, labelled '2'): Ambient temperature.
*   **tmot** (Scalar, labelled '3'): Engine oil temperature.
*   **tumgtbks** (Parameter/Scalar): A threshold or constant, likely related to engine temperature management.
*   **CWTMODBKS** (Parameter/Configuration Word): A bitmask or configuration register, where Bit 6 controls a specific temperature selection logic.
*   **OTMOTBKS** (Parameter/Scalar): An offset value for oil temperature correction; its non-zero value also acts as an enable flag.
*   **toel** (Scalar, labelled '4'): Engine coolant temperature.

## Outputs
*   **B_tmtobks** (Boolean, labelled '1'): A flag indicating a specific condition related to temperature selection logic.
*   **tmotbks** (Scalar, labelled '2'): The final selected and/or corrected engine operating temperature.

## Logic Flow (43.4.6.3 TWOELBKS)
1.  **Intermediate Conditions:**
    *   `dmkrhdev_w` is compared with `DMKRTBKS` using a less-than (`<`) operator.
    *   `tumgtbks` is compared with `toel` using a less-than (`<`) operator.
    *   Bit 6 of the `CWTMODBKS` configuration word is extracted using a "GET BIT" block. This bit (let's call it `CWTMODBKS_Bit6`) enables the MAX selection between `tmot` and `tosp`.

2.  **`B_tmtobks` Calculation:**
    *   The result of `(dmkrhdev_w < DMKRTBKS)` is negated using a `NOT` operator.
    *   This negated result, along with `(tumgtbks < toel)`, `B_tospgpl`, and `CWTMODBKS_Bit6`, are fed into an `AND` gate.
    *   The output of this `AND` gate is assigned to `B_tmtobks`. This flag likely signifies a specific operating condition where a particular temperature selection strategy is active (e.g., "near-idle and cold outside temperatures" as per the German comment).

3.  **Temperature Pre-Selection based on `tosp` / `tmot` / `toel`:**
    *   `tosp` and `tmot` are fed into a `MAX` block, which outputs the greater of the two.
    *   `CWTMODBKS_Bit6` and `B_tospgpl` are combined in an `AND` gate. The result of this `AND` gate controls a switch block (labeled "Check ~= 0").
    *   If `(CWTMODBKS_Bit6 AND B_tospgpl)` is true, the `MAX(tosp, tmot)` result is selected.
    *   Otherwise (if `(CWTMODBKS_Bit6 AND B_tospgpl)` is false), `toel` (coolant temperature) is selected. This implements the rule for enabling `MAX(tosp, tmot)` selection based on `CWTMODBKS.Bit6`.

4.  **Oil Temperature (`tmot`) Correction:**
    *   `tmot` and `OTMOTBKS` are fed into an `ADD` block.
    *   The value of `OTMOTBKS` itself controls another switch block (labeled "Check ~= 0"). If `OTMOTBKS` is non-zero (interpreted as true), an offset is applied.
    *   If `OTMOTBKS` is non-zero, then `(tmot + OTMOTBKS)` is selected.
    *   Otherwise (if `OTMOTBKS` is zero), `tmot` itself is selected. This implements the rule to add an offset to `tmot` if the oil temperature sensor is unavailable or not operational (where `OTMOTBKS` acts as the offset value and its enablement flag).

5.  **Final `tmotbks` Determination:**
    *   The output of the "Temperature Pre-Selection" step and the output of the "Oil Temperature Correction" step are fed into a final switch block (also labeled "Check ~= 0", represented with a curved line).
    *   The control input for this final switch is `B_tmtobks`.
    *   If `B_tmtobks` is true, the temperature from the "Temperature Pre-Selection" (i.e., `MAX(tosp, tmot)` or `toel`) is chosen.
    *   If `B_tmtobks` is false, the potentially offset `tmot` from the "Oil Temperature Correction" step is chosen.
    *   The output of this final switch is `tmotbks`.

---

### **Diagram: 43.4.6.4 SELECT_KFFLAFIN**

## Function
This subsystem selects or calculates a corrected fuel mass flow value, `kfflafincor`, based on a configuration bit. It manages different modes for fuel mass flow calculation, potentially distinguishing between total fuel mass and fuel mass specifically for high-pressure injectors, as implied by the German comments.

## Inputs
*   **kfflafin_w** (Scalar, labelled '1'): Primary or raw fuel mass flow.
*   **dmkrmpi_w** (Scalar, labelled '2'): A value representing a component of fuel mass flow, possibly for multi-point injection (MPI) or an additive component.
*   **CWTMODBKS2** (Parameter/Configuration Word): A bitmask or configuration register, where Bit 3 controls the fuel mass flow selection logic.

## Outputs
*   **kfflafincor** (Scalar, labelled '1'): The final corrected fuel mass flow.

## Logic Flow (43.4.6.4 SELECT_KFFLAFIN)
1.  **Bit 3 Check of CWTMODBKS2:**
    *   Bit 3 of the `CWTMODBKS2` configuration word is extracted using a "GET BIT" block. This bit (let's call it `CWTMODBKS2_Bit3`) is critical for mode selection.
    *   According to the description:
        *   If `CWTMODBKS2_Bit3` is `false`: "The complete mass from EFP will be used."
        *   If `CWTMODBKS2_Bit3` is `true`: "Only fuel mass for high pressure injectors will be taken into account for tfuelmx."

2.  **Adjusted Fuel Mass Flow Calculation:**
    *   `kfflafin_w` and `dmkrmpi_w` are summed using an `ADD` block.
    *   The result of this sum, along with a constant `0`, is fed into a `MAX` block. This ensures that the calculated fuel mass flow is never negative (`max(0, kfflafin_w + dmkrmpi_w)`). This intermediate result represents a "complete" or combined fuel mass.

3.  **Final `kfflafincor` Selection:**
    *   The output of the "Adjusted Fuel Mass Flow Calculation" and the original `kfflafin_w` are fed into a switch block (labeled "Check ~= 0", represented with a curved line).
    *   The control input for this switch is `CWTMODBKS2_Bit3`.
    *   If `CWTMODBKS2_Bit3` is `true` (indicating high-pressure injector fuel mass), the original `kfflafin_w` is selected. This suggests `kfflafin_w` itself represents the high-pressure injector fuel mass in this mode.
    *   If `CWTMODBKS2_Bit3` is `false` (indicating complete fuel mass from EFP), the "Adjusted Fuel Mass Flow" (`max(0, kfflafin_w + dmkrmpi_w)`) is selected. This implies that `dmkrmpi_w` contributes to the total fuel mass when the complete mass is considered.
    *   The output of this final switch is `kfflafincor`.


--- Page 48 ---

This page contains two Simulink diagrams, which are analyzed below.

## Function

The primary function of these Simulink diagrams, titled "MDLDITEMP" (Modeled Difference Temperature) and "MDLMPITEMP" (Modeled Multi-Point Temperature), is to model and process various fuel and component temperatures within an automotive system. They calculate different temperature values (e.g., compensated temperatures, difference temperatures, flow-related temperatures, and compensation factors) based on several input signals. This processing involves look-up tables for calibration, bit-wise operations for status/mode decoding, conditional logic for operational variations, and basic arithmetic. These calculations are crucial for accurate fuel quantity measurement, engine control strategies, and diagnostic functions related to fuel temperature management.

## Inputs

**From "43.4.6.5 MDLDITEMP" (Figure 43.4.13):**
1.  **`tmofbks`**: Modeled fuel temperature (likely from a sensor or estimation).
2.  **`vifzg_w`**: A signal related to volume flow or mass air flow.
3.  **`lepwmfan`**: A signal representing fan pulse-width modulation, possibly indicating cooling demand.
4.  **`ttankbks`**: Fuel tank temperature.
5.  **`kfflaflncor`**: Fuel flow compensation factor or a related correction value.
6.  **`RadBli_rActr_VW`**: Raw radiator actuator value.
7.  **`B_stend`**: A boolean flag, likely indicating engine standstill or a specific operational state.
8.  **`RadBli_rActr_VW_SC`**: Scaled radiator actuator value, used for conditional logic.
9.  **`RadBli_vCmptmt_VW_SC`**: Scaled compartment temperature value, used for conditional logic.
10. **`RadBli_vCmptmt_VW`**: Raw compartment temperature value.
11. **`tfuelmx`**: Fuel mixture temperature.
12. **`tumgtbks`**: Engine housing or coolant temperature.
13. **`tfvuradtbks`**: Fuel vapor return temperature (serves as both input and output, implying an initial value or a feedback loop).
14. **`trohvhdp`**: Return oil/hydraulic fluid temperature (serves as both input and output, implying an initial value or a feedback loop).

**From "43.4.6.6 MDLMPITEMP" (Figure 43.4.14):**
1.  **`tmofbks`**: Modeled fuel temperature (shared input with MDLDITEMP).
2.  **`tans`**: Ambient temperature.
3.  **`tumgtbks`**: Engine housing or coolant temperature (shared input with MDLDITEMP).
4.  **`dmkrmpi_w`**: A signal related to engine speed or a compensation factor for fuel mass.
5.  **`tflvrhdp`**: Fuel temperature, possibly for vapor recovery or return.

## Outputs

**From "43.4.6.5 MDLDITEMP" (Figure 43.4.13):**
1.  **`tcomphd`**: Compensated header/main temperature.
2.  **`ffwkbks`**: Fuel flow working value or a compensation factor.
3.  **`tfvuradtbks`**: Fuel vapor return temperature (output, potentially updated value from input).
4.  **`tdiffhd`**: Difference temperature.
5.  **`trohvhdp`**: Return oil/hydraulic fluid temperature (output, potentially updated value from input).

**From "43.4.6.6 MDLMPITEMP" (Figure 43.4.14):**
1.  **`trohvmpi`**: Return oil/hydraulic fluid temperature (different calculation/purpose from `trohvhdp`).
2.  **`tdiffmpi`**: Difference temperature (different calculation/purpose from `tdiffhd`).
3.  **`tcompmpi`**: Compensated primary temperature.
4.  **`fkmplfl`**: Fuel compensation factor or flow limiter factor.

## Logic Flow

The logical flow involves parallel computations across multiple paths, converging to produce various temperature values.

### For "43.4.6.5 MDLDITEMP" (Figure 43.4.13):

1.  **Input Conditioning and Bit Extraction:**
    *   `tmofbks` and `tumgtbks` (and other implied internal signals) undergo bit-wise extraction (`GET BIT` blocks) via `CWTMODBKS` blocks, producing control signals (`bit_sel0`, `num_dec`) for switches or further processing.
    *   `B_stend` acts as a condition for a switch, selecting between different values.

2.  **Look-Up Table (LUT) Processing:**
    *   Various inputs like `vifzg_w`, `lepwmfan`, `ttankbks`, `kfflaflncor`, `RadBli_rActr_VW`, and `tumgtbks` are fed into 1D or 2D Look-Up Tables (`KFVFTBKS`, `TOFSVHSK`, `KFNKSSK`, `KLPRADBTBKS`, `KFL_B_B`). These tables map input values to calibrated output values, often representing compensations or specific physical properties.

3.  **Conditional Logic for Actuator/Compartment Values:**
    *   `RadBli_rActr_VW_SC` and `RadBli_vCmptmt_VW_SC` are compared against a value (e.g., -1). Based on these comparisons, `If/Else` blocks or switches select between the output of an LUT (e.g., `KLPRADBTBKS`) or a default value (e.g., 0), or between different raw temperature values. This handles different operating conditions or fault states for radiator and compartment values.
    *   The selected values undergo subtractions with raw `RadBli_rActr_VW` and `RadBli_vCmptmt_VW` respectively.

4.  **`ffwkbks` Calculation (Output 2):**
    *   `ffwkbks` is computed through a `Merge` block, combining outputs from two paths: one involving `KFNKSSK` and another involving `KFL_B_B`, both multiplied by an intermediate signal (`tdifftr`). The selection criteria for the `Merge` block are implied by upstream conditional logic.

5.  **`tcomphd` Calculation (Output 1):**
    *   Multiple signals (processed `tfuelmx`, `tumgtbks`, outputs from `KFVFTBKS`, `TOFSVHSK`, and conditioned bit values) are summed together.
    *   This sum is then combined with the input `tfvuradtbks` and passed through a limiter (V.6.1) to produce `tcomphd`.

6.  **`tdiffhd` Calculation (Output 4):**
    *   `tdiffhd` is derived by subtracting the input `tfvuradtbks` from `tcomphd`, and the result is passed through another limiter (V.6.1).

7.  **`trohvhdp` Calculation (Output 1):**
    *   The input `trohvhdp` is summed with the results of the conditional `RadBli_rActr_VW` and `RadBli_vCmptmt_VW` processing paths (from step 3), which involve subtractions and merge blocks. The final sum produces the `trohvhdp` output.

### For "43.4.6.6 MDLMPITEMP" (Figure 43.4.14):

1.  **Look-Up Table (LUT) Processing:**
    *   `tmofbks` and `tans` are fed into `KFCOMPMPI` (2D LUT).
    *   `tumgtbks` and `dmkrmpi_w` are fed into `KFMPICOR` (2D LUT).
    *   `dmkrmpi_w` and another unnamed signal are fed into `KFKMPIFL` (2D LUT).

2.  **`tcompmpi` Calculation (Output 3):**
    *   The output of `KFCOMPMPI` is summed with the output of `KFMPICOR`.
    *   This sum is then added to `tflvrhdp` and passed through a limiter (V.6.1) to produce `tcompmpi`.

3.  **`tdiffmpi` Calculation (Output 2):**
    *   `tflvrhdp` is subtracted from `tcompmpi`.
    *   The resulting difference is passed through a limiter (V.6.1) to produce `tdiffmpi`.

4.  **`fkmplfl` Calculation (Output 4):**
    *   The output of `KFKMPIFL` is passed through a limiter (V.6.1) to produce `fkmplfl`.

5.  **`trohvmpi` Calculation (Output 1):**
    *   The output of `KFCOMPMPI` is summed with `tdiffmpi` and an unnamed signal.
    *   This final sum produces the `trohvmpi` output.

Both diagrams extensively use limiter blocks (V.6.1) to ensure calculated values remain within realistic and safe operating ranges for automotive systems.


--- Page 49 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "43.4.6.7 TEMPFILTER" and labeled for "FUSL, Fuel temperature (Appl. Inc.)", describes a system designed to filter temperature measurements. Its primary function is to process raw temperature signals (`trohvhd`, `trohvmpi`) and produce two distinct filtered temperature outputs (`tfllvrhdp`, `tfllvmpi`). The filtering process is dynamic, with its enable, reset, and time constant parameters adjusted based on various system states, configuration values, and lookup table calculations, ensuring adaptive temperature signal conditioning for fuel temperature applications.

## Inputs
The key inputs to this system are:
*   **Raw Temperature Measurements:**
    *   `trohvhd` (Analog or digital temperature reading for the 'hdp' path)
    *   `trohvmpi` (Analog or digital temperature reading for the 'mpi' path)
*   **System State/Control Signals:**
    *   `B_stend_kl15` (Boolean, system status/enable)
    *   `B_tospgpl` (Boolean, system status/enable)
    *   `B_hst` (Boolean, system status/enable)
    *   `B_stendz` (Boolean, system status/enable)
    *   `B_sshev` (Boolean, system status/enable)
    *   `B_stend` (Boolean, system status/enable)
    *   `B_tmbkser` (Boolean, filter enable/mode selection)
    *   `reset_tflvrhdp_lp` (Boolean, reset signal for filters)
*   **Initial Values/Calibration Parameters:**
    *   `tflvrhdp_filt_ini` (Initial value for the 'hdp' filter)
    *   `tfllvmpi_filt_ini` (Initial value for the 'mpi' filter)
*   **Temperature-Related Inputs for Parameterization:**
    *   `tabst_w` (Temperature input for lookup table)
    *   `tka` (Temperature input for RESBBKS)
    *   `tksvhdpa` (Temperature input for RESBBKS)
    *   `tmotbks` (Temperature input for RESBBKS and summation, an orange block indicates it's likely a persistent value or a feedback)
    *   `tumgtbks` (Temperature input for summation)
    *   `tkast` (Temperature input for ZTTMBKS)
    *   `tkatubks` (Temperature input for ZTTMBKS)
    *   `B_rzttmbks` (Temperature input for ZTTMBKS)
    *   `B_zttmgr` (Temperature input for ZTTMBKS)
    *   `tksvmpiabs` (Input for KFINITMPI lookup table)
    *   `dmkrmpi_w` (Input for KFFLTMMPI lookup table)
    *   `tdiffmpi` (Input for KFFLTMMPI lookup table)

## Outputs
The primary outputs of this system are:
*   `tfllvrhdp` (Filtered fuel temperature for the 'hdp' path)
*   `tfllvmpi` (Filtered fuel temperature for the 'mpi' path)

Auxiliary or intermediate outputs that exit sub-blocks but are used within the overall system:
*   `fazbksy_w`, `fabstbks`, `tkadifbks`, `B_tmodbks`, `tstbks` (from RESBBKS block)
*   `tdiffbks_w` (from ZTTMBKS block, used as filter time constant)
*   `tkast`, `tkatubks`, `B_rzttmbks`, `B_zttmgr` (outputs from ZTTMBKS, potentially modified pass-throughs)

## Logic Flow

The system's logic can be broken down into several interconnected stages:

1.  **System State and Mode Determination (Left-Top and Central-Top):**
    *   Multiple boolean input signals such as `B_stendz`, `B_sshev`, `B_stend`, and `B_tmbkser` are fed into `CWTMODBKS2` (V.6.4) and `Check == 0` (V.6.6) blocks.
    *   This logic determines various control flags (`bit_sel_0`, `num_dec`) and derived state signals (`B_stendre`, `B_sshev1`, `tnse_w`, `tnsez_w`, `tka`, `tumg`, `kfflafin`).
    *   Crucially, these control signals also generate the enable (`E`) and reset (`R`) conditions for the two main T-filter blocks through a series of `AND` gates and `Check == 0` blocks. A `NOT` gate also affects the enable for the HDP filter based on `B_tmbkser`. The `reset_tflvrhdp_lp` signal also feeds into the reset logic for both filters.

2.  **Initial Temperature Processing and Status (Left-Central):**
    *   The `RESBBKS` (X.6.8.2) block takes a range of system status and temperature-related inputs (`B_stend_kl15`, `B_tospgpl`, `B_hst`, `tabst_w`, `tka`, `tksvhdpa`, `tmotbks`). It processes these to output several boolean flags (`fazbksy_w`, `fabstbks`, `tkadifbks`, `B_tmodbks`, `tstbks`) and a processed `tmotbks` signal. The `tmotbks` input/output suggests an internal state or an input that is processed and then outputted.
    *   The `ZTTMBKS` (X.6.8.1) block receives several derived state signals from the `CWTMODBKS2` path, along with `tkast`, `tkatubks`, `B_rzttmbks`, `B_zttmgr`. Its primary output, `tdiffbks_w`, is a critical parameter for the filters. It also outputs potentially modified versions of its `tkast`, `tkatubks`, `B_rzttmbks`, `B_zttmgr` inputs.

3.  **Filter Parameter Determination (Central-Bottom and Right-Central):**
    *   **Time Constants:** The `tdiffbks_w` signal from `ZTTMBKS` is fed into `TMBIKSER` (V.6.4) and `TMPJBKSER` (V.6.4`) blocks. The outputs of these blocks serve as the dynamic time constants (`T`) for the upper and lower T-filters, respectively.
    *   **Lookup Table for Filter Initialization/Adaptation:**
        *   The `tmotbks` signal (from RESBBKS) is summed with `tumgtbks` to produce `tmo`.
        *   This `tmo` signal, along with `tabst_w` and `tksvmpiabs`, feeds into `KFINITMPI` (V.7.3), a 2D lookup table. The output is processed further (summed with another value and multiplied).
        *   Similarly, `dmkrmpi_w` and `tdiffmpi` feed into `KFFLTMMPI` (V.7.3), another 2D lookup table.
        *   The outputs of these lookup tables and subsequent arithmetic operations (`+ V.7.5`, `X V.7.6`) likely contribute to dynamically calculated initial conditions or other adaptive parameters for the filters.

4.  **Temperature Filtering (Right-Central):**
    *   **Upper T-Filter (for `tfllvrhdp`):**
        *   Takes `trohvhd` as the measurement input (`u`).
        *   Receives its Enable (`E`) and Reset (`R`) signals from the logic derived in step 1.
        *   Its time constant (`T`) is provided by `TMBIKSER` (from `tdiffbks_w`).
        *   Its initial value (`x_in`) is `tflvrhdp_filt_ini`.
        *   The block outputs the filtered temperature `tfllvrhdp`.
    *   **Lower T-Filter (for `tfllvmpi`):**
        *   Takes `trohvmpi` as the measurement input (`u`).
        *   Receives its Enable (`E`) and Reset (`R`) signals from the same logic as the upper filter (derived in step 1).
        *   Its time constant (`T`) is provided by `TMPJBKSER` (from `tdiffbks_w`).
        *   Its initial value (`x_in`) is `tfllvmpi_filt_ini`.
        *   The block outputs the filtered temperature `tfllvmpi`.

In essence, the system continuously monitors various operational states and raw temperature readings, dynamically adjusting the characteristics (enable, reset, time constant, potentially initial conditions) of two independent low-pass filters to produce conditioned fuel temperature signals for two different paths ('hdp' and 'mpi').


--- Page 50 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, titled "FUSL, Fuel temperature (Appl. Inc.)" and located at the path "TEMPFILTER/ZTTMBKS", primarily functions to calculate and manage a dynamic, filtered fuel temperature (`zttm_w`) and related control flags. It integrates multiple temperature sensors (fuel, ambient, cold start reference), engine state (ignition/start conditions), and calibrated lookup tables to provide a robust and dynamic fuel temperature signal, along with boolean flags (`B_rzttmbks`, `B_zttmgr`) that indicate specific operational states or reset conditions for a "Zeit-Temperatur-Modell" (Time-Temperature Model) or similar temperature-dependent logic. The goal is to adapt the dynamic temperature profile based on temperature differences between the engine and ambient, and potentially vehicle speed.

## Inputs

*   **`tnsez_w` (4)**: Primary fuel temperature input, possibly a pre-filtered or zero-point corrected value.
*   **`B_sshev` (2)**: A boolean signal, likely an enable or status flag affecting the initial temperature processing.
*   **`tnse_w` (3)**: Another fuel temperature input, possibly a raw sensor reading or a different filtered version.
*   **`tka` (5)**: "Kaltstartanhebung" (cold start enrichment) temperature or a critical ambient/engine reference temperature.
*   **`tumg` (6)**: Ambient temperature.
*   **`ZSNMST`**: "Zündung Status Motor Start" (Ignition Status Engine Start) – a threshold value or status flag related to engine starting conditions.
*   **`TDSBKS`**: "Temperatur Differenz Start Bedingung" (Temperature Difference Start Condition) – another threshold or condition parameter related to engine starting.
*   **`tdiffbks_w` (8)**: A calculated temperature difference, likely between engine and ambient.
*   **`kfflafincor` (7)**: A correction factor or increment/decrement value, possibly related to fuel temperature adaptation.

## Outputs

*   **`zttm_w` (1)**: The primary output, representing the dynamically filtered or adjusted fuel temperature.
*   **`tkast` (2)**: A processed temperature value, likely a filtered or selected cold start reference temperature.
*   **`tkatubks` (3)**: A combined or derived temperature value, possibly related to ambient and cold start temperatures for adaptation.
*   **`B_rzttmbks` (4)**: A boolean flag indicating a reset condition for the ZTTMBKS (Time-Temperature Model) process.
*   **`B_zttmgr` (5)**: A boolean flag indicating the managed state of the ZTTM process, likely controlled by an RS flip-flop.

## Logic Flow

The logical flow can be broken down into several interconnected paths:

1.  **Primary Dynamic Fuel Temperature Calculation (`zttm_w`)**:
    *   Inputs `tnsez_w`, `B_sshev`, and `tnse_w` are fed into a block labeled "Check ~= 0 V.6.6".
    *   This block likely implements a filtering algorithm (e.g., a first-order lag, moving average, or conditional selection) on `tnse_w` or `tnsez_w`. The `B_sshev` signal probably enables or modifies this filtering. The "Check ~= 0" may imply a division by a value that needs to be non-zero, or a general validation.
    *   The output of this block is `zttm_w` (Output 1), which is the dynamic fuel temperature.

2.  **Cold Start/Ambient Temperature Processing (`tkast`, `tkatubks`)**:
    *   `tka` (Input 5) and `tnse_w` (Input 3) are compared. A comparison block (V.6.1) with an associated multiplexer or selector determines the output `tkast` (Output 2), possibly taking the maximum or selecting based on a condition (e.g., if `tnse_w` is greater, use `tnse_w`, otherwise `tkast`).
    *   `tkast` (Output 2) and `tka` are summed (V.7.2). This sum is then used as the input (`x_val`) to a 1D lookup table "KFLDBKS" (V.7.2), producing an `IP_val`.
    *   `tumg` (Input 6) and `tka` are subtracted (V.7.2) to produce a temperature difference (`x_val`).
    *   This temperature difference (`x_val`) and the `IP_val` from "KFLDBKS" (`y_val`) are fed into a 2D lookup table "KFZTST" (V.7.3), which also outputs an `IP_val`.
    *   `tkast` (Output 2) and `tumg` (Input 6) are summed (V.7.2) to produce `tkatubks` (Output 3), a combined temperature used for further adaptation.

3.  **ZTTMBKS Reset Condition Logic (`B_rzttmbks`)**:
    *   `tka` (Input 5) is compared with `ZSNMST` and `TDSBKS` using two greater-than comparators (V.6.2).
    *   The results of these two comparisons are combined via an OR gate (V.6.3).
    *   If `tka` is greater than `ZSNMST` OR greater than `TDSBKS`, then `B_rzttmbks` (Output 4) becomes true, signaling a reset condition for the Time-Temperature Model.

4.  **ZTTM Manager State Logic (`B_zttmgr`)**:
    *   An RS Flip-Flop (V.5.5) controls the state of `B_zttmgr` (Output 5).
    *   **RESET Logic**:
        *   `tdiffbks_w` (Input 8) is compared with `ZSNMST` and `TDSBKS` in two comparators (V.6.2).
        *   The results of these comparisons, along with an unspecified signal from a block labeled "Bewertung der Bedingungen im Start" (Evaluation of conditions at start), are combined using an AND gate (V.6.6). This ANDed output contributes to the RESET input of the flip-flop.
        *   Additionally, the `B_rzttmbks` (Output 4) signal is also fed into the RESET input. Therefore, `B_zttmgr` will be reset if a combination of start conditions, temperature differences, and the general ZTTMBKS reset flag are met.
    *   **SET Logic**:
        *   `tkatubks` (Output 3) and `kfflafincor` (Input 7) are used as `x_val` and `y_val` inputs to a 2D lookup table "KFZTTMM" (V.7.3).
        *   The output (`IP_val`) of this lookup table directly feeds the SET input of the RS Flip-Flop. This lookup table ("Anpassung des dynamischen Temperaturverlaufs...") calculates an adjustment based on temperature differences and correction factors, and its output determines when to set `B_zttmgr`, indicating the dynamic temperature model is active or ready.


--- Page 51 ---

## Function
The diagram illustrates a Simulink model for a **Fuel Temperature Conditioning, Filtering, and Validation System**. Its primary function is to take various raw temperature inputs and system status flags, process them through conditional logic, lookup tables, and bitfield extractions, to produce derived, filtered, and validated fuel temperature values, as well as status flags relevant for fuel management and diagnostics, particularly concerning hot start conditions and temperature resilience. The path `FUSL_M408B/OPM_100MS/TEMPFILTER/RESBBKS` suggests that this module is part of a larger fuel temperature management system, specifically handling temperature filtering and resilience mechanisms.

## Inputs

1.  **`B_stend_kl15`**: (Boolean/Discrete) Status of electrical terminal 15 (ignition).
2.  **`reset_tflvrhdp_lp`**: (Boolean/Discrete) A reset signal for internal logic or states.
3.  **`tabst_w`**: (Analog) Ambient temperature or a base fuel temperature reading.
4.  **`tge_w`**: (Analog) A general temperature input.
5.  **`tmotbk_w`**: (Analog) Motor block temperature.
6.  **`tkal_w`**: (Analog) Another general temperature input.
7.  **`tk_w`**: (Analog) Yet another general temperature input.
8.  **`tqfll`**: (Analog) Fuel quantity/level related temperature input for `KFFAZBKS`.
9.  **`tqfld`**: (Analog) Another fuel quantity/level related temperature input for `KFFADIFBKS`.
10. **`tmotbk`**: (Analog) Motor block temperature, specifically for `KFFADIFBKS`.
11. **`B_hst`**: (Boolean) Hot Start flag.
12. **`tmotbkabs`**: (Analog) Absolute motor block temperature; passed through directly to several outputs.
13. **`tksvhdpabs`**: (Analog) Absolute temperature/pressure; passed through directly to an output.
14. **`TGRESBKS`**: (Word/Integer) Temperature Resilience configuration or status word.
15. **`tmodtbks`**: (Analog) A modified or reference temperature input for difference calculation.
16. **`CWTMODBKS2`**: (Word/Integer) Control Word for Modulus/Configuration, from which bit 1 is extracted.
17. **`Fregabe Heissstartcheck`**: (Boolean) German for "Enable Hot Start Check" flag.
18. **`CWTMODBKS3`**: (Word/Integer) Control Word for Modulus/Configuration, from which bit 0 is extracted.
19. **`B_tospgpl`**: (Word/Integer) Status word, possibly related to "Total Operating Hours/Service Life", from which bit 2 is extracted.
20. **`CWTMODBKS`**: (Word/Integer) Control Word for Modulus/Configuration, from which bit 6 is extracted.

## Outputs

1.  **`tflsoll_w`**: (Analog) Target/nominal fuel temperature, derived from `tmotbkabs` input.
2.  **`volfuel_w`**: (Analog) Fuel volume or related quantity, derived from `tksvhdpabs` input.
3.  **`tfl_w`**: (Analog) Fuel temperature, derived from `tmotbkabs` input.
4.  **`fabstfbsk`**: (Analog) Filtered or compensated fuel temperature, likely ambient-based, from `KFFAZBKS`.
5.  **`tkadifbks`**: (Analog) Filtered or compensated fuel temperature, possibly adiabatic or based on motor temperature, from `KFFADIFBKS`.
6.  **`fazbksy_w`**: (Analog) The conditionally selected (multiplexed) fuel temperature.
7.  **`tmodbksC`**: (Boolean/Discrete) Status or flag indicating a modified temperature condition.
8.  **`tstbks`**: (Analog/Discrete) Final validated fuel temperature or its status, potentially indicating resilience activation or hot-start relevance based on a difference calculation.

## Logic Flow

1.  **System State and Sequencing Initialization:**
    *   The `B_stend_kl15` signal (ignition status) is processed (by a block labelled `u` to `y`) and fed into a `cond_if` block, along with `reset_tflvrhdp_lp`.
    *   The output of the `cond_if` block controls a `sequencer` block (`V.6.4`). This `sequencer` receives multiple raw temperature inputs (`tabst_w`, `tge_w`, `tmotbk_w`, `tkal_w`, `tk_w`). It outputs 5 signals, which are likely selected or processed temperature values or flags based on its internal sequencing logic. Output '4' of the sequencer is `tabst_w`, and output '5' is another temperature value.

2.  **Primary Fuel Temperature Derivation Paths:**
    *   **Path A (`fabstfbsk`):** The `tabst_w` signal (from sequencer output 4) and `tqfll` are inputs to the `KFFAZBKS` block (a 2D lookup table). This block outputs `fabstfbsk`, which likely represents a calibrated or filtered fuel temperature, possibly related to ambient conditions or a base value.
    *   **Path B (`tkadifbks`):** Another output from the `sequencer` (output 5), `tqfld`, and `tmotbk` are fed into the `KFFADIFBKS` block (another 2D lookup table). This block outputs `tkadifbks`, likely a calibrated adiabatic temperature, or a temperature value derived considering motor temperature.

3.  **Conditional Fuel Temperature Selection (`fazbksy_w`):**
    *   The two derived temperatures, `fabstfbsk` and `tkadifbks`, are inputs to a multiplexer-like block `x` (`V.7.3`). This multiplexer selects one of these two values as its output, `fazbksy_w`, based on a control signal from an `AND` gate (detailed in step 5).

4.  **Temperature Difference Calculation:**
    *   The selected fuel temperature `fazbksy_w` is subtracted from the input `tmodtbks` (a modified or reference temperature). This calculation provides a temperature difference or deviation.

5.  **Status and Control Flags Generation:**
    *   **Modified Temperature Condition (`tmodbksC`):** Three `GET BIT` blocks extract specific bits (bit 0 from `CWTMODBKS3`, bit 2 from `B_tospgpl`, bit 6 from `CWTMODBKS`). The outputs of these `GET BIT` blocks are combined using an `OR` gate. The `OR` gate's output, along with a constant `1`, feeds into a `Check ~= 0` block. This block likely asserts `tmodbksC` (e.g., sets it to true/1) if the `OR` condition is true, indicating a modified temperature condition.
    *   **Multiplexer Control & Hot Start Condition:** Bit 7 from `TGRESBKS` (Temperature Resilience Status) is extracted. This bit, along with bit 1 extracted from `CWTMODBKS2` and the `Fregabe Heissstartcheck` (Enable Hot Start Check) flag, are inputs to an `AND` gate. The output of this `AND` gate serves as the control signal for the multiplexer `x` (determining `fazbksy_w` selection) and also as a control input for the final validation step.

6.  **Final Temperature Validation/Status (`tstbks`):**
    *   The output of the temperature difference calculation (from step 4) and the output of the `AND` gate (from step 5, representing the hot start condition and other flags) feed into a final `Check ~= 0` block. This block processes these inputs to generate `tstbks`. This output likely represents a final validated fuel temperature, or a status indicating the temperature's validity or relevance under hot start and resilience conditions.

7.  **Pass-Through Outputs:**
    *   The inputs `tmotbkabs` and `tksvhdpabs` are directly routed to the outputs `tflsoll_w`, `volfuel_w`, and `tfl_w`. This suggests these signals are passed through this subsystem, potentially for grouping or for use by other modules that interface with this fuel temperature system.


--- Page 52 ---

This page clearly contains a Simulink diagram.

## Function
This Simulink diagram, named `CLC_TFUELMX` (likely "Closed Loop Control Fuel Maximum Temperature"), serves to calculate and output a robust, application-level maximum fuel temperature (`tfuelmx`). It processes multiple raw fuel temperature inputs, applies conditional logic based on system status and configuration bits, and performs filtering/validation to ensure a reliable output for use in other automotive control systems. The overarching context is "FUSL, Fuel temperature (Appl. Inc.)", indicating its role in the fuel system's temperature management at an application level.

## Inputs
1.  **`tflvrhdp`**: (Input port 1) Represents a raw fuel temperature measurement or estimation, potentially from a fuel tank or return line.
2.  **`tflvmpi`**: (Input port 2) Represents another raw fuel temperature measurement or estimation, potentially related to the fuel pump or engine-side fuel delivery.
3.  **`SY_MPI`**: A system status signal, likely indicating the operational state of the Multi-Point Injection (MPI) system. Used as a condition for bit extraction.
4.  **`CWTMODBKS2`**: A control word or flag register, from which a specific bit (bit 4, as indicated by `num_dec`) is extracted to influence the fuel temperature selection logic.

## Outputs
1.  **`tfuelmx`**: (Output port 1) The calculated maximum fuel temperature, after processing and validation, intended for application-level use.

## Logic Flow

The logical flow can be broken down into the following steps:

1.  **Initial Fuel Temperature Comparison and Pre-processing:**
    *   The two primary raw fuel temperature inputs, `tflvrhdp` and `tflvmpi`, are fed into a `max` block. This block outputs the higher of the two values, providing a preliminary maximum fuel temperature.
    *   The output of the `max` block then passes through a "Check ~= 0" block (version V.6.6). This block likely performs a sanity check, filtering, or a specific transfer function operation. Its graphical representation suggests it might be a lookup table or a specialized filter, possibly ensuring the value is non-negative or within a valid range.

2.  **Control Mode Determination via Bit Extraction:**
    *   The `SY_MPI` input is compared with a constant `0` (likely `SY_MPI > 0`). The result of this comparison acts as a control input (`bit_sel`) to a "GET BIT" block.
    *   A constant `4` is fed into the `num_dec` input of the "GET BIT" block. This indicates that bit number 4 will be extracted from the `CWTMODBKS2` input.
    *   The "GET BIT" block extracts the specified bit (bit 4) from the `CWTMODBKS2` control word, but this operation is likely conditional on `SY_MPI > 0` (as suggested by `bit_sel`). The output of this block, labeled `bits`, is a boolean (0 or 1) signal.

3.  **Conditional Fuel Temperature Selection (Switch Logic):**
    *   A `Switch` block (represented by the triangular block with "f()" and `[tflvrhdp]` output label) is used to select between two possible fuel temperature sources.
    *   The `bits` signal (output from the "GET BIT" block) acts as the control input for this `Switch`.
    *   If `bits` is true (e.g., 1), the `Switch` selects the `tflvrhdp` input (the upper input to the switch). This means the raw `tflvrhdp` is chosen directly.
    *   If `bits` is false (e.g., 0), the `Switch` selects the pre-processed maximum temperature (the output from the "Check ~= 0" block, which itself came from the `max` of `tflvrhdp` and `tflvmpi`). This implies a different strategy is active when `bits` is false.

4.  **Final Filtering and Output:**
    *   The selected fuel temperature from the `Switch` block is then fed into a second "Check ~= 0" block (V.6.6). This block performs a final filtering, scaling, or validation step on the chosen fuel temperature. This could be to smooth the signal, apply a final calibration, or ensure it adheres to specific physical constraints before being output.
    *   The output of this final processing block is the system's primary output, `tfuelmx`, which represents the determined maximum fuel temperature.


--- Page 53 ---

This image is a Simulink diagram.

## Function
This Simulink diagram, titled "43.4.6.9 POSTDRIVE" and related to "FUSL, Fuel temperature," appears to be a subsystem responsible for processing various temperature inputs and a refueling status signal, likely in a post-drive or specific operating condition of an automotive fuel system. Its primary function is to transform raw temperature measurements into "absolute" or conditioned values, and to process a refueling status, potentially based on a vehicle mode or brake status. The "abs" suffix on the temperature outputs suggests conversion to a standardized or absolute scale, or perhaps a filtered/stabilized value.

## Inputs
1.  **B_tmodbksc (Input 1, green oval):** A boolean or status signal, possibly indicating a brake mode, vehicle mode, or a module status. It acts as a condition for processing other signals.
2.  **tflvrhdp (Input 2, green oval):** A temperature signal, likely related to fuel system components (e.g., fuel line, high-pressure pump).
3.  **tmotbks (Input 3, green oval):** A temperature signal, possibly related to motor/engine block temperature or a specific motor within the fuel system.
4.  **ttankbks (Input 4, green oval):** A temperature signal, likely from the fuel tank.
5.  **tflvmpi (Input 5, green oval):** A temperature signal, potentially related to fuel volume, metering, or pressure.
6.  **B_getankt (Input to V.6.4, square block 0):** A boolean or status signal indicating whether the vehicle has been refueled ("tanked").

## Outputs
1.  **B_getankt (Output 1, blue oval):** The processed refueling status.
2.  **tksvhdpabs (Output 2, blue oval):** The "absolute" or conditioned temperature related to the high-pressure fuel system or a specific component.
3.  **tmotbksabs (Output 3, blue oval):** The "absolute" or conditioned motor/engine temperature.
4.  **ttankabs (Output 4, blue oval):** The "absolute" or conditioned fuel tank temperature.
5.  **tksvmpiabs (Output 5, blue oval):** The "absolute" or conditioned temperature related to fuel volume/metering/pressure.

## Logic Flow
1.  **Conditional Control (`B_tmodbksc` pathway):**
    *   The input signal `B_tmodbksc` feeds into a block labeled `cond_if` (version V.6.0). This block evaluates `B_tmodbksc` to produce a conditional output, labeled "if".
    *   This "if" output then enters a multiplexer-like or custom distribution block labeled `V.6.1` (with ports 1, 2, 3, 4). This block generates four separate control signals (from its four output ports).
    *   Each of these four control signals is routed to the small triangular control input port of the individual `V.6.1` blocks that process the temperature signals. This implies that the processing of the temperature signals is dynamically controlled or enabled/disabled based on the `B_tmodbksc` condition.

2.  **Temperature Signal Processing:**
    *   Each of the four raw temperature inputs (`tflvrhdp`, `tmotbks`, `ttankbks`, `tflvmpi`) is fed into a dedicated processing block, all labeled `V.6.1`.
    *   These `V.6.1` blocks (likely custom functions or subsystems) perform specific operations (e.g., scaling, filtering, conversion) on their respective temperature inputs.
    *   Crucially, the operation of each `V.6.1` temperature processing block is influenced by the corresponding control signal received from the central `V.6.1` distributor (which originated from `cond_if`).
    *   The processed outputs are `tksvhdpabs`, `tmotbksabs`, `ttankabs`, and `tksvmpiabs`, indicating conditioned or "absolute" temperature values.

3.  **Refueling Status Processing (`B_getankt` pathway):**
    *   The input `B_getankt` (indicating refueling status) first passes through a block labeled `V.6.4`. This block likely performs an initial transformation or check on the refueling status.
    *   The output of `V.6.4` then feeds into a generic function block `f()`. This `f()` block represents a further, undefined functional transformation on the refueling status.
    *   The final output of the `f()` block is the processed `B_getankt` signal.

In essence, the diagram shows a control flow where a system status (`B_tmodbksc`) conditionally influences how various temperature sensors are processed, while a separate path handles the refueling status.


--- Page 60 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram describes an initialization routine (`FUSL_M408B/INI`) for various system variables, particularly those related to fuel temperature and internal states of low-pass filters. This initialization occurs at specific system events such as `IGK_ON` (ignition on) or `RST` (reset). The purpose is to set default or initial values for operating condition variables (BKS variables) and to prime low-pass filters with current, relevant temperature values.

## Inputs
The primary inputs to this initialization subsystem, provided via the main `In` block, are:
*   `<tumg>`: Ambient temperature (likely `Temperatur UmGebung`).
*   `<tmot>`: Engine temperature (likely `Temperatur Motor`).
*   `<tans>`: Intake temperature (likely `Temperatur Ansaugluft`).
*   `<ttankabs>`: Absolute tank temperature (likely `Temperatur Tank Absolut`).
*   `SY_MPI`: A system-specific input, possibly a boolean flag or a system mode indicator, used in a conditional calculation.
*   Other implicit inputs are the constant value `0` used for resetting various flags.

## Outputs
The outputs of this initialization subsystem, grouped into the main `Out` block, are:
*   `B_getankt`: Flag indicating if the vehicle was refueled (initialized to 0).
*   `B_tfstausw`: Fuel status flag (initialized to 0).
*   `B_tmbkser`: Temperature operating condition set flag (initialized to 0).
*   `tktm`: Tank temperature measurement (initialized to 0).
*   `B_tmodini`: Temperature mode initialization flag (initialized to 0).
*   `B_stendre`: End of start flag (initialized to 0).
*   `B_tmodbksc`: Temperature operating condition set for specific mode C (initialized to 0).
*   `B_stend_kl15`: End of start for terminal 15 (ignition) (initialized to 0).
*   `tumgtbks`: Initialized ambient temperature operating condition variable.
*   `tflvrhdp`: Initialized fuel vapor pressure relevant temperature (appears to be set to `tmot`).
*   `tfuelmx`: Initialized fuel mix temperature (appears to be set to `tmot`).
*   `tflvrhdp_flt_ini`: Initialization value for the internal state of the fuel vapor pressure filter (set to `tmot`).
*   `tflvmpi_flt_ini`: Initialization value for the internal state of the fuel metering pump input filter (set to `tflvmpi`).
*   `tflvmpi`: Calculated fuel metering pump input temperature.
*   `ttankbks`: Initialized tank temperature operating condition variable.
*   `tmotbks`: Initialized engine temperature operating condition variable.

## Logic Flow

1.  **Constant Initialization of Flags:**
    *   Several constant blocks, each outputting `0` (labeled `V.6.4`), are directly fed into the final `Out` multiplexer. This immediately sets variables such as `B_getankt`, `B_tfstausw`, `B_tmbkser`, `tktm`, `B_tmodini`, `B_stendre`, `B_tmodbksc`, and `B_stend_kl15` to `0`. This effectively resets these boolean or integer flags/variables to a default inactive or zero state upon initialization.

2.  **Direct Temperature Variable Initialization:**
    *   The input signal `<tumg>` (ambient temperature) is directly passed through to the output `tumgtbks`.
    *   The input signal `<tmot>` (engine temperature) is directly passed through to the output `tmotbks`, `tflvrhdp`, and `tfuelmx`.
    *   The input signal `<ttankabs>` (absolute tank temperature) is passed through a Gain block (value `1`, labeled `V.6.1`) and then output as `ttankbks`.
    *   These steps ensure that key temperature-related operating condition variables are initialized with their current sensor values.

3.  **Conditional Fuel Temperature Calculation (`tflvmpi`):**
    *   A set of input signals, including a constant `0` (`V.6.4`), `SY_MPI` (`V.6.4`), and another unlabeled `V.6.4` signal, are fed into a comparison block (`>` labeled `V.6.2`). The result of this comparison, along with outputs from other blocks (`V.6.1`, `V.6.2`), determines the logic within a `cond_if` block (`V.6.0`). This `cond_if` block likely implements a conditional branching logic based on these inputs.
    *   The output of the `cond_if` block (labeled 'if'), along with the input temperatures `<tmot>` (engine temperature) and `<tans>` (intake temperature), are fed into a custom function block `Calc_of_tflvmpi` (labeled `X.1.1`).
    *   This function calculates the `tflvmpi` (fuel metering pump input temperature) based on the provided engine, intake, and conditional inputs. The calculated `tflvmpi` is then routed to an output port.

4.  **Low-Pass Filter State Initialization:**
    *   The `tflvrhdp_flt_ini` output, which represents the initial state for a fuel vapor pressure filter, is directly set to the input engine temperature `<tmot>`.
    *   The `tflvmpi_flt_ini` output, representing the initial state for the fuel metering pump input filter, is directly set to the *calculated* `tflvmpi`.
    *   This step aligns with the descriptive text, ensuring that filter internal states are initialized with appropriate current values to prevent transients upon startup.

5.  **Output Aggregation:**
    *   All the initialized constant flags, directly passed-through temperatures, calculated `tflvmpi`, and the derived filter initialization states are then collected and output by the main `Out` block.


--- Page 61 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink diagram, named "Calc_of_tflvmpi", is to calculate a derived fuel temperature value, likely a compensated or normalized fuel temperature, denoted as `tflvmpi`. It uses engine temperature, ambient temperature, and a constant offset in its calculation, incorporating a non-linear function.

## Inputs
*   **tmot (1):** Represents an input signal, likely engine temperature (motor temperature).
*   **tans (2):** Represents an input signal, likely ambient temperature (outside air temperature).
*   **2.0 (V.6.4):** A constant value used in the calculation.

## Outputs
*   **tflvmpi (1):** The calculated fuel temperature-related value, which is the primary output of this subsystem.

## Logic Flow

The logical flow calculates `tflvmpi` through a series of arithmetic operations and a function block:

1.  **Summation of Temperatures:** The input signals `tmot` and `tans` are added together.
    `Sum1 = tmot + tans`
    (This is performed by the first summation block, labeled V.7.2).

2.  **Function Application:** The result of `Sum1` is fed into a function block `f()`. This block applies an unspecified function (e.g., a lookup table, interpolation, or a custom mathematical function) to its input.
    `FuncOutput = f(Sum1)`

3.  **Subtraction with Constant:** The output of the `f()` block (`FuncOutput`) is then subjected to a subtraction with the constant value `2.0`. The diagram clearly indicates that `2.0` is subtracted.
    `Sum2 = FuncOutput - 2.0`
    (This is performed by the second summation block, labeled V.7.2, with a '-' sign on the input from '2.0').

4.  **Division:** The result of `Sum2` is divided by `Sum1` (the initial sum of `tmot` and `tans`). Note that `Sum1` is reused for the denominator.
    `tflvmpi = Sum2 / Sum1`
    (This is performed by the division block, labeled V.7.2).

5.  **Output:** The final result of the division is the output `tflvmpi`.

In summary, the output `tflvmpi` is calculated as:
`tflvmpi = (f(tmot + tans) - 2.0) / (tmot + tans)`


--- Page 62 ---

This image contains a Simulink diagram.

## Function

The primary function of this Simulink subsystem, named `NVMY_INI` (Non-Volatile Memory Initialization), is to initialize or retrieve specific absolute fuel system-related temperature/pressure parameters from Non-Volatile Memory (NVM). These parameters, which persist across power cycles, are then bundled together and output for further processing within the automotive control unit (ECU), likely as part of the system's initialization sequence. The context "FUSL, Fuel temperature (Appl. Inc.)" indicates its role in fuel temperature management.

## Inputs

There are no explicit input ports shown directly feeding into the `NVMY_INI` subsystem from upstream Simulink blocks in this diagram. The "inputs" for the `NVMY[read/init]` blocks are implicit:
*   **Non-Volatile Memory (NVM) storage:** Each `NVMY[read/init]` block implicitly reads from a designated location in the NVM.
*   **Initialization values:** Default initialization values are specified for each NVM variable (e.g., `init:0` or `init:tksvmpiabs`) to be used if the value cannot be read from NVM or is invalid.

## Outputs

The subsystem has one main output port, labeled "1 Out", which carries a bus containing the following five scalar signals, read or initialized from NVM:

1.  **`tksvhdpabs`**: Likely an absolute pressure or density value (e.g., fuel vapor head pressure, absolute).
2.  **`tmotbksabs`**: Absolute motor block temperature.
3.  **`ttankabs`**: Absolute fuel tank temperature.
4.  **`tfstvz`**: Fuel temperature sensor value.
5.  **`tksvmpiabs`**: Another absolute pressure, temperature, or density value (e.g., vapor manifold pressure, absolute).

## Logic Flow

1.  **NVM Parameter Retrieval/Initialization:** Five independent `NVMY[read/init]` blocks are invoked. Each block is a specialized function or component designed to:
    *   Attempt to read a specific persistent parameter (e.g., `tksvhdpabs`, `tmotbksabs`, etc.) from the Non-Volatile Memory.
    *   If the read operation is successful and the value is valid, that value is used.
    *   If the read operation fails (e.g., the NVM location is empty, corrupted, or the system is initializing for the first time), the parameter is initialized to a predefined default value (e.g., `0` for `tksvhdpabs`, `tmotbksabs`, `ttankabs`, `tfstvz`; and `tksvmpiabs` using its own specified default).
    *   Each parameter is indicated to be a scalar (`size: 1`) and uses version `V.6.5` of the NVM implementation or definition.

2.  **Signal Bundling:** The five individual scalar output signals from the `NVMY[read/init]` blocks are connected to a vertical thick line. In Simulink, this typically represents a Bus Creator or a virtual bus, which combines these distinct signals into a single, structured compound signal.

3.  **Intermediate Processing/Forwarding:** The bundled signal (bus) is then routed as an input to a block identified as a triangular shape with "V.6.1". This block generally represents a subsystem, a function-call subsystem, or an embedded function. It receives all the initialized NVM values. While its internal logic is not shown, it suggests that these NVM values are either directly forwarded, processed further, or used as inputs for subsequent calculations within this block.

4.  **Subsystem Output:** The output from the "V.6.1" block is connected to the "1 Out" port, which defines the final output of the `NVMY_INI` subsystem. This means the NVM-read/initialized and potentially processed values are made available to the parent model or other connected subsystems. The presence of `f()` in the top right corner suggests that this entire diagram constitutes a function.


--- Page 63 ---

This image contains a Simulink diagram.

## Function
This Simulink diagram, titled "43.5.3 NVMY_RES" and belonging to the "FUSL, Fuel temperature (Appl. Inc.)" application, is primarily responsible for reading and initializing several temperature-related variables from Non-Volatile Memory (NVM). These NVM-persisted values are then aggregated and passed to a downstream subsystem for further processing, likely as part of a fuel temperature management or control system within an automotive application. The module ensures that critical temperature states or parameters are restored upon system startup or reset.

## Inputs
The inputs to this module are conceptual, originating from the Non-Volatile Memory (NVM) system via dedicated "NVMY[read/init]" blocks. These blocks retrieve or initialize the following scalar values:

1.  **`tksvhdpabs`**: A temperature-related absolute value from NVM.
2.  **`tmotbksabs`**: An engine or motor temperature-related absolute value from NVM.
3.  **`ttankabs`**: A fuel tank temperature-related absolute value from NVM.
4.  **`tfstvz`**: Another fuel system or temperature-related absolute value from NVM.
5.  **`tksvmpiabs`**: A further temperature-related absolute value from NVM.

Each NVM block specifies `size: 1` (scalar) and `init:<variable_name> V.6.5`, indicating NVM module version 6.5 for initialization.

## Outputs
The diagram has one explicit output:

1.  **Unnamed Output**: The output of the "V.6.1" subsystem, which is the result of processing the aggregated NVM-read temperature values. The specific name of this output signal is not labeled on the "Out" block itself in this view.

## Logic Flow

The logical flow of the diagram proceeds as follows:

1.  **NVM Data Reading/Initialization**: Five "NVMY[read/init]" blocks are independently called. Each block attempts to read a specific temperature-related variable (e.g., `tksvhdpabs`, `tmotbksabs`, `ttankabs`, `tfstvz`, `tksvmpiabs`) from Non-Volatile Memory. If the value is not present or invalid, it is initialized according to its definition (V.6.5 implies a specific initialization mechanism).
2.  **Intermediate Signal Processing**: The `ttankabs` signal, after being read from NVM, follows two paths:
    *   One path feeds directly into the main signal aggregation point.
    *   The other path passes through a "Gain" block with a gain of "1", and its output is labeled `ttankbks`. This `ttankbks` signal also feeds into the main signal aggregation point. A gain of 1 means the value is passed through unchanged, suggesting `ttankbks` might be a contextual rename or an indication of some trivial processing for `ttankabs`.
3.  **Data Aggregation (Bus Creation)**: All the retrieved and potentially processed signals (`tksvhdpabs`, `tmotbksabs`, `ttankbks`, `ttankabs`, `tfstvz`, `tksvmpiabs`) are fed into a thick vertical line. This element typically represents a Bus Creator or a similar signal aggregation mechanism in Simulink, bundling these individual scalar signals into a single composite signal or bus.
4.  **Subsystem Processing**: The aggregated signal (bus) is then provided as input to a subsystem or function call block labeled "V.6.1". This block encapsulates the primary logic for processing these collected temperature values. The internal details of "V.6.1" are not visible in this diagram.
5.  **Final Output**: The result generated by the "V.6.1" subsystem is then directed to an "Out" block, which represents the final output of this `NVMY_RES` module. This output likely represents a consolidated fuel temperature or related status derived from the NVM data.


--- Page 64 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink diagram, named `NVMY_STO`, is to store several absolute temperature values into Non-Volatile Memory (NVM). It acts as an interface to persist specific critical data points in the automotive system, likely for diagnostic purposes, operational history, or recovery after power cycles.

## Inputs
The system takes a single top-level input, labeled "In" (port 1). This input is implicitly a bus or structure containing multiple scalar absolute temperature values. The individual signals extracted from this input bus and processed are:

*   `<tksvhdpabs>` (temperature for the hot vehicle detection, absolute value)
*   `<tmotbksabs>` (temperature for motor block, absolute value)
*   `<ttankabs>` (temperature for the fuel tank, absolute value)
*   `<tfstvz>` (temperature for fuel supply, related to valve/pump, absolute value)
*   `<tksvmpiabs>` (temperature for throttle valve / intake manifold, absolute value)

Each of these variables is described as having `size: 1` (scalar) and `init:0` (initial value of 0), running on `V.6.5` (likely a specific version or software component designation).

## Outputs
The diagram shows outputs from each `NVMY[store]` block, which then connect to what appear to be custom "processing" or "continuation" blocks (represented by the block with three horizontal lines). The direct outputs of the NVM storage operation are effectively the values that have just been stored, which are then made available for downstream processing. The system does not have explicit top-level output ports in this particular view; rather, the outputs of the storage operations are passed internally to other parts of the larger `FUSL_M408B` subsystem.

## Logic Flow
The logical flow of the `NVMY_STO` subsystem is as follows:

1.  **Input Reception:** A single "In" port receives a composite signal. Given that it branches into multiple distinct signals, this input is understood to be a bus or structure containing the various absolute temperature values.
2.  **Signal Demultiplexing (Implicit):** The incoming composite signal is logically deconstructed or fanned out, allowing each individual absolute temperature value (`<tksvhdpabs>`, `<tmotbksabs>`, `<ttankabs>`, `<tfstvz>`, `<tksvmpiabs>`) to be accessed separately.
3.  **Non-Volatile Memory Storage:** Each individual absolute temperature value is fed into its dedicated `NVMY[store]` block.
    *   The `NVMY[store]` block represents a functional unit responsible for writing the received input value to a specified location in non-volatile memory.
    *   Below each `NVMY[store]` block, the specific variable name (e.g., `tksvhdpabs`) confirms which variable is being stored.
    *   The attributes `size: 1`, `init:0`, `V.6.5` define the characteristics of the data being stored (scalar, initial value, and version/component identifier).
4.  **Output to Downstream Processing:** After being stored in NVM, the "out" port of each `NVMY[store]` block provides the stored value. This value is then passed to subsequent, unspecified processing blocks (represented by the symbol with three horizontal lines). This indicates that the stored data is then available for further use or evaluation within the broader system.
5.  **Subsystem Context:** The `f()` block at the top right suggests that this `NVMY_STO` subsystem is part of a larger function or computation block within the `FUSL_M408B` model.


--- Page 65 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, labeled "TFST_20MS" (likely "Fuel Temperature Status / 20 Milliseconds") and associated with "FUSL, Fuel temperature (Appl. Inc.)", appears to be responsible for processing fuel temperature sensor data, detecting refueling events, and managing various status flags related to the fuel temperature system. Its primary function is to provide a robust and filtered fuel temperature value, identify significant changes in fuel level/temperature (indicating refueling), and report the operational status of the fuel temperature sensor and its associated logic, executing at a 20ms rate.

## Inputs

*   **`CWTMODBKS`**: A digital word representing various system modes or statuses.
*   **`bit_sel_0`**: A signal used to select a specific bit from `CWTMODBKS`.
*   **`<B_tfstok>`**: Boolean flag, indicating if the fuel temperature sensor is operational/OK.
*   **`<B_tfstcanok>`**: Boolean flag, indicating if CAN communication for the fuel temperature sensor is operational/OK.
*   **`<B_kl15>`**: Boolean flag, indicating the status of ignition terminal 15 (ignition ON/OFF).
*   **`TWA_TFST`**: Threshold value for fuel temperature deviation.
*   **`TFST_UM_DIFF`**: Upper limit for fuel temperature difference for change detection.
*   **`TFST_LM_DIFF`**: Lower limit for fuel temperature difference for change detection.
*   **`TFST_UM_DIFF_OLD`**: Previous upper limit for fuel temperature difference.
*   **`TFST_LM_DIFF_OLD`**: Previous lower limit for fuel temperature difference.
*   **`T_TFST_FAD`**: Timer value for fuel temperature fault accumulation duration.
*   **`T_TFST_RAF`**: Timer value for fuel temperature fault recovery accumulation duration.
*   **`TFST_INIT`**: Boolean flag, indicating if the fuel temperature system is in an initialization state.
*   **`TFST_SEN_VAL`**: Raw, unfiltered fuel temperature sensor value.
*   **`TFST_FILT_OLD`**: Previous filtered fuel temperature value (feedback for filtering).
*   **`<feedback>`**: An internal feedback signal from a memory or delay block, likely related to filtered values.

## Outputs

*   **`B_tfstausw`**: Boolean status flag, indicating the evaluated/selected state of the fuel temperature system (e.g., active, valid).
*   **`tfstvz`**: An intermediate, possibly "pre-filtered" or initial, fuel temperature value.
*   **`<tfst>`**: The final processed and filtered fuel temperature value.
*   **`B_getankt`**: Boolean flag, indicating if a refueling event has been detected ("Tankvorgang erkannt").

## Logic Flow

The logical flow can be broadly categorized into several sub-functions:

1.  **Input Conditioning and Status Derivation (Top-Left):**
    *   The `CWTMODBKS` input is processed by `bit_sel_0` to extract specific `bits` (likely from a larger status word).
    *   These `bits` are then combined with `B_tfstok`, `B_tfstcanok`, and the inverted `B_kl15` (ignition OFF) using `AND` gates. This forms conditions (`cond_if`) that enable or disable downstream logic based on sensor health, communication status, and ignition state.
    *   A block with a 'T' (likely a timer or edge detector) and an `FF` (RS Flip-Flop) are used in conjunction with `num_dec` (a decoded value from `CWTMODBKS`) and `TWA_TFST`. This logic likely manages a timed state or a debounced status related to fuel temperature conditions.

2.  **Fuel Temperature Change Detection (Middle-Left):**
    *   The current filtered fuel temperature (`TFST_FILT`) is compared against the previous filtered temperature (`TFST_FILT_OLD`) to calculate a difference.
    *   This difference is then compared using `>` and `<` blocks against various thresholds: `TFST_UM_DIFF`, `TFST_LM_DIFF`, `TFST_UM_DIFF_OLD`, and `TFST_LM_DIFF_OLD`. These comparisons check for both positive and negative significant changes in fuel temperature.
    *   The outputs of these comparisons are combined using an `OR` gate. This `OR` gate output indicates if any of the defined significant temperature change conditions are met.

3.  **Refueling Event Detection ("Tankvorgang erkannt") (Middle-Right):**
    *   The output from the fuel temperature change detection (`OR` gate) is combined with another signal (from a `cond_if` block) via another `OR` gate.
    *   The result is fed into a comparator (labelled `>`) whose exact comparison value is not fully visible but is likely a fixed threshold or a boolean condition.
    *   The output of this comparator directly sets the `B_getankt` flag, indicating that a refueling event has been recognized. This `B_getankt` flag is also fed back into the system, possibly to influence other states or to ensure consistent detection.

4.  **Fuel Temperature Filtering and Initialization (Right-Middle):**
    *   An `IF` block uses `TFST_INIT` (initialization flag) to select between the raw sensor value (`TFST_SEN_VAL`) and the previous filtered value (`TFST_FILT_OLD`). When initializing, it might directly use the raw value or a default, otherwise it might feed the previous filtered value for continuous filtering. This output forms `tfstvz`.
    *   The `tfstvz` signal is then fed into a `TFSTOET` block along with `<feedback>`. The `TFSTOET` block likely performs the core fuel temperature filtering or processing, potentially including offset and evaluation, to produce the final filtered fuel temperature output `<tfst>`.

5.  **Output Status Management (Right-Top):**
    *   Multiple `IF` blocks, influenced by `cond_if` signals, `TFST_INIT`, and the output of the `FF` block, determine various timing or status signals (`T_TFST_FAD`, `T_TFST_RAF` related outputs).
    *   Another `IF` block, combining `TFST_INIT` and the `FF` output, determines the `B_tfstausw` status, which is a key output indicating the overall validity or selected status of the fuel temperature system.


--- Page 66 ---

This image contains a Simulink diagram.

## Function
The primary function of this Simulink diagram, labeled "OPM_100MS" and associated with "FUSL, Fuel temperature (Appl. Inc.)", is to **estimate or calculate the fuel temperature (tfuelmx)** within an automotive system. It does so by processing various sensor inputs, vehicle operating conditions, and fuel system parameters through a series of interconnected functional blocks, performing filtering, and deriving specific temperature values relevant to different parts of the fuel system.

## Inputs
The system takes a wide range of inputs, which can be categorized as follows:

*   **Vehicle & Engine Status:**
    *   `B_sshev`: Engine start/stop status.
    *   `B_stendz`, `B_stend`: Engine standstill/operating status.
    *   `B_kl15_dly`: Delayed ignition status (terminal 15).
    *   `B_getankt`: Refueling detection flag.
    *   `vfzg_w`: Vehicle speed.
*   **Ambient & Component Temperatures:**
    *   `tumg`: Ambient temperature.
    *   `B_tmmn`: Minimum temperature (e.g., ambient or fuel).
    *   `tosp`: Oil sump temperature.
    *   `tmol`: Engine oil temperature.
    *   `kfllafin_w`: Fuel flap related temperature.
*   **Fuel System & Flow Parameters:**
    *   `dmkrhdev_w`, `dmkrmpl_w`, `dmkrmpi_w`: Various mass flow rates (e.g., air, fuel).
    *   `lepwmfan`: PWM signal for a fan (e.g., fuel cooler fan).
    *   `tdiffmp`, `tdiffbks_w`: Temperature differentials (e.g., for MPI or BKS systems).
    *   `RadBl_rActr_VW_SC`, `RadBl_vCmptmt_VW_SC`, `RadBl_vCmptmt_VW`: Fuel rail actual volume, fuel volume in compartment, etc.
*   **Control & Sensor Signals:**
    *   `B_tumnpl`, `B_tabstv`: Control or status bits.
    *   `tabst_w`: Tank absolute level sensor value.
    *   `tanhkm_w`: Tank heating control value.
    *   `tans`: Throttle angle sensor value.
    *   `tflvrhdp`: Fuel return line temperature (high pressure).
*   **Internal Feedback/Previous Values:**
    *   `feedback`, `B_tmodini_prev`, `tfuelmx` (used as feedback within MDLDITEMP block).

## Outputs
The key outputs of this module, primarily intended to be consumed by other systems, are a bundle of temperature values related to the fuel system:

*   **`tfuelmx`**: The calculated fuel mixture temperature. This is the main estimated fuel temperature.
*   **`tflvrhdp`**: Fuel return line temperature (high pressure).
*   **`tflvmpi`**: Fuel return line temperature (multi-point injection).

Additionally, the sub-systems within the diagram produce numerous intermediate outputs (e.g., `B_tmodbks`, `ttankbks`, `kfflafin_cor`, `tospggl`, `tfllfmpi`, `tfvuradtbks`) that are used internally by other blocks in the diagram or could potentially be exposed as outputs for other modules within a larger system.

## Logic Flow

The Simulink diagram executes a complex logical flow, often in parallel, to derive the final fuel temperature. The flow can be broken down into several stages:

1.  **Vehicle State and Ambient Condition Processing (TUMBKS - X.6.1):**
    *   This block initializes the process by taking various engine status flags (`B_sshev`, `B_stendz`, `B_stend`), ambient temperature (`tumg`), ignition status (`B_kl15_dly`), and other mode-related inputs (`B_tumnpl`, `B_tabstv`).
    *   It produces fundamental operational flags and filtered temperature values, such as `B_stend_kl15`, `B_stendre`, `B_tumgfilil`, and `tumgtbks`, which are crucial for subsequent calculations.

2.  **Fuel Tank Temperature Modeling (TTANKMOD - X.6.2):**
    *   This module models the fuel temperature within the tank. It considers inputs like refueling events (`B_getankt`), vehicle speed (`vfzg_w`), minimum temperature (`B_tmmn`), outputs from TUMBKS (`B_tumgfilil`, `tumgtbks`), tank level (`tabst_w`), and tank heating status (`tanhkm_w`).
    *   It calculates the tank temperature (`ttankbks`) and related parameters.

3.  **Oil Temperature Processing (TWOELB - X.6.3):**
    *   This block processes inputs related to oil temperature (`tosp`, `tmol`) and mass flow (`dmkrhdev_w`), along with engine state from TUMBKS (`tumgtbks`).
    *   It outputs an "oil module temperature" (`tmodbks`) and a filtered oil sump temperature (`tospggl`), which are used for heat transfer calculations impacting fuel temperature.

4.  **Fuel Flap Temperature Correction (SELECT_KFFLAFIN - X.6.7):**
    *   Based on the raw fuel flap temperature (`kfllafin_w`) and a mass flow signal (`dmkrmpl_w`), this block applies conditional logic (`cond_if`) to output a corrected fuel flap temperature (`kfflafin_cor`).

5.  **MPI and DI Specific Temperature Calculations (MDLMPITEMP - X.6.6 and MDLDITEMP - X.6.5):**
    *   These two blocks likely calculate temperatures specific to different fuel injection systems or regions.
    *   **MDLMPITEMP (X.6.6)** uses `tmodbks`, `tans`, `tdiffmp`, `tflvrhdp`, `dmkrmpi_w`, `tumgtbks` to determine MPI-related temperatures like `trohvmpi`, `tcompmpi`, `tfllfmpi`.
    *   **MDLDITEMP (X.6.5)** uses `tmodbks`, `vfzg_w`, `lepwmfan`, `ttankbks`, `kfflafin_cor`, `tdiffbks_w`, `B_stend`, various fuel volume parameters (`RadBl_rActr_VW_SC`, `RadBl_vCmptmt_VW_SC`, `RadBl_vCmptmt_VW`), `tumgtbks`, and notably, a feedback of `tfuelmx` to calculate DI-related temperatures like `trohvsdp`, `ffwkbks`, `tfvuradtbks`. This feedback loop suggests a dynamic model or state-space approach.

6.  **Centralized Temperature Filtering (TEMPFILTER - X.6.8):**
    *   This is a critical block that consolidates and filters a large number of temperature-related signals from various upstream blocks (`B_stend_kl15`, `B_sshev`, `B_stendz`, `B_stend`, `tumg`, `tmodbks`, `kfllafin_cor`, `dmkrmpi_w`, `tflvrhdp`, `tfllfmpi`, `tospggl`, etc.).
    *   It refines these signals and outputs filtered or derived temperatures (`tdiffbks_w`, `tflvrhdp`, `tflvmpi`, `tfllfmpi`, `tfllmpi`, `tkast`, `tkalubks`, `B_rztmbks`, etc.) that represent more stable or representative values for further use.

7.  **Post Drive Logic (POSTDRIVE - X.6.4):**
    *   This module likely handles updates or calculations specific to conditions after engine operation or during specific drive cycles. It takes inputs such as `B_tmodbks`, `B_getankt`, `iksvhdpabs`, `tflvrhdp`, `ttankbks`, `tflvmpi` and outputs updated versions of some of these signals or related flags.

8.  **Final Fuel Mixture Temperature Calculation (CLC_TFUELMX - X.6.9):**
    *   This is the final stage where the primary fuel temperature is calculated. It takes the filtered fuel return line temperatures (`tflvrhdp` and `tflvmpi`) from the `TEMPFILTER` block.
    *   It computes and outputs `tfuelmx`, the main estimated fuel mixture temperature.

9.  **Output Aggregation (V.5.7):**
    *   The final output port aggregates `tfuelmx` from CLC_TFUELMX, along with `tflvrhdp` and `tflvmpi` (which are also outputs from TEMPFILTER), into a single output bundle for consumption by other parts of the ECU software.

The overall logic demonstrates a systematic approach to fuel temperature estimation, considering multiple heat sources (engine, oil), operational states, fuel system dynamics (tank, injection systems), and applying filtering to produce robust and accurate temperature values.


--- Page 67 ---

This page contains two interconnected Simulink diagrams, which are sub-models within a larger automotive system, likely related to fuel temperature management.

## Function

The primary function of these Simulink diagrams is to estimate and manage the fuel tank temperature within an automotive context. This involves two main stages:

1.  **43.5.6.1 TUMGBKS**: This sub-model is responsible for conditioning and selecting an appropriate ambient or reference temperature (`tumgtbks`) based on various vehicle operating conditions and configuration bits. It also generates several boolean status flags related to system operation.
2.  **43.5.6.2 TTANKMOD**: This sub-model utilizes the conditioned ambient temperature (`tumgtbks`) from the first stage, along with measured absolute tank temperature and other vehicle-specific parameters (e.g., from lookup tables), to calculate the estimated fuel tank temperature (`teitaa`) through a thermal modeling approach. It also derives intermediate temperature values and flags.

Together, these models contribute to accurate fuel temperature monitoring and control, which is crucial for engine performance, emissions, and fuel system diagnostics.

## Inputs

The key inputs to these combined models are:

*   **`B_tumpl` (Boolean)**: Status signal, possibly related to a specific operational mode.
*   **`CWTMODBKS` (Bitfield/Integer)**: Configuration word for mode selection and bit extraction.
*   **`B_kli15_dly` (Boolean)**: Delayed KL15 (Ignition ON) signal.
*   **`CWTMODBKS2` (Bitfield/Integer)**: Another configuration word for bit extraction.
*   **`B_tabstv` (Boolean)**: Status related to an "Ausblendestufe" (fade-out stage).
*   **`B_stendz`, `B_sshev`, `B_stend` (Boolean)**: Various signals possibly indicating engine stop or standstill conditions.
*   **`B_tmodini_prev` (Boolean)**: Previous state of the `B_tmodini` initialization flag.
*   **`cond_if` (Boolean)**: Condition for an if-else block, likely for initialization.
*   **`B_getankt` (Boolean)**: Flag indicating whether fuel has been recently tanked.
*   **`ttankabs` (Real)**: Measured absolute fuel tank temperature.
*   **`tabst_w` (Real)**: An input value for the `KLFTTANKST` lookup table (e.g., ambient temperature).
*   **`vfzg_w` (Real)**: An input value for the `KLFTTANKST` lookup table (e.g., vehicle speed).
*   **`ZTABKS` (Real)**: A parameter for the thermal model 'T' block.
*   **`teitaar` (Real)**: A reference temperature value used in the thermal model.

## Outputs

The key outputs from these combined models are:

*   **`tumgtbks` (Real)**: Conditioned ambient/reference temperature, used for fuel tank temperature estimation.
*   **`B_stend_kl15` (Boolean)**: A derived status signal, likely related to engine standstill and ignition.
*   **`B_tmodini` (Boolean)**: An initialization or mode-control flag.
*   **`ttankbks` (Real)**: An intermediate temperature value, derived from `ttankabs` and `tumgtbks`.
*   **`dttankst` (Real)**: Delta tank temperature, potentially representing the difference or change in tank temperature.
*   **`teitaa` (Real)**: The estimated fuel tank temperature.
*   **`tktm` (Real)**: An intermediate temperature value, scaled from `teitaa`.

## Logic Flow

The logical flow can be described in two parts, corresponding to the two diagrams:

### 1. Logic Flow for 43.5.6.1 TUMGBKS (Figure 43.5.9)

This section focuses on selecting and conditioning an ambient temperature and determining several status flags.

1.  **Bit Extraction and Conditional Logic**:
    *   Specific bits (`bit_sel_0`, `num_dec`) are extracted from `CWTMODBKS` and `CWTMODBKS2` using "GET BIT" blocks (V.7.0), which are then used in subsequent logical operations.
    *   The `B_tumpl` signal is NOTed, and its output is used along with `CWTMODBKS` derived bits to feed into a block `TCTUMBKSS` (V.6.4), which also takes `tumgtbks` as feedback.
2.  **Engine Stop/Standstill Detection (`B_stendre` and `B_stend_kl15`)**:
    *   `B_stendz`, `B_sshev`, and `B_stend` signals are ORed together. The output is processed by a block `V.5.3` (likely a debouncer or timer for engine stop). The output `B_stendre` feeds into another OR gate.
    *   `B_stend_kl15` is an output of an OR gate, combining `B_tumgfili` and other internal logic results, suggesting a status related to vehicle standstill and ignition (KL15).
3.  **`tumgtbks` Determination**:
    *   Several boolean inputs (`B_tumgfili`, `B_tmmn`, `B_tmmn1`) are combined with a constant `0` through OR gates and "Check ~= 0" blocks (V.6.6), likely generating reset or control signals.
    *   An AND gate combines `B_kli15_dly` and `B_tabstv`. The output is processed by another "Check ~= 0" block.
    *   A block `ZTTUMGBKS` (V.6.4) and a `1000MS` timer (V.6.4) contribute to determining an intermediate `tumg` signal.
    *   The final `tumgtbks` value (an output from a V.7.2 block) is derived from `tumg` and other internal calculations.
4.  **`B_tmodini` Initialization Flag**:
    *   The `B_tmodini` output is determined by an "if" block (V.6.0). The condition for this block (`cond_if`) and a NOTed `B_tmodini_prev` (previous state) decide the current state of `B_tmodini`. This suggests a mechanism to initialize or reset the fuel temperature model.

### 2. Logic Flow for 43.5.6.2 TTANKMOD (Figure 43.5.10)

This section calculates the estimated fuel tank temperature `teitaa` and related values.

1.  **Tanking Event and Mode Logic (`B_tumgtanks`)**:
    *   A specific bit (`bit_sel_0`) is extracted from `CWTMODBKS` using a "GET BIT" block (V.7.0).
    *   `B_getankt` (fuel tanked) is NOTed.
    *   An AND gate combines `NOT B_getankt` and `bit_sel_0`.
    *   This result is ORed with `B_tumgfili`, `B_tmmn`, and `B_tmmn1` (all inputs from TUMGBKS) to produce `B_tumgtanks`. This signal likely controls the reset or initialization of the thermal model, especially after a tanking event.
2.  **`ttankbks` and `dttankst` Calculation**:
    *   The measured `ttankabs` (absolute tank temperature) and the calculated `tumgtbks` (conditioned ambient temperature from the previous model) are summed by a block (V.7.2).
    *   The output of this sum (`ttankbks`) and `dttankst` are then forwarded.
3.  **Lookup Tables for Thermal Parameters**:
    *   `KLFTTANKST` (V.7.3) is a 2D lookup table that takes `tabst_w` and `vfzg_w` as inputs and outputs `P_val`. This table likely determines a heat transfer coefficient or a time constant multiplier based on ambient conditions and vehicle speed.
    *   `KFTETK` (V.7.3) is another 2D lookup table, taking `x_val` (possibly `P_val` or another value) and `y_val` (labeled `tanhm_w`) to output a value that feeds into the thermal model's `u` input. This might represent an effective temperature or heat source/sink.
4.  **Thermal Model (`T` block, V.5.3)**:
    *   This is the core of the fuel tank temperature estimation. It appears to be a dynamic thermal model (e.g., a first-order lag or a more complex thermal transfer function).
    *   **Inputs to the 'T' block**:
        *   `R` (Reset/Enable): Derived from `B_tumgtanks` through a "Check ~= 0" block and a constant `0`. This likely resets the model's state when `B_tumgtanks` is active (e.g., after tanking or specific conditions).
        *   `IV` (Initial Value): Derived from a "Check ~= 0" block and a constant `0`, possibly setting an initial temperature.
        *   `dT` (Time Constant/Derivative Factor): Comes from a `1000MS` timer and `teitaar`.
        *   `u` (Input to the model): From the output of the `KFTETK` lookup table.
        *   `T` (Temperature/Parameter): From `ZTABKS`.
    *   The output `y` of this thermal model is the estimated fuel tank temperature (`teitaa`).
5.  **Final Outputs**:
    *   The `y` output from the thermal model is directly assigned to `teitaa`.
    *   `y` is also scaled by 1 (effectively passed through) to produce `tktm`.


--- Page 68 ---

This page contains Simulink diagrams. The primary diagram for analysis is "43.5.6.3 TWOELBKS" (Figure 43.5.11).

## Function

The primary function of this Simulink diagram (`TWOELBKS`) is to calculate and output a specific internal engine temperature value (`tmotbks`) for control systems. This calculation involves:
1.  **Conditional Selection:** Choosing between different temperature sources (`tosp`, `tmot`) based on a control bit (`CWTMODBKS.Bit6`).
2.  **Offset Adjustment:** Potentially adding an offset (`OTMOTBKS`) to the engine temperature (`tmot`) if an oil temperature sensor is unavailable or not operational (`CWTMODBKS.Bit0`).
3.  **Override/Fallback Logic:** Implementing an override logic (`B_tmotbks`) that dictates which of the conditionally selected or offset-adjusted temperatures is used as the final `tmotbks` output.

In essence, it intelligently processes various engine temperature inputs to provide a robust and context-aware temperature signal, considering sensor status and operating conditions.

## Inputs

*   **B_tospgpl** (Boolean): A control signal, likely related to the availability or validity of `tosp`.
*   **dmkrhdev_w** (Real): A deviation or difference value, possibly related to engine speed or load.
*   **DMKRTBKS** (Parameter): A threshold value for `dmkrhdev_w`.
*   **tumgtbks** (Real): Another temperature-related input or control signal.
*   **TUMGOBKS** (Parameter): A threshold value for `tumgtbks`.
*   **CWTMODBKS** (Control Word/Byte Parameter): A multi-bit parameter containing various control flags:
    *   **Bit 6**: Controls the MAX selection between `tosp` and `tmot`.
    *   **Bit 0**: Indicates the status of the oil temperature sensor (available/operational or not).
*   **tosp** (Real): Oil sump temperature (or similar engine temperature).
*   **tmot** (Real): Engine coolant temperature (motor temperature).
*   **OTMOTBKS** (Parameter): An offset value to be added to `tmot` under specific conditions.

## Outputs

*   **B_tmotbks** (Boolean): An intermediate boolean signal, indicating a specific condition related to temperature calculation, which then acts as a control for the final temperature selection.
*   **tmotbks** (Real): The final calculated engine temperature value used by other systems.

## Logic Flow

The logical flow can be broken down into three main sections leading to the final `tmotbks` output:

**1. Derivation of the control signal `B_tmotbks` (Top Left Section):**
    *   `dmkrhdev_w` is compared with `DMKRTBKS`. If `dmkrhdev_w < DMKRTBKS`, the result is TRUE.
    *   `tumgtbks` is compared with `TUMGOBKS`. If `tumgtbks < TUMGOBKS`, the result is TRUE.
    *   The output of the first comparison (`dmkrhdev_w < DMKRTBKS`) is inverted by a `NOT` gate.
    *   This inverted signal and `B_tospgpl` are logically combined using an `AND` gate (let's call its output `AND1_Out`).
    *   The output of the second comparison (`tumgtbks < TUMGOBKS`) and `B_tospgpl` are logically combined using another `AND` gate (let's call its output `AND2_Out`).
    *   Finally, `AND1_Out` and `AND2_Out` are combined using a third `AND` gate. The output of this gate is `B_tmotbks`. This `B_tmotbks` signal serves as a master selector for the final `tmotbks` value.

**2. Calculation of `TEMP_A` (Offset-adjusted `tmot`) (Middle-Right Section):**
    *   A 'GET BIT' block extracts Bit 0 from `CWTMODBKS`. This bit acts as a control for an additive offset.
    *   `tmot` and `OTMOTBKS` are fed into a summing block, resulting in `tmot + OTMOTBKS`.
    *   A Switch block then selects between `tmot + OTMOTBKS` and `tmot` itself:
        *   If `CWTMODBKS.Bit0` is TRUE (or 1, indicating the oil temperature sensor is absent/not ready), the output is `tmot + OTMOTBKS`.
        *   If `CWTMODBKS.Bit0` is FALSE (or 0, indicating the sensor is present/ready), the output is `tmot`.
    *   The result of this switch is referred to as `TEMP_A`. This represents the engine temperature potentially adjusted by an offset.

**3. Calculation of `TEMP_B` (Conditionally selected `tosp`/`tmot`) (Middle-Left Section):**
    *   A 'GET BIT' block extracts Bit 6 from `CWTMODBKS`. This bit controls the selection logic.
    *   `tosp` and `tmot` are fed into a `MAX` block, which outputs the greater of the two values: `MAX(tosp, tmot)`.
    *   A Switch block then selects between `MAX(tosp, tmot)` and `tmot`:
        *   If `CWTMODBKS.Bit6` is TRUE (or 1), the output is `MAX(tosp, tmot)`. This enables the selection between `tmot` and `tosp`.
        *   If `CWTMODBKS.Bit6` is FALSE (or 0), the output is `tmot`.
    *   The result of this switch is referred to as `TEMP_B`. This represents the engine temperature selected based on a configuration bit.

**4. Final Determination of `tmotbks` (Far Right Section):**
    *   A final Switch block uses the `B_tmotbks` signal (from Section 1) as its control input.
    *   The top data input to this switch is `TEMP_A` (from Section 2).
    *   The middle data input to this switch is `TEMP_B` (from Section 3).
    *   The output of this final switch is `tmotbks`:
        *   If `B_tmotbks` is TRUE, then `tmotbks = TEMP_A` (the offset-adjusted `tmot`). This acts as an override or a fallback mode.
        *   If `B_tmotbks` is FALSE, then `tmotbks = TEMP_B` (the conditionally selected `tosp`/`tmot`). This is the default operational mode.


--- Page 69 ---

This page contains two Simulink diagrams, Figure 43.5.13 and Figure 43.5.14, which are components of an automotive thermal management system, specifically related to fuel and engine component temperature modeling as indicated by "FUSL, Fuel temperature" and "MDLMPITEMP". As an expert automotive systems engineer, I will analyze both diagrams collectively as they represent a logical unit within the specified path: "FUSL_M408B/OPM_100MS/MDLDITEMP".

## Function

The primary function of these Simulink diagrams is to **model and calculate various critical temperatures within an automotive powertrain, focusing on fuel temperature and Multi-Point Injection (MPI) system components.** This involves compensating for different operating conditions, cooling/heating circuit states, and fuel flow characteristics. The system dynamically determines:
*   **Fuel temperature variations and radiator return temperatures (Figure 43.5.13).**
*   **Compensated temperatures, temperature differences, and influence factors specific to the MPI fuel delivery system (Figure 43.5.14).**
The use of configuration words (`CWTMODBKSX`) suggests a highly modular and configurable system, enabling or disabling certain calculation paths based on vehicle variants or operational modes.

## Inputs

The system takes a wide array of inputs, categorized as follows:

*   **Engine/Coolant/Air Temperatures:**
    *   `tmotbks`: Engine coolant temperature (base temperature).
    *   `tans`: Ambient or intake air temperature.
    *   `tfuelmx`: Mixed fuel temperature.
    *   `tumgtbks`: Turbocharger/exhaust gas temperature or general engine thermal mass temperature.
    *   `ttankbks`: Fuel tank temperature.
    *   `tflvrhdp`: Fuel temperature at return line or high-pressure pump.
*   **Flows/Rates:**
    *   `ffwkbks`: Fuel mass flow rate.
    *   `dmkrmpi_w`: Mass flow rate through MPI components.
*   **Component States/Characteristics:**
    *   `RadBli_vCmpmtmt_VW_SC`: Radiator/compartment volume switch/control.
    *   `RadBli_vCmpmtmt_VW`: Radiator/compartment volume.
    *   `RadBli_rActr_VW_SC`: Radiator actuator ratio switch/control.
    *   `RadBli_rActr_VW`: Radiator actuator ratio.
    *   `lepwmfan`: Fan Pulse Width Modulation (PWM) or fan speed.
    *   `tflvrhdp_SC`: Fuel temperature switch/control.
*   **Control/Flags/Coefficients:**
    *   `vlfzg_w`: Vehicle longitudinal acceleration or speed factor.
    *   `kfflafinor`: Coefficient for fluid interaction (e.g., air-to-fluid heat transfer).
    *   `tdiffbk`: Base temperature difference.
    *   `B_stend`: Standstill condition flag.
*   **Configuration Words:**
    *   `CWTMODBKS1`, `CWTMODBKS2`, `CWTMODBKS3`: Configuration words containing bit flags that enable or disable specific features or calculation paths.

## Outputs

The system produces several modeled temperature values and related factors:

*   **From Figure 43.5.13 (Fuel Temperature / Radiator Return):**
    *   `tfvuraditbks`: Modeled fuel temperature variation or radiator inlet/outlet temperature.
    *   `trohvhdhp`: Return temperature of heating fluid (coolant) at the high-pressure side.
*   **From Figure 43.5.14 (MPI System Temperatures):**
    *   `tcompmp`: Compensated MPI temperature.
    *   `trohvmpi`: Robust MPI temperature.
    *   `tdiffmpi`: Temperature difference for the MPI system.
    *   `fkmpifl`: Fuel influence factor for the MPI system.

## Logic Flow

The logical flow involves parallel calculations, conditional logic, lookup tables for non-linear mappings, and filtering, all configured by bit flags.

**Overall System Architecture:**

1.  **Configuration Bit Extraction:** `CWTMODBKS1`, `CWTMODBKS2`, `CWTMODBKS3` (configuration words) are processed by `GET BIT` blocks to extract individual bits. These bits are crucial for enabling/disabling specific calculation branches, representing different control strategies or hardware configurations.
2.  **Conditional Execution:** Many paths are gated by `Check ~= 0` blocks, often controlled by the extracted configuration bits or by comparing input switch values (e.g., `RadBli_vCmpmtmt_VW_SC == -1`). This allows the system to adapt its behavior based on specific conditions or parameter settings.
3.  **Lookup Table Mappings:** Numerous 1D and 2D lookup tables (e.g., `KLPADBTBKS`, `KFCOMPMPI`, `KFVFTBKS`) are used to map multiple input variables (like engine temperature, air temperature, flow rates, component states) to non-linear compensation values, target temperatures, or scaling factors. These tables are essential for capturing complex physical relationships not easily described by linear equations.
4.  **Arithmetic Operations:** Standard arithmetic blocks (`+`, `-`, `X` for multiplication) combine and adjust the values derived from inputs and lookup tables.
5.  **Signal Merging:** `Merge` blocks are used to combine signals from different conditional branches, ensuring a continuous output signal regardless of which path was active.
6.  **Filtering/Rate Limiting:** Trapezoidal blocks (labeled V.6.1) are applied to various signals before producing outputs. These typically perform rate limiting, anti-windup, or filtering to ensure smooth and physically plausible transitions in the modeled temperatures.

**Detailed Flow (Figure 43.5.13 - Fuel Temperature / Radiator Return):**

1.  **Radiator Compensation Path:**
    *   Conditional selection of `RadBli_vCmpmtmt_VW` and `RadBli_rActr_VW` based on their respective `_SC` (switch/control) inputs.
    *   These selected values feed into `KLPADBTBKS` (2D lookup table) to determine a compensation value.
    *   This compensation value is then conditionally added or passed through based on configuration bits.
2.  **Fuel Flow / Fan / Tank Temperature Path:**
    *   `vlfzg_w` and `lepwmfan` map to a temperature component via `KFVFTBKS`.
    *   `kfflafinor` and `ttankbks` map to another component via `KFNKSSK`.
    *   `ffwkbks` multiplies with the `KFNKSSK` output.
    *   These components are then summed and conditionally processed with `tdiffbk`.
3.  **Temperature Offset and Direct Fuel Temperature Path:**
    *   `tmotbks` is used in `TOFSVHKSK` to get an offset, which is conditionally applied.
    *   `tfuelmx` and `tumgtbks` are summed and conditionally gated based on `CWTMODBKS2` bit.
    *   `B_stend` (standstill flag) also conditionally affects other sums.
4.  **Final Output Calculation:** All derived and compensated temperature components are summed. The resulting values are filtered by trapezoidal blocks (V.6.1) to produce `tfvuraditbks` and `trohvhdhp`.

**Detailed Flow (Figure 43.5.14 - MPI System Temperatures):**

1.  **Compensated MPI Temperature (`tcompmp`):**
    *   `tmotbks` and `tans` are used in `KFCOMPMPI` (2D lookup table).
    *   The `KFCOMPMPI` output is summed with `tmotbks`, then filtered (V.6.1) to yield `tcompmp`.
2.  **MPI Correction/Influence Factor (`fkmpifl`):**
    *   `tumgtbks` and `dmkrmpi_w` are inputs to `KFMPICOR` (2D lookup table).
    *   `dmkrmpi_w` also feeds `KFFKMPICOR` (2D lookup table).
    *   A bit from `CWTMODBKS1` (`get_bit1`) gates a multiplication between `dmkrmpi_w` and the `KFFKMPICOR` output.
    *   This result is filtered (V.6.1) to produce `fkmpifl`.
3.  **MPI Temperature Difference (`tdiffmpi`):**
    *   `tflvrhdp_SC` conditionally selects between `tflvrhdp` and a merged value.
    *   The selected `tflvrhdp` and `tmotbks` are inputs to `KFPMPITMP` (2D lookup table).
    *   The output of `KFPMPITMP` is summed with the selected `tflvrhdp`, then filtered (V.6.1) to produce `tdiffmpi`.
4.  **Robust MPI Temperature (`trohvmpi`):**
    *   The `IP_val` from `KFCOMPMPI` and the `IP_val` from `KFPMPITMP` are summed.
    *   Additional conditional contributions (gated by `CWTMODBKS` bits) are added.
    *   The final sum is filtered (V.6.1) to produce `trohvmpi`.

In essence, these diagrams represent a sophisticated model-based approach to thermal management, using a combination of empirical mappings (lookup tables) and logical control (conditional blocks, bit manipulation) to provide accurate and robust temperature estimates for critical powertrain components.


--- Page 70 ---

This image contains a Simulink diagram, specifically a block diagram illustrating a "TEMPFILTER" module for fuel temperature in an automotive application.

## Function

The primary function of this Simulink diagram, titled "43.5.6.7 TEMPFILTER" under "FUSL, Fuel temperature (Appl. Inc.)", is to process, filter, and manage various fuel temperature-related signals. It takes multiple raw temperature inputs and system status flags, applies condition-dependent filtering (likely first-order low-pass filters), and generates several filtered temperature outputs and derived status signals. The system is designed to handle different operational modes, including reset conditions and standstill detection, which are crucial for accurate and stable temperature readings in a dynamic automotive environment.

## Inputs

The diagram receives numerous inputs, including raw sensor data, initial conditions for filters, and system status flags. Key inputs observed are:

1.  **`tend_kl15`**: Status related to terminal 15 (ignition switch).
2.  **`B_tospgpl`**: A boolean or status signal.
3.  **`B_hst`**: A boolean or status signal, possibly indicating a "hot start" condition or heating status.
4.  **`tabst_w` / `tabst_w1`**: Raw absolute fuel temperature measurement.
5.  **`otbksabs`**: Another absolute temperature-related signal.
6.  **`tksvhdpabs`**: Temperature sensor value, possibly related to hydraulic pressure.
7.  **`tmotbks`**: Engine or motor temperature.
8.  **`tumgtbks`**: Another input temperature signal.
9.  **`B_stendz`**: A boolean or status signal, likely indicating "standstill zero" or similar vehicle state.
10. **`B_sshev`**: A boolean or status signal, possibly related to a heating element or valve.
11. **`tkast`**: A temperature sensor input.
12. **`tkatubks`**: Another temperature sensor input.
13. **`B_rztmbks`**: A boolean or status signal.
14. **`B_zttmgr`**: A boolean or status signal, possibly indicating a "zero temperature manager" state.
15. **`trohvhd`**: Initial value (IV) for the 'rhdp' (e.g., high-pressure regulation) filter.
16. **`tflvrhdp_filt_ini`**: Initial state (`x_in`) for the 'rhdp' filter.
17. **`tksvmpiabs`**: Temperature sensor value, possibly related to manifold pressure.
18. **`dmkrmpi_w`**: A differential or specific temperature related to manifold pressure.
19. **`tdiffmpi`**: A differential temperature input related to manifold pressure.
20. **`trohvmpi`**: Initial value (IV) for the 'vmpi' (e.g., manifold pressure related) filter.
21. **`tflvmpi_filt_ini`**: Initial state (`x_in`) for the 'vmpi' filter.
22. **`B_s_tmbkser`**: A master service enable/request signal for the temperature filter system.
23. **`reset_tflvrhdp_lp`**: A direct reset signal for the 'rhdp' filter.

## Outputs

The module generates several filtered temperature values and derived status/control signals:

1.  **`fazbksy_w`**: Processed or "actual" fuel temperature.
2.  **`fabstbks`**: Absolute filtered fuel temperature.
3.  **`tkadifbks`**: A filtered differential temperature.
4.  **`B_tmodbksc`**: A boolean or status output related to temperature modification.
5.  **`tstbks`**: A stabilized or test fuel temperature.
6.  **`tdiffbks_w`**: A differential temperature output.
7.  **`B_stendre`**: A boolean or status output, indicating "standstill enable" or "ready".
8.  **`B_sshev1`**: A boolean or status output derived from `B_sshev`.
9.  **`tnse_w`**: A normalized temperature signal.
10. **`tnsez_w`**: Another normalized temperature signal.
11. **`tka`**: A processed temperature value.
12. **`tumg`**: Another processed temperature value.
13. **`kfflafincor`**: A fuel temperature correction factor.
14. **`tflvrhdp`**: Filtered fuel temperature output, likely associated with fuel level and vapor handling or high-pressure regulation.
15. **`tflvmpi`**: Filtered fuel temperature output, likely associated with manifold pressure.

## Logic Flow

The diagram's logical flow can be broken down into several interconnected paths:

1.  **System State and Input Processing (Left Side - `RESBBKS` and `ZTTMBKS` subsystems):**
    *   The `RESBBKS` subsystem (`X.6.8.2`) takes `tend_kl15`, `reset_tflvrhdp_lp`, `B_tospgpl`, `B_hst`, `tabst_w`, `otbksabs`, `tksvhdpabs`, and `B_tmotbksabs` as inputs. It processes these to output `fazbksy_w`, `fabstbks`, `tkadifbks`, `B_tmodbksc`, and `tstbks`. This likely involves logic for overall fuel temperature control, limit supervision, or state transitions based on engine/ignition status.
    *   The `ZTTMBKS` subsystem (`X.8.1`) takes `B_stendz`, `B_sshev`, `tkast`, `tkatubks`, `B_rztmbks`, and `B_zttmgr` as inputs. It outputs `tdiffbks_w`, `B_stendre`, `B_sshev1`, `tnse_w`, `tnsez_w`, `tka`, `tumg`, and `kfflafincor`. This subsystem seems responsible for handling conditions related to "zero temperature" or specific temperature differential calculations and generating corresponding status flags or derived values.

2.  **Filter Reset and Enable Logic (`TMBKSER` and associated gates):**
    *   The `B_s_tmbkser` input feeds into the `TMBKSER` subsystem (`V.6.4`), producing `E_tmbkser`.
    *   `E_tmbkser` is negated by a `NOT` gate (`V.6.3`) and, along with logic from `CWTMODBKS2` (`V.6.4`) and `GET_BIT` (`V.7.0`), generates the reset (`R`) signal for the upper "Resettable filter".
    *   `B_stendz` (from input 5) and `E_tmbkser` (via an `AND` gate `V.6.6`) generate the enable (`E`) signal for both "Resettable filter" blocks. This ensures the filters are active only under specific system conditions.
    *   An additional reset signal `reset_tflvrhdp_lp` also directly feeds the `R` port of the upper filter.
    *   For the lower filter, logic involving `SY_MPI` (`V.6.4`) and `E_tmbkser` (via `AND` gates `V.6.6`) controls its reset signal.

3.  **Temperature Signal Pre-processing for Filtering:**
    *   **Upper Filter Path (`tflvrhdp`):** The input `u` to the upper "Resettable filter" is derived from signals related to `B_tmotbksabs`, `B_tmotbks`, and `E_tmbkser` through a series of logical and arithmetic operations (partially obscured).
    *   **Lower Filter Path (`tflvmpi`):** The input `u` to the lower "Resettable filter" is a more complex calculation:
        *   `tabst_w1` and `tksvmpiabs` feed into a 2D lookup table `KFINTMPI` (`V.7.3`).
        *   `dmkrmpi_w` and `tdiffmpi` feed into another 2D lookup table `KFFLTMP1` (`V.7.3`).
        *   The output of `KFINTMPI` is summed with `tmotbks` (motor temperature, also from input `[tmotbks]`). This summed value, combined with the output of `KFFLTMP1`, forms the input `u` for the filter.

4.  **Resettable First-Order Filtering:**
    *   Two "Resettable filter" blocks (`V.5.3`) are central to the filtering process. These are typically first-order low-pass filters:
        *   They receive their calculated input `u`.
        *   They are enabled/disabled via the `E` port and reset via the `R` port by the logic described above.
        *   The `IV` (initial value) and `x_in` (initial state) ports allow the filters to be initialized with specific values (`trohvhd`, `tflvrhdp_filt_ini` for the upper; `trohvmpi`, `tflvmpi_filt_ini` for the lower).
        *   The filters produce a smoothed output `y` and their internal state `x_out`.

5.  **Output Gating/Finalization:**
    *   The filtered outputs `y` from both "Resettable filter" blocks pass through "Check == 0" switch blocks (`V.6.6`). These switches likely act as a validity gate: if a specific condition (derived from various internal signals) is true (evaluates to 0), the filtered value is passed through; otherwise, a default value (e.g., 0) or the previous value might be maintained, ensuring a stable and safe output.
    *   The final outputs are `tflvrhdp` and `tflvmpi`.

In essence, the system dynamically filters fuel temperature measurements based on various operational states, such as ignition status, standstill conditions, and other system flags, providing robust and reliable temperature signals for further control algorithms in the vehicle.


--- Page 71 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "FUSL, Fuel temperature (Appl. Inc.)" and part of the "ZTTMBKS" (likely "Zylinderkopf-Temperatur Tankberechnung und Korrekturwert-Steuerung" - Cylinder Head Temperature Tank Calculation and Correction Value Control) subsystem, primarily functions to **dynamically calculate and adapt the estimated fuel tank temperature**. It considers various inputs such as primary/secondary tank temperature sensors, ambient temperature, engine conditions, and vehicle speed to produce a filtered and corrected fuel temperature value (`tkatubks`). It also manages flags (`B_rzttmbks`, `B_zttmgr`) that signify reset conditions or the activation of the temperature management system. The German description states: "Anpassung des dynamischen Temperaturverlaufs in Abhängigkeit von der Temperaturdifferenz zwischen Motor und Umgebung und der Fahrzeuggeschwindigkeit" (Adaptation of the dynamic temperature profile depending on the temperature difference between engine and ambient, and vehicle speed).

## Inputs
The key inputs to this subsystem are:

*   **`tnsez_w` (Port 4):** Primary fuel tank temperature sensor value (raw).
*   **`B_sshev` (Port 2):** Boolean flag, likely indicating the validity or selection of the primary tank temperature sensor (`tnsez_w`).
*   **`tnse_w` (Port 3):** Secondary or default fuel tank temperature sensor value.
*   **`B_stendre` (Port 1):** Boolean flag, indicating an engine start condition or a stable operating state.
*   **`tka` (Port 5):** Ambient air temperature.
*   **`tumg` (Port 6):** Engine temperature or another critical ambient temperature.
*   **`ZSNMST` (V.6.4):** A threshold or parameter related to zero speed or nominal engine speed.
*   **`TDSBKS` (V.6.4):** A threshold or parameter for temperature difference, potentially related to a braking system or specific temperature condition.
*   **`tdiffbks_w` (Port 8):** A calculated temperature difference value.
*   **`ztdbks_w` (V.6.4):** A status or threshold for zero temperature difference.
*   **`tkkfl_w` (V.6.4):** A correction factor related to cold start or cold conditions.
*   **`kfflaincor` (Port 7):** A general correction factor input, possibly for fine-tuning the adaptation.
*   **`tnsebks` (V.6.4):** A temperature threshold for evaluating reset conditions.

## Outputs
The key outputs from this subsystem are:

*   **`zttm_w` (Port 1):** The initially selected/filtered fuel tank temperature, based on sensor validity.
*   **`tkast` (Port 2):** An internally filtered and continuously adapted temperature estimate, acting as a state variable for the temperature model.
*   **`tkatubks` (Port 3):** The final adapted and corrected fuel tank temperature value.
*   **`B_rzttmbks` (Port 4):** A boolean flag, indicating a "Reset ZTTMBKS" condition, likely triggering a reset of the temperature model or filter.
*   **`B_zttmgr` (Port 5):** A boolean flag, indicating the activation status of the fuel temperature management or adaptation logic.

## Logic Flow

The logical flow can be broken down into several interconnected paths:

1.  **Initial Fuel Tank Temperature Selection (`zttm_w`):**
    *   The boolean signal `B_sshev` (Port 2) acts as a selector.
    *   If `B_sshev` is true (e.g., primary sensor valid), the value `tnsez_w` (Port 4) is passed through the "Check ~= 0" block (V.6.6).
    *   If `B_sshev` is false, `tnse_w` (Port 3) is passed instead.
    *   The output of this selection is `zttm_w` (Output Port 1), representing the raw or initially chosen fuel tank temperature.

2.  **`B_rzttmbks` (Reset Condition for ZTTMBKS) Calculation:**
    *   Two comparison paths feed into an `OR` block (V.6.3):
        *   **Path 1:** A signal, likely related to `tkast` or an internal temperature estimate, is compared against `tnsebks` (a temperature threshold, V.6.4) using a ">" (greater than) block (V.6.2).
        *   **Path 2:** The ambient/engine temperature `tumg` (Port 6) is compared against `tnsebks` (V.6.4) using another ">" block (V.6.2).
    *   If either of these conditions is met (i.e., `tkast` or `tumg` exceeds `tnsebks`), the `OR` block outputs `TRUE`, setting `B_rzttmbks` (Output Port 4). This flag signals a condition requiring a reset of the temperature management system.

3.  **Dynamic Temperature Filter/Adaptation (`tkast` and `tkatubks` Calculation):**
    *   **Input Selection:** `B_stendre` (Port 1) controls an "if" block (V.6.0). If `B_stendre` is true, `zttm_w` (from step 1) is selected as `zttm_w_if`. This `zttm_w_if` serves as an input to the filter logic.
    *   **Filtered Temperature `tkast`:** The signal `tkast` (Output Port 2) is part of a feedback loop that continuously estimates the fuel tank temperature. The diagram shows it being summed (V.7.2) and multiplied (V.7.3) with various factors, suggesting an iterative filtering process. `tkast` is either initialized by `zttm_w_if` or continuously updated based on calculations.
    *   **Correction Factor (`IP_val` from KLFDBKS):** A 1D or 2D lookup table `KLFDBKS` (V.7.2) takes `x_val` (likely `tkast` or a related temperature) and potentially another input to output `IP_val`. This `IP_val` represents a base correction or dynamic factor.
    *   **Intermediate Adapted Temperature (`tkatubks`):** The `IP_val` from `KLFDBKS` is added to `tkast` (V.7.2) to produce `tkatubks` (Output Port 3). This is the first stage of adaptation.
    *   **Further Dynamic Adaptation (using `KFZTST` and `KFZTTMM`):**
        *   `tkatubks` is then multiplied (`X` block, V.7.3) with a factor derived from `KFZTST` (V.7.3). `KFZTST` is a lookup table taking `x_val` (potentially a temperature difference) and `y_val` (e.g., vehicle speed) to provide an `IP_val`.
        *   The result is further multiplied (`X` block, V.7.3) with another correction factor from `KFZTTMM` (V.7.3). `KFZTTMM` is a lookup table that takes `x_val` (e.g., `kfflaincor` (Port 7)) and `y_val` (e.g., `B_zttmgr`) to provide its `IP_val`.
        *   These multiplications provide the final dynamically adapted fuel tank temperature, which likely feeds back to update `tkast` (though the exact feedback path is not fully depicted).

4.  **`B_zttmgr` (Fuel Temperature Management Active) Calculation:**
    *   **Start Condition Evaluation:** A complex logic block (V.6.4 to V.6.6) named "Bewertung der Bedingungen im Start" (Evaluation of conditions at start) combines several conditions using comparison and logical `AND` blocks:
        *   `ZSNMST` (V.6.4) and `TDSBKS` (V.6.4) are compared with `tumg` (Port 6) using "<" and ">" blocks (V.6.2).
        *   `tdiffbks_w` (Port 8) is compared with `tumg` (Port 6) using a ">" block (V.6.2).
        *   These results, along with `B_stendre` (Port 1), `tnse_w` (Port 3), `ztdbks_w` (V.6.4), and `tkkfl_w` (V.6.4), feed into an `AND` block (V.6.6). The output of this `AND` block forms the `SET` input of an `RSFlipFlop`.
    *   **RS Flip-Flop:** An `RSFlipFlop` (V.5.5) block manages the state of `B_zttmgr`.
        *   Its `SET` input is determined by the complex `AND` logic described above, which signifies that the conditions for activating temperature management are met.
        *   Its `RESET` input is `B_rzttmbks` (from step 2), meaning the management system is reset if the `B_rzttmbks` condition is true.
    *   The `Q` output of the `RSFlipFlop` is `B_zttmgr` (Output Port 5), a boolean flag indicating whether the fuel temperature management logic is currently active.


--- Page 72 ---

This image clearly displays a Simulink block diagram, indicated by the typical block shapes, signal lines, and labeling conventions (e.g., V.x.x for block versions). The title "FUSL, Fuel temperature (Appl. Inc.)" confirms its domain.

---

## Function
The primary function of this Simulink diagram is to process, filter, validate, and derive various fuel temperature-related values and status flags. It takes raw fuel temperature readings along with other system temperatures and control modes, applies filtering, look-up table adjustments, logical operations, and comparisons against thresholds to output a comprehensive set of temperature information and diagnostic flags relevant to fuel system management within an automotive context. The subsystem path `FUSL_M408B/OPM_100MS/TEMPFILTER/RESBBKS` suggests it's a fuel temperature filter or resilience block within a larger fuel system control module.

---

## Inputs
The key inputs to this Simulink diagram are:

*   **`B_stend_kl15`**: (Boolean) System status, likely indicating terminal 15 (ignition) status.
*   **`reset_tflvrhdp_lp`**: (Boolean) A reset signal for the temperature-related logic.
*   **`tabst_w`**: (Analog/Temperature) Raw fuel tank temperature reading.
*   **`tmotbksabs`**: (Analog/Temperature) Engine motor temperature (absolute).
*   **`tksvhdpabs`**: (Analog/Temperature) Coolant temperature (High Pressure Absolute, possibly for a specific circuit).
*   **`B_hst`**: (Boolean) Hot Start flag.
*   **`CWTMODBKS3`**: (Bus/Word) Control Word for Mode selection 3 (specific bits are extracted).
*   **`CWTMODBKS`**: (Bus/Word) Control Word for Mode selection (specific bits are extracted).
*   **`B_tospgpl`**: (Boolean) Temperature over-speed or gas pressure limit flag (appears as input and derived from internal logic, likely feedback or a default input).
*   **`CWTMODBKS2`**: (Bus/Word) Control Word for Mode selection 2 (specific bits are extracted).
*   **`t_sp_fl`**: (Analog/Temperature) Fuel temperature set point.
*   **`t_fl_min`**: (Analog/Temperature) Minimum allowed fuel temperature threshold.
*   **`t_fl_max`**: (Analog/Temperature) Maximum allowed fuel temperature threshold.
*   **`t_fl_low`**: (Boolean/Analog) A pre-existing low fuel temperature condition or a reference value.
*   **`B_tfl_min`**: (Boolean) Boolean flag for minimum fuel temperature condition.
*   **`tkadifbks`**: (Analog/Temperature) Temperature difference (appears as input and output, likely a feedback or default value when not calculated).

---

## Outputs
The key outputs from this Simulink diagram are:

*   **`cond_if`**: (Boolean) A general conditional flag, possibly indicating system activity or validity.
*   **`fabstbks`**: (Analog/Temperature) Filtered/processed fuel absolute stored temperature.
*   **`fazbksy_w`**: (Analog/Temperature) Derived fuel temperature, potentially from a lookup table.
*   **`tmodbksabs`**: (Analog/Temperature) Calculated temperature difference or mode temperature.
*   **`B_tospgpl`**: (Boolean) Temperature over-speed or gas pressure limit flag (as derived from mode word).
*   **`B_tmodbksc`**: (Boolean) Calculated Boolean flag for temperature mode.
*   **`B_tfl_low`**: (Boolean) Flag indicating raw fuel temperature is below minimum threshold.
*   **`B_tfl_max`**: (Boolean) Flag indicating raw fuel temperature is above maximum threshold.
*   **`val_tabst`**: (Boolean) Validation flag for the fuel temperature.
*   **`t_fl_low`**: (Analog/Temperature) A validated low fuel temperature value or flag.
*   **`tfl_min`**: (Analog/Temperature) Calculated minimum fuel temperature (potentially adjusted by setpoint).
*   **`tfl_max`**: (Analog/Temperature) Calculated maximum fuel temperature (potentially adjusted by setpoint).
*   **`tstbks`**: (Analog/Temperature) A selected test or validated fuel temperature.
*   **`tkadifbks`**: (Analog/Temperature) Calculated temperature difference, `fabstbks - t_fl_min`.

---

## Logic Flow

The logical flow of the diagram can be broken down into several interconnected stages:

1.  **System Initialization and Conditional Status:**
    *   `B_stend_kl15` (ignition status) is processed via a unit block (V.5.3) along with `reset_tflvrhdp_lp` (an external reset). The outcome of this logic determines the `cond_if` (output), a general conditional flag that controls the `sequencer` block.

2.  **Fuel Temperature Filtering/Sequencing:**
    *   The raw fuel tank temperature, `tabst_w`, is fed into a `sequencer` block (V.6.4). This block likely implements a state-dependent filter, average, or state machine.
    *   The `sequencer` operation is controlled by `cond_if` and modulated by `B_tmodbksc` (a calculated mode flag).
    *   The output of the `sequencer` is `fabstbks`, representing a filtered or processed fuel temperature.

3.  **Derived Fuel Temperature from Look-up Table:**
    *   `fabstbks` (filtered fuel temperature) and `tmotbksabs` (engine temperature) are fed as X and Y inputs to a 2D lookup table (`KFFZBKS`, V.7.3).
    *   The output of this lookup table is `fazbksy_w` (output), providing a derived fuel temperature, possibly adjusted based on engine thermal state.

4.  **Temperature Difference Calculation:**
    *   `tmodbksabs` (output) is computed by subtracting `tksvhdpabs` (another system temperature) from `tmotbksabs` (engine temperature).

5.  **Operating Mode and Status Flag Derivation:**
    *   Several `GET BIT` blocks (V.7.0) extract specific bits from control words `CWTMODBKS3`, `CWTMODBKS`, and `CWTMODBKS2`. These bits represent specific operating modes or status.
    *   Bit 6 from `CWTMODBKS` is directly output as `B_tospgpl` (output), potentially indicating an over-speed or gas pressure limit condition.
    *   `B_tmodbksc` (output) is derived from an `OR` logic combining bit 0 of `CWTMODBKS3` and bit 6 of `CWTMODBKS` (after passing through `Check ~= 0` blocks to ensure boolean interpretation). This flag influences the `sequencer` and other switches.

6.  **Fuel Temperature Threshold Checks:**
    *   `tabst_w` (raw fuel temperature) is continuously compared against predefined thresholds:
        *   If `tabst_w < t_fl_min` (minimum allowed fuel temperature), `B_tfl_low` (output) is set to true.
        *   If `tabst_w > t_fl_max` (maximum allowed fuel temperature), `B_tfl_max` (output) is set to true.

7.  **Complex Low Fuel Temperature and Validation Logic:**
    *   `val_tabst` (output) is determined by an `AND` operation between `B_tfl_min` (input, likely a specific minimum flag) and `t_fl_low` (input, a reference low temperature condition).
    *   A `Switch` block uses `B_tfl_low` (from step 6) as its control:
        *   If `B_tfl_low` is true (`tabst_w` is below `t_fl_min`), the output `t_fl_low` (output) takes the value of `val_tabst`.
        *   If `B_tfl_low` is false, the output `t_fl_low` takes the value of `t_fl_min` (input). This means the output `t_fl_low` is either a validated low condition or the minimum threshold itself if the temperature is not critically low.

8.  **Minimum and Maximum Output Temperature Derivation:**
    *   `tfl_min` (output) is selected by a `Switch`: If `tmodbksabs < t_sp_fl` (fuel temperature set point), then `t_fl_min` (input) is output; otherwise, `t_sp_fl` (input) is output.
    *   `tfl_max` (output) is selected by another `Switch`: If `B_tmodbksc` (the mode flag) is true, then `t_fl_max` (input) is output; otherwise, `t_sp_fl` (input) is output.

9.  **Setpoint-based Temperature and Difference Calculation:**
    *   A complex condition is formed by `AND`ing the following: `(tmodbksabs < t_sp_fl)`, `(NOT GET BIT(CWTMODBKS2, bit=1))`, and `B_hst` (hot start flag). This condition, after a `Check ~= 0` block, controls a `Switch`.
    *   If this condition is true, `tstbks` (output) is set to `t_fl_min` (input).
    *   If false, `tstbks` is set to `tkadifbks` (input).
    *   Finally, `tkadifbks` (output) is calculated as the difference between `fabstbks` and `t_fl_min`. This calculated `tkadifbks` can also be an input to the `tstbks` switch, implying it's either a feedback or an alternative default value.


--- Page 73 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "CLC_TFUELMX" and related to "FUSL, Fuel temperature," appears to calculate and output a controlled or maximum fuel temperature (`tfuelmx`). It processes two primary fuel temperature inputs, `tflvrhdp` and `tflvmpi`, and adjusts the final output based on system operating modes (`SY_MPI`, `CWTMODBKS2`) through a series of maximum selections, bit extractions, and conditional switches, potentially including an intermediate custom function.

## Inputs
*   **tflvrhdp (Inport 1):** A primary fuel temperature value, likely from a sensor or another calculation path.
*   **tflvmpi (Inport 2):** Another fuel temperature value, potentially related to the Multi-Port Injection (MPI) system or a different measurement.
*   **SY_MPI:** A system variable or flag indicating the status or mode of the Multi-Port Injection (MPI) system.
*   **CWTMODBKS2:** A control word or bitfield that provides configuration or status information, used to determine specific operating modes.
*   **0 (Constant):** Used as a comparison value for `SY_MPI` and as a parameter for the `GET BIT` block.
*   **4 (Constant):** Used as a parameter for the `GET BIT` block.

## Outputs
*   **tfuelmx (Outport 1):** The final calculated or controlled fuel temperature, which is the module's primary output.

## Logic Flow

The logical flow can be broken down into the following steps:

1.  **Initial Fuel Temperature Maximum:**
    *   The `max` block (V.6.6) compares `tflvrhdp` and `tflvmpi` and outputs the higher of the two values. Let's call this `initial_max_temp`.

2.  **MPI System Condition Check:**
    *   A relational `>` block (V.6.2) compares the `SY_MPI` input with the constant `0`.
    *   Its output, `mpi_active_flag`, is a boolean (`1` if `SY_MPI > 0`, `0` otherwise). This signal is also labeled `[tflvrhdp]` in the diagram, suggesting its significance might be linked to the activation or selection of `tflvrhdp`.

3.  **Operating Mode Bit Extraction:**
    *   A `GET BIT` block (V.7.0) extracts a specific bitfield, `mode_bits`, from the `CWTMODBKS2` input using `0` and `4` as parameters (likely indicating the starting bit position and the number of bits to extract).

4.  **First Stage Temperature Selection (Mode-Dependent):**
    *   A Switch block (V.6.6) uses `mode_bits` as its control input with the condition `Check ~= 0`.
    *   If `mode_bits` is **not equal to zero** (`Check ~= 0` is true), the switch selects `initial_max_temp` (the output of the `max` block).
    *   If `mode_bits` **is equal to zero** (`Check ~= 0` is false), the switch selects `mpi_active_flag` (the `1` or `0` result from `SY_MPI > 0`). This implies that `1` or `0` could represent a specific default or state-dependent temperature in this context. Let's call the output of this switch `selected_temp_1`.

5.  **Intermediate Function Processing:**
    *   The `selected_temp_1` is fed into a generic function block `f()`. This block represents an unspecified custom function, filter, calibration, or a more complex model that processes the selected temperature. The output of this block is `func_output`.

6.  **Second Stage Temperature Selection (MPI-Conditioned):**
    *   Another Switch block (V.6.6) uses the `mpi_active_flag` (the `1` or `0` result from `SY_MPI > 0`, again labeled `[tflvrhdp]`) as its control input with the condition `Check ~= 0`.
    *   If `mpi_active_flag` is **not equal to zero** (`Check ~= 0` is true, meaning `SY_MPI > 0`), the switch selects `func_output` (the result from the `f()` block).
    *   If `mpi_active_flag` **is equal to zero** (`Check ~= 0` is false, meaning `SY_MPI <= 0`), the switch selects the *original* `tflvrhdp` input value.

7.  **Final Output:**
    *   The output of the second switch is assigned to `tfuelmx`, which is the final calculated fuel temperature value passed out of the module.

In summary, the diagram orchestrates a series of conditional selections and an intermediate function call to derive a final fuel temperature, prioritizing certain temperature sources or processed values based on specific system modes and conditions. The repeated labeling `[tflvrhdp]` for the `SY_MPI > 0` output suggests this boolean flag is critical in determining the influence or activation of `tflvrhdp` throughout the logic.


--- Page 74 ---

This image contains a Simulink-like diagram, likely representing a functional block within an automotive embedded control system, given the context "FUSL, Fuel temperature (Appl. Inc.)" and "Continental" branding.

## Function

This diagram describes a "POSTDRIVE" logic module primarily responsible for conditionally processing various temperature inputs (related to fuel, motor, and tank) to derive and output corresponding "absolute" temperature values. A key aspect is the selection mechanism, controlled by a background mode or status signal, which determines which temperature input is actively processed at a given time. There is also a separate, simpler path for a fuel tank status signal.

## Inputs

1.  **`B_tmodbksc` (Input 1):** A boolean or enumerated control signal, likely indicating a mode or state (e.g., "tank mode background status control"). This signal dictates the conditional logic for temperature processing.
2.  **`tflvrhdp` (Input 2):** A temperature value, potentially related to fuel vapor, head pressure, or a similar measurement.
3.  **`tmotbks` (Input 3):** A temperature value, likely related to the motor or a motor-specific background system.
4.  **`ttankbks` (Input 4):** A temperature value, likely related to the fuel tank or a tank-specific background system.
5.  **`tflvmpi` (Input 5):** A temperature value, possibly related to fuel level or a specific measurement point in the fuel system.
6.  **`B_getankt` (Input 0):** A boolean or status signal, likely indicating the refueling status of the tank ("tanked" or "filled").

## Outputs

1.  **`B_getankt` (Output 1):** The processed or passed-through value of the `B_getankt` input.
2.  **`tksvhdapbs` (Output 2):** An absolute temperature value derived from `tflvrhdp`, potentially representing "tank vapor head pressure absolute" temperature.
3.  **`tmotbksabs` (Output 3):** An absolute temperature value derived from `tmotbks`, likely "motor temperature background system absolute".
4.  **`ttankabs` (Output 4):** An absolute temperature value derived from `ttankbks`, likely "tank temperature absolute".
5.  **`tksvmpiabs` (Output 5):** An absolute temperature value derived from `tflvmpi`, likely "tank fuel volume measurement point absolute".

## Logic Flow

1.  **`B_getankt` Path:**
    *   The input signal `B_getankt` (from the green block labeled '0') is fed into a function block `f()` (labeled 'V.6.4').
    *   This `f()` block performs a specific operation on `B_getankt` (e.g., filtering, debouncing, or simple pass-through).
    *   The result is output as `B_getankt` (to the blue block labeled '1').

2.  **Conditional Temperature Processing Path:**
    *   **Condition Evaluation:** The main control signal `B_tmodbksc` (from the green block labeled '1') is fed into the `cond_if` block (labeled 'V.6.0'). This block evaluates the condition of `B_tmodbksc` and generates a discrete control signal (likely an integer index, e.g., 1, 2, 3, or 4) based on the state of `B_tmodbksc`.
    *   **Central Dispatcher/Enable Generator:** The output of `cond_if` controls the central block labeled 'V.6.1' (the tall black block with numbered outputs 1, 2, 3, 4). This block acts as a dispatcher or an enable signal generator. Based on the `cond_if` output:
        *   If `cond_if` output is 1, then only output '1' of the central `V.6.1` becomes active (e.g., value 1), while outputs '2', '3', '4' are inactive (e.g., value 0).
        *   If `cond_if` output is 2, then only output '2' of the central `V.6.1` becomes active, and so on for outputs 3 and 4.
        This mechanism ensures that only one specific temperature processing path is "enabled" at a time.
    *   **Individual Temperature Processing Units:** Each of the four remaining green temperature inputs (`tflvrhdp`, `tmotbks`, `ttankbks`, `tflvmpi`) has a dedicated processing unit represented by a triangular block, also labeled `V.6.1`. Each of these units receives two inputs:
        *   Its direct corresponding temperature input (e.g., `tflvrhdp`).
        *   A specific enable/control signal from the central `V.6.1` block (e.g., output '1' from central `V.6.1` goes to the `tflvrhdp` processing unit).
    *   **Conditional Output Generation:** Each triangular `V.6.1` block processes its temperature input *only if* its associated control signal from the central `V.6.1` is active.
        *   When output '1' of the central `V.6.1` is active, the `tflvrhdp` processing unit becomes active, calculating and outputting `tksvhdapbs` (to blue block '2').
        *   When output '2' is active, the `tmotbks` processing unit becomes active, calculating and outputting `tmotbksabs` (to blue block '3').
        *   When output '3' is active, the `ttankbks` processing unit becomes active, calculating and outputting `ttankabs` (to blue block '4').
        *   When output '4' is active, the `tflvmpi` processing unit becomes active, calculating and outputting `tksvmpiabs` (to blue block '5').
    *   If a processing unit's control signal is inactive, its corresponding "absolute" output might hold its last value, be reset to a default, or be governed by other logic not explicitly shown.

In summary, the module selectively calculates and updates one of the "absolute" temperature outputs based on the `B_tmodbksc` input, while typically the other absolute temperature outputs are not actively updated by this specific logic branch.


--- Page 77 ---

This page contains a Simulink-style block diagram.

## Function
This Simulink diagram, titled "FUSL, Fuel pressure," describes a module responsible for **signal acquisition and processing of fuel pressure sensor data**. Its primary function is to sample fuel pressure sensor voltage at a 1ms recurrence, accumulate these samples, count the number of acquired samples, and perform signal averaging over variable segment times (e.g., 10ms segments). It then outputs various processed, validated, and diagnostic-related fuel pressure values.

## Inputs
The system receives a variety of inputs, including:

*   **Timing/Control Signals:**
    *   `FUSL_M4018_RST`: System reset signal.
    *   `FUSL_M4018_1MS`: 1ms timing signal for operations.
    *   `FUSL_M4018_SEG`: Segmentation control signal.
    *   `FUSL_M4018_10MS`: 10ms timing signal for segment operations.
    *   `fc_OPM_1MS`: Internal 1ms operation flag/signal.
    *   `fc_OPM_SEG_10MS`: Internal 10ms segment operation flag/signal.
    *   `opm_1ms`: Output from 1ms operation module, potentially fed back or to other modules.
    *   `opm_seg_10ms`: Output from 10ms segment operation module, potentially fed back or to other modules.
*   **Sensor and Control Data:**
    *   `<ACTION_INFR_GetVfupSens>`: Action request to acquire raw fuel pressure sensor voltage.
    *   `<AMP>`: Amplifier related input (likely calibration or status).
    *   `<C_VP_FUP_MES_MAX_DIAG>`: Configurable maximum diagnostic value for fuel pressure measurement.
    *   `<C_VP_FUP_MES_MIN_DIAG>`: Configurable minimum diagnostic value for fuel pressure measurement.
    *   `<FUP_EFP>`: Electrical Fuel Pump related data.
    *   `<LV_ST_END>`: Status end signal.
    *   `<MFF_SP_FUP_CTL>`: Control setpoint for fuel pressure.
    *   `<FUP_SP>`: General fuel pressure setpoint.
    *   `<FUP_AD_OFS>`: Analog offset for fuel pressure sensor.
    *   `<LV_FUP_LIH_H_PRS_CTL_REQ>`: Request for high-pressure control related to fuel.
    *   `<LV_FUP_MES_LIH_REQ>`: Request for fuel pressure measurement from LIH.
    *   `<input>` (multiple instances): Generic inputs to the OPM blocks, likely including raw sensor readings.

## Outputs
The module outputs several processed fuel pressure values and associated status/diagnostic signals:

*   `<FUP>`: Final, processed fuel pressure value.
*   `<FUP_H_SAE>`: High fuel pressure value (potentially conforming to SAE standards).
*   `<FUP_MES>`: Measured fuel pressure value.
*   `<FUP_SAE>`: Fuel pressure value (potentially conforming to SAE standards).
*   `<VP_FUP_MES>`: Variable fuel pressure measurement.
*   `CTR_VP_FUP_MES`: Counter for variable fuel pressure measurement.
*   `FUP: O V`: Fuel pressure output.
*   `FUP_H_SAE: O V`: High fuel pressure output.
*   `FUP_MES: O V`: Measured fuel pressure output.
*   `FUP_SAE: O V`: Fuel pressure output.
*   `LV_FUP_MES_SEG: V`: Segmented fuel pressure measurement validity.
*   `LV_VP_FUP_MES_NOT_VLD: V`: Variable fuel pressure measurement not valid flag.
*   `VP_FUP_RAW: ---`: Raw variable fuel pressure.
*   `VP_FUP_MES_SUM: V`: Sum of variable fuel pressure measurements.

## Logic Flow

1.  **Reset and Core Timing Signal Generation:** The module starts by receiving reset (`FUSL_M4018_RST`) and specific timing signals (`FUSL_M4018_1MS`, `FUSL_M4018_SEG`, `FUSL_M4018_10MS`). These signals are processed through initial blocks (V.5.3, V.5.7) to generate internal, synchronized timing flags like `fc_OPM_1MS` and `fc_OPM_SEG_10MS` which are critical for scheduling subsequent operations.

2.  **1ms Operation (`OPM_1MS` Block):** This block is activated by `fc_OPM_1MS` and receives generic `input` signals, which would typically include the raw fuel pressure sensor voltage triggered by `<ACTION_INFR_GetVfupSens>`. As per the description, it performs the **1ms sampling** of the sensor voltage. It outputs `opm_1ms` and `opm_seg_10ms` (which is likely an internal signal shared with the 10ms module).

3.  **10ms Segment Operation (`OPM_SEG_10MS` Block):** This block is activated by `fc_OPM_SEG_10MS` and receives inputs such as `opm_1ms` (from the 1ms module) and other generic `input` signals. This module is responsible for accumulating the 1ms samples, counting the number of acquired samples, and preparing data for **averaging over variable segment times**, typically 10ms as implied by its name. It outputs `opm_seg_10ms`.

4.  **Signal Aggregation (V.6.1 Block):** The outputs `opm_1ms` and `opm_seg_10ms` (representing processed data from 1ms and 10ms operations) are fed into block V.6.1. This block likely performs further synchronization, combination, or initial processing of the different-rate data streams before final calculations.

5.  **Final Calculation, Validation, and Output (V.6.5 Block):** The outputs from the aggregation block (V.6.1) along with the extensive list of diagnostic, control, and setpoint inputs from the left are all fed into a larger, unlabelled block (identified as V.6.5 by its version number). This is the core processing unit where the accumulated and averaged fuel pressure values are used to calculate the final fuel pressure outputs. It integrates diagnostic checks, applies offsets, handles control requests, and generates the various forms of fuel pressure outputs (e.g., raw, measured, SAE-standardized, high pressure) and associated validity or status flags.

6.  **External Output Routing:** The key processed fuel pressure values, such as `<FUP>`, `<FUP_H_SAE>`, `<FUP_MES>`, `<FUP_SAE>`, and `<VP_FUP_MES>`, are then routed out of this main processing block and the overall module for use by other systems.


--- Page 78 ---

This page contains Simulink diagrams illustrating a signal acquisition and initialization process.

## Function
The primary function of this Simulink diagram is to implement a **Signal Acquisition and Buffering** module for a fuel pressure sensor, as indicated by the "FUSL, Fuel pressure" title and the descriptive text. It handles the continuous sampling of raw sensor voltage at a 1ms rate, accumulates these samples and associated counters over 10ms segments, and provides a processed fuel pressure output. It also incorporates the necessary initialization of the internal states required for this buffering mechanism.

## Inputs
*   **`fc_OPM_1MS`**: (Event/Control Signal) A function call or event signal, likely indicating a 1ms periodic operation mode update.
*   **`FUSL_M4018_RST`**: (Boolean/Control Signal) A reset signal specifically for module M4018, used to trigger the initialization sequence.
*   **`FUSL_M4018_1MS`**: (Event/Control Signal) A 1ms periodic trigger signal for module M4018, used by the APP_CDN scheduler.
*   **`<input>`**: (Analog Value) The raw voltage reading directly from the fuel pressure sensor.
*   **`<opm_seg_10ms>`**: (Event/Control Signal) A function call or event signal indicating the completion of a 10ms segment for operational mode processing, which is critical for segment-based buffering.
*   **`feedback`**: (Data Bus/Internal State) A feedback signal to the 'Signal acquisition' block. This likely carries internal state information such as active buffer index, accumulated sums, or sample counts from the previous cycle, essential for continuous accumulation.

## Outputs
*   **`opm_1ms`**: (Numeric Value) The processed and buffered fuel pressure value, updated and available at a 1ms rate.

## Logic Flow

1.  **System Triggering and Initialization Control (APP_CDN):**
    *   The `APP_CDN V.5.13` block acts as a central scheduler or function call generator. It is configured for a `Recurrence: 1MS`, meaning its internal logic runs every millisecond.
    *   It takes `FUSL_M4018_RST` as its `RST` input and `FUSL_M4018_1MS` as its `1MS` input.
    *   Upon receiving a reset signal (`FUSL_M4018_RST`), it triggers the `fc_INI` output, initiating the system's initialization sequence.
    *   In normal operation, triggered every 1ms, it outputs `fc_OPM`, which initiates the main signal acquisition and processing routines.

2.  **Initialization of Buffers (Figure 43.6.3 and `f() ini` block):**
    *   When the `fc_INI` signal is triggered by `APP_CDN`, it activates the `f() ini X.1.1` block.
    *   This block receives an `ini` bus from the "Initialisation" sub-diagram (Figure 43.6.3).
    *   The "Initialisation" sub-diagram defines two arrays: `CTR_VP_FUP_MES` (likely a counter for the number of voltage samples of the fuel pressure measurement) and `VP_FUP_MES_SUM` (likely the accumulated sum of voltage samples for the fuel pressure measurement). Both are initialized to zero and are of size `[2]`, indicating a double-buffering scheme for segment-based accumulation.
    *   These zero-initialized arrays are combined into an `ini` bus. The `f() ini X.1.1` block uses this `ini` bus to reset or set the initial states of the internal buffers and counters within the signal acquisition system.

3.  **Signal Acquisition and Buffering (Signal acquisition block):**
    *   The `Signal acquisition X.1.2 opm` block is the core processing component, activated by the `fc_OPM` signal (every 1ms).
    *   It receives the `raw voltage of sensor` (`<input>`) at a 1ms sample rate.
    *   The input `<opm_seg_10ms>` indicates the completion of a 10ms segment. According to the text "Raw voltage of sensor is accumulated for each 10 ms / segment recurrence at 1 ms sample rate. Number of considered samples is counted accordingly in active buffer selected by LV_FUP_MES_SEG.", this block continuously samples the raw voltage.
    *   It utilizes the `feedback` input (which likely includes `CTR_VP_FUP_MES` and `VP_FUP_MES_SUM` or similar internal states) to manage two buffers. While one buffer is accumulating 1ms samples over a 10ms period, the other is likely being processed (e.g., averaged) or is ready for the next segment.
    *   When a 10ms segment ends (signaled by `<opm_seg_10ms>`), the accumulated samples and counts are used to compute an intermediate fuel pressure value, and the buffers are switched or reset for the next segment.
    *   The block outputs the calculated instantaneous or segment-averaged fuel pressure as `opm`.

4.  **Signal Merging and Final Output:**
    *   The `BusMerge V.5.35` block combines the `ini` bus (representing the current buffer states/initialization values) and the `opm` signal (the processed fuel pressure from the signal acquisition) into a single bus.
    *   This merged bus is then fed into the `opm_1ms V.6.1` block. This block performs any final processing steps, such as selection, scaling, or further filtering, to produce the final fuel pressure output.
    *   The system's final output, `opm_1ms`, represents the continuously updated (1ms rate) and processed fuel pressure value.


--- Page 79 ---

This page contains a Simulink-like diagram, likely representing a block-diagram implementation for an automotive control system.

## Function

The primary function of this diagram, titled "FUSL, Fuel pressure" and specifically "Signal buffering", is to process a raw fuel pressure sensor signal. It aims to acquire the raw voltage, average it over a 10ms recurrence period (segment), convert this averaged voltage into a calibrated pressure value using a linear sensor characteristic, and finally apply low-pass filtering to produce a stable and reliable fuel pressure output. This process reduces noise and provides a smoother, more accurate measurement for downstream control logic.

## Inputs

1.  **`<input>` (Raw Sensor Signal):** This represents the raw analog voltage signal from the fuel pressure sensor.
2.  **`<ACTION_INFR_GetVfupSens_T2>` (Sensor Read Trigger):** A trigger or event signal that initiates the reading of the raw fuel pressure sensor value by the `ACTION_INFR_GetVfupSens` block.
3.  **`<opm_seg_10ms>` (Operational Mode Segment 10ms):** A timing or synchronization signal, indicating the start or end of a 10ms operational segment during which the signal processing and averaging take place. This aligns with the "Recurrence: SEG 10MS" mentioned in the text.
4.  **`<feedback>` (Generic Feedback):** A general feedback signal, whose specific purpose is not fully detailed but likely relates to internal state management or control of the averaging process. It's connected to the `CTR_VP_FUP_MES` signal path.
5.  **`<LV_FUP_MES_SEG>` (Last Value Fuel Pressure Measurement Segment):** This signal likely represents the averaged fuel pressure value from the *previous* 10ms segment. It serves as an input to the `V.6.9` block.
6.  **`<VP_FUP_MES_SUM>` (Fuel Pressure Measurement Sum):** This signal likely represents the accumulated sum of raw fuel pressure readings from the *previous* processing cycle or segment. It serves as an input to the `V.7.10` block.
7.  **`<CTR_VP_FUP_MES>` (Fuel Pressure Measurement Counter):** This signal likely represents the count of samples accumulated from the *previous* processing cycle or segment. It serves as an input to the `V.7.10` block.

## Outputs

1.  **`opm` (Processed Fuel Pressure):** This is the main output of the system, representing the averaged, converted, and low-pass filtered fuel pressure value.

## Logic Flow

The logical flow describes how the raw sensor signal is transformed into the stable `opm` output:

1.  **Raw Signal Acquisition (ACTION_INFR_GetVfupSens):**
    *   The process begins with the `ACTION_INFR_GetVfupSens` block, which is an "ActionImport" block.
    *   It is activated by the `<ACTION_INFR_GetVfupSens_T2>` trigger.
    *   Upon activation, this block reads the raw fuel pressure sensor input (implicitly from `<input>`) and outputs `PRM_VP_FUP_RAW` and `VP_FUP_RAW`, representing the instantaneous raw fuel pressure voltage.

2.  **Counter and Sum Accumulation (V.6.9, V.6.4, V.5.4, V.7.10):**
    *   The `VP_FUP_RAW` (current raw fuel pressure) is fed into block `V.7.10`, which appears to be a stateful block (indicated by `C0` and `[..]`, typical for accumulators or delays).
    *   Simultaneously, a counter mechanism is at play:
        *   `LV_FUP_MES_SEG` (previous segment's average/value) is fed into block `V.6.9`. `VP_FUP_RAW` also feeds into `V.6.9`. `V.6.9` likely buffers or processes these values to maintain a running state for the counter.
        *   The output `u` of `V.6.9` is fed into the adder `V.5.4`.
        *   A constant value `1` (from block `V.6.4`) is also fed into `V.5.4`. This `V.5.4` block thus increments a value, presumably the count of samples. The output of `V.5.4` represents the *new* count for the current segment.
    *   Block `V.7.10` receives the current `VP_FUP_RAW`, the previous accumulated sum (`VP_FUP_MES_SUM`), and the previous counter value (`CTR_VP_FUP_MES`), along with the new incremented count from `V.5.4`.
    *   Within `V.7.10`, the raw fuel pressure `VP_FUP_RAW` is added to the internally held `VP_FUP_MES_SUM` to accumulate the total sum of readings for the current segment. The counter (`CTR_VP_FUP_MES`) is also updated by incorporating the incremented value from `V.5.4`.
    *   The `opm_seg_10ms` signal governs the recurrence of this accumulation process, ensuring that the sum and count are reset or processed at the start/end of each 10ms segment.

3.  **Averaging, Conversion, and Filtering (within V.7.10 or implied):**
    *   As per the description "Raw sensor signal voltage is averaged over one recurrence, converted into pressure value according to linear sensor characteristic, and low-pass filtered," these operations are performed.
    *   After accumulating the sum (`VP_FUP_MES_SUM`) and count (`CTR_VP_FUP_MES`) over the 10ms recurrence, `V.7.10` internally calculates the average (e.g., `VP_FUP_MES_SUM / CTR_VP_FUP_MES`).
    *   This averaged voltage value is then converted into a pressure unit using a pre-defined linear sensor characteristic.
    *   Finally, a low-pass filter is applied to the converted pressure value to smooth out any remaining high-frequency noise.

4.  **Output Generation (opm):**
    *   The final, fully processed (averaged, converted to pressure, and low-pass filtered) value is output from block `V.7.10` and designated as `opm`. This `opm` signal represents the stable and reliable fuel pressure measurement for the system.
    *   The inputs `LV_FUP_MES_SEG`, `VP_FUP_MES_SUM`, and `CTR_VP_FUP_MES` are likely feedback loops within a larger system, indicating that these states are maintained across segments and initialized (RST) when required.


--- Page 80 ---

This page contains two distinct Simulink-style diagrams: "Figure 43.6.5: Signal processing" and "Figure 43.6.6: Initialisation". I will analyze the "Signal processing" diagram as the primary functional component and the "Initialisation" diagram as a supporting function.

## Function
The primary function of the "Signal processing" diagram is to process and standardize raw fuel pressure sensor signals (`input`, `opm_1ms`) into a final, segmented output (`opm_seg_10ms`) at a 10-millisecond recurrence rate. This involves state-based control, initialization, and signal conditioning, likely including filtering, scaling, and validation specific to fuel pressure management (FUSL). The "Initialisation" diagram sets up the initial conditions for variables related to fuel pressure measurement.

## Inputs
### For "Figure 43.6.5: Signal processing":
*   **`input`**: The raw, unprocessed measurement from the fuel pressure sensor.
*   **`opm_1ms`**: A higher-frequency (1ms) sampled or pre-processed fuel pressure measurement.
*   **`fc_OPM_SEG_10MS`**: A control signal indicating a 10ms segment operation.
*   **`<FUSL_M4018_RST>`**: A reset signal for the fuel pressure system's internal states.
*   **`<FUSL_M4018_SEG>`**: A control signal related to the processing segment.
*   **`<FUSL_M4018_10MS>`**: A control signal related to the 10ms processing cycle.
*   **`LV_ST_END`**: A Boolean flag used by the recurrence block to determine the activation of `SEG` or `10MS` operations.

### For "Figure 43.6.6: Initialisation":
*   **`f()`**: A function call or trigger to activate the initialization sequence.

## Outputs
### For "Figure 43.6.5: Signal processing":
*   **`opm_seg_10ms`**: The final, standardized, and segmented fuel pressure value, output at a 10ms interval.

### For "Figure 43.6.6: Initialisation":
*   **`ini`**: An initialization status or signal, indicating that the specified fuel pressure-related variables have been set to their initial values.

## Logic Flow

### "Figure 43.6.5: Signal processing"

1.  **Recurrence and State Management (APP CDN V.5.13 Block):**
    *   This orange block, likely a Stateflow chart or a custom control block, manages the operational timing and states of the signal processing.
    *   It receives several control inputs: `FUSL_M4018_RST`, `FUSL_M4018_SEG`, `FUSL_M4018_10MS`, `fc_OPM_SEG_10MS`, and `LV_ST_END`.
    *   It defines a `Recurrence` of "SEG 10MS" and an `Init` state of "RST".
    *   Crucially, it dictates activation based on `LV_ST_END`: if `LV_ST_END == 1`, the `SEG` operation is activated; if `LV_ST_END == 0`, the `10MS` operation is activated.
    *   It outputs `fc_INI` (an initialization control signal) and `fc_OPM` (an operational control signal).

2.  **Initialization Trigger (`f()` block and `ini`):**
    *   The `fc_INI` signal from the recurrence block triggers an `f()` function, which produces an `ini` signal. This `ini` signal is an explicit indication that an initialization procedure should occur or has occurred. This `ini` signal then feeds into the "Signal standardization" block.

3.  **Signal Standardization (Signal standardization opm X.2.2 Block):**
    *   This blue block is the core processing unit. It receives the raw `input`, the 1ms sampled `opm_1ms`, and the `ini` signal for proper initialization.
    *   It also receives the `fc_OPM` signal, indicating that its processing behavior is controlled by the recurrence block (e.g., different filters or processing steps might be applied based on the current `SEG` or `10MS` state).
    *   This block performs signal conditioning, which could include filtering, scaling, conversion, and validation of the fuel pressure.
    *   It outputs a bus of processed signals, labeled `opm`. A "feedback" line from this block suggests internal state information or processed values are fed back within the block or to other modules not shown.

4.  **Bus Merging (`BusMerge V.5.35`):**
    *   The `opm` bus, containing the standardized fuel pressure signals, is fed into a `BusMerge` block. This block combines the `opm` bus with potentially other signals (implied by the multiple input lines, though only one source is clearly visible) into a consolidated bus structure.

5.  **Output Selection (`Bus Selector V.6.1`):**
    *   Finally, a `Bus Selector` block extracts the specific `opm_seg_10ms` signal from the merged bus. This signal represents the final, standardized, and segmented fuel pressure measurement, available at a 10ms rate, ready for use by other control systems.

### "Figure 43.6.6: Initialisation"

1.  **Initialization Function (`f()` block):**
    *   This diagram shows that when an `f()` trigger is received, it sets several key fuel pressure-related variables (`LV_FUP_MES_SEG`, `FUP`, `FUP_MES`, `VP_FUP_MES`, `LV_VP_FUP_MES_NOT_VLD`, `FUP_SAE`, `FUP_H_SAE`) to an initial value of `0`.
    *   The output `ini` indicates that this initialization process has completed, providing a clear initialization state to other parts of the system, such as the "Signal standardization" block in the main processing diagram.


--- Page 81 ---

This page contains a Simulink-like block diagram.

## Function

The primary function of this Simulink diagram is to process fuel pressure measurement signals (FUSL - Fuel Pressure). This involves several stages: **signal averaging**, **conversion**, **filtering**, and **validation**. The system takes various raw, feedback, diagnostic, and control-related inputs, processes them through a series of calculation blocks, and produces refined, validated fuel pressure values along with diagnostic flags and consolidated outputs for further use in an automotive control system.

## Inputs

The system receives a comprehensive set of inputs, which can be categorized as follows:

1.  **Feedback/Previous State Variables:**
    *   `<LV_FUP_MES_SEG>`: Segment flag for fuel pressure measurement.
    *   `<VP_FUP_MES>`: Volatile fuel pressure measurement (from feedback).
    *   `<CTR_VP_FUP_MES>`: Counter for volatile fuel pressure measurement.
    *   `<VP_FUP_MES_SUM>`: Sum for volatile fuel pressure measurement.
2.  **Raw/Timed Measurements:**
    *   `<VP_FUP_MES>`: Volatile fuel pressure measurement (e.g., from a 1ms sampling input).
    *   `<FUP_MES>`: Fuel pressure measurement (likely another raw or slightly pre-processed value).
    *   `<FUP>`: Fuel pressure (possibly a prior calculated value for feedback or comparison).
3.  **Configuration/Diagnostic Parameters:**
    *   `<AMP>`: Amplitude or scaling factor.
    *   `<C_VP_FUP_MES_MIN_DIAG>`: Minimum diagnostic limit for volatile fuel pressure measurement.
    *   `<C_VP_FUP_MES_MAX_DIAG>`: Maximum diagnostic limit for volatile fuel pressure measurement.
    *   `<FUP_AD_OFS>`: Fuel pressure additive offset.
4.  **Control/Setpoint/Request Signals:**
    *   `<FUP_EFP>`: Electrical Fuel Pump related signal.
    *   `<MFF_SP_FUP_CTL>`: Main Fuel Filter setpoint for fuel pressure control.
    *   `<LV_FUP_MES_LIH_REQ>`: Fuel pressure measurement "low pressure in high" request.
    *   `<FUP_SP>`: Fuel pressure setpoint.
    *   `<LV_FUP_LIH_H_PRS_CTL_REQ>`: Fuel pressure "low pressure in high pressure control" request.

## Outputs

The system outputs several processed signals and buses:

1.  **`clc_vp_fup_mes` Bus:** Contains the results of volatile fuel pressure averaging.
    *   `<VP_FUP_MES>`: Averaged volatile fuel pressure measurement.
    *   `<LV_FUP_MES_SEG>`: Updated segment flag.
    *   `<VP_FUP_MES_SUM>`: Updated sum.
    *   `<CTR_VP_FUP_MES>`: Updated counter.
2.  **`clc_fup_mes` Bus:** Contains filtered fuel pressure measurements.
    *   `<FUP_MES>`: Filtered fuel pressure measurement.
    *   `<FUP_SAE>`: Fuel pressure sensor analog input equivalent (likely another filtered variant).
    *   `<FUP_H_SAE>`: High-resolution fuel pressure sensor analog input equivalent.
3.  **`clc_fup` Bus:** Contains the final validated fuel pressure and diagnostic status.
    *   `<LV_VP_FUP_MES_NOT_VLD>`: Flag indicating if the volatile fuel pressure measurement is not valid.
    *   `FUP`: The final calculated and validated fuel pressure value.
4.  **`opm`:** A consolidated output signal, likely representing the primary processed fuel pressure value for an "Operating Point Management" or similar system.

## Logic Flow

The logical flow can be broken down into three main processing stages, followed by a consolidation step:

1.  **Signal Averaging and Buffer Management (`clc_vp_fup_mes X.2.2.1`):**
    *   This block receives raw/timed volatile fuel pressure measurements (`VP_FUP_MES` from `<opm_1ms>`) along with feedback/previous state variables (`LV_FUP_MES_SEG`, `VP_FUP_MES`, `CTR_VP_FUP_MES`, `VP_FUP_MES_SUM` from `<feedback>`).
    *   As indicated by the accompanying text "Signal averaging," its primary task is to perform averaging calculations, likely involving buffer management and ensuring data consistency. It updates the sum and counter, and potentially segments the data.
    *   It outputs the updated averaged volatile fuel pressure (`VP_FUP_MES`) and associated averaging state variables (`LV_FUP_MES_SEG`, `VP_FUP_MES_SUM`, `CTR_VP_FUP_MES`) as a bus `clc_vp_fup_mes`.

2.  **Signal Filtering and Conversion (`clc_fup_mes X.2.2.2`):**
    *   This block takes the averaged volatile fuel pressure (`VP_FUP_MES` from `clc_vp_fup_mes X.2.2.1`) and an `AMP` (amplitude/scaling factor) as inputs.
    *   It applies filtering (e.g., low-pass filtering) to smooth the signal and may perform unit conversions or scaling to produce refined fuel pressure measurements suitable for different applications.
    *   It outputs different filtered versions of the fuel pressure measurement (`FUP_MES`, `FUP_SAE`, `FUP_H_SAE`) as a bus `clc_fup_mes`.

3.  **Comprehensive Fuel Pressure Calculation, Validation, and Control Integration (`clc_fup X.2.2.3`):**
    *   This is the most elaborate processing stage, receiving a wide array of inputs including filtered measurements (`FUP_MES`, `VP_FUP_MES`), diagnostic limits (`C_VP_FUP_MES_MIN_DIAG`, `C_VP_FUP_MES_MAX_DIAG`), setpoints (`FUP_SP`, `MFF_SP_FUP_CTL`), offset values (`FUP_AD_OFS`), and various control requests (`LV_FUP_MES_LIH_REQ`, `LV_FUP_LIH_H_PRS_CTL_REQ`, `FUP_EFP`).
    *   Within this block:
        *   **Diagnosis:** It checks the `VP_FUP_MES` against its minimum and maximum diagnostic limits to determine if the measurement is valid, outputting `LV_VP_FUP_MES_NOT_VLD`.
        *   **Offset/Setpoint Application:** It incorporates offsets and setpoints into the fuel pressure calculation.
        *   **Control Logic:** It integrates various control-related signals and requests to influence the final fuel pressure calculation, likely adjusting it based on engine or vehicle operating conditions.
        *   **Final Calculation:** Based on all these inputs, it computes the final, robust, and validated fuel pressure value, `FUP`.
    *   It outputs the diagnostic flag (`LV_VP_FUP_MES_NOT_VLD`) and the final fuel pressure (`FUP`) as a bus `clc_fup`.

4.  **Consolidated Output (`opm` block):**
    *   The results from the three main processing blocks (specifically, `clc_vp_fup_mes`, `clc_fup_mes`, and `clc_fup` buses, as well as individual signals like `FUP_MES`, `FUP`, `LV_VP_FUP_MES_NOT_VLD`) are fed into a final `opm` block.
    *   This block acts as a collector or consolidator, taking these various processed signals and producing a single, aggregated `opm` output. This `opm` output likely represents the critical, ready-to-use fuel pressure information for other modules in the control system.


--- Page 82 ---

This page contains two Simulink-like diagrams that describe parts of a fuel pressure processing system.

## Function
The primary function of these interconnected Simulink diagrams is to process raw fuel pressure sensor signals. This involves two main stages:
1.  **Signal Averaging (Figure 43.6.8):** This stage averages the raw fuel pressure measurements over active segments and provides a count of valid segments. It outputs an averaged/filtered fuel pressure value.
2.  **Signal Conversion (Figure 43.6.9):** This stage takes the (potentially averaged) fuel pressure, applies linear calibration (slope and offset), limits the values, and offers options for compensation using an additional amplitude offset. It then converts these calibrated values into different unit formats suitable for various system functions or diagnostic scan tools.

Together, these diagrams represent a robust signal conditioning pipeline for automotive fuel pressure sensing.

## Inputs
The combined system takes the following key inputs:

*   **`<LV_FUP_MES_SEG>`**: A logical (boolean) signal indicating whether the current fuel pressure measurement segment is valid and should be included in averaging.
*   **`<VP_FUP_MES>` (raw)**: The initial raw measured fuel pressure signal (e.g., from a sensor, possibly a voltage signal as suggested by the text "Signal conversion from voltage to pressure").
*   **`C_FUP_MES_SLOP`**: A calibration constant representing the slope for the linear conversion of the pressure signal.
*   **`C_VP_FUP_MES_OFS`**: A calibration constant representing the offset for the linear conversion of the pressure signal.
*   **`C_FUP_MES_MAX`**: A constant defining the maximum allowable value for the calibrated fuel pressure.
*   **`C_FUP_MES_MIN`**: A constant defining the minimum allowable value for the calibrated fuel pressure.
*   **`<AMP>`**: An additional amplitude or offset value, likely used for dynamic or static compensation of the fuel pressure.
*   **`LC_FUP_RAW_CLC_SWI` (V.6.4)**: A logical control signal that likely determines whether to output raw calibrated pressure or compensated pressure in the conversion stage.

## Outputs
The combined system produces the following key outputs:

*   **`<VP_FUP_MES>` (averaged/filtered)**: The averaged or filtered fuel pressure value, resulting from the averaging stage (Figure 43.6.8). This output typically serves as the processed input to the signal conversion stage.
*   **`<VP_FUP_MES_SUM>`**: The accumulated sum of raw fuel pressure measurements during valid segments.
*   **`<CTR_VP_FUP_MES>`**: The total count of valid fuel pressure measurement segments.
*   **`<FUP_MES>`**: The primary calibrated fuel pressure measurement, potentially incorporating compensation based on the control logic.
*   **`<FUP_SAE>`**: The calibrated fuel pressure (which could be raw or compensated), converted to a specific unit (e.g., kPa/hPa), possibly adhering to a standard like SAE.
*   **`<FUP_H_SAE>`**: Another variant of the calibrated fuel pressure, potentially with compensation applied, and converted to a specific unit (e.g., kPa/hPa).

## Logic Flow

The system operates in a sequential flow, starting with signal averaging and then proceeding to signal conversion.

### Part 1: Signal Averaging (Figure 43.6.8)

1.  **Reset Condition Generation**: The `<LV_FUP_MES_SEG>` signal is fed into a `NOT` block (V.6.3). The output of this `NOT` block acts as a reset signal for the subsequent accumulation blocks. When `<LV_FUP_MES_SEG>` is FALSE (no valid segment), the `NOT` block output is TRUE, triggering a reset.
2.  **Pressure Sum Accumulation**: The raw `<VP_FUP_MES>` signal is fed into the upper C-block (V.6.9) which acts as a resettable accumulator. When `<LV_FUP_MES_SEG>` is TRUE (valid segment, `NOT` is FALSE, no reset), this block accumulates the `<VP_FUP_MES>` values. The accumulated sum is outputted as `<VP_FUP_MES_SUM>`. If reset is active, it resets to `0`.
3.  **Segment Count Accumulation**: In parallel, a constant `1` (implied for counting) is fed into the lower C-block (V.6.9), which also acts as a resettable accumulator/counter. When `<LV_FUP_MES_SEG>` is TRUE, it increments its count. The accumulated count is outputted as `<CTR_VP_FUP_MES>`. If reset is active, it resets to `0`.
4.  **Average Calculation**: The accumulated pressure sum (`<VP_FUP_MES_SUM>`) is divided by the segment count (`<CTR_VP_FUP_MES>`) using the division block (V.7.2), calculating the average pressure for the active segments.
5.  **Averaged Pressure Output Selection**: A switch block (V.6.6), controlled by the condition "Check ~= 0" (which likely refers to `<CTR_VP_FUP_MES>`), determines the final `<VP_FUP_MES>` output.
    *   If `CTR_VP_FUP_MES` is zero (no valid segments for averaging), the switch outputs the original raw `<VP_FUP_MES>` input.
    *   If `CTR_VP_FUP_MES` is non-zero, the switch outputs the calculated average pressure. This signal, now representing the averaged or raw fuel pressure, is passed on as the input to the next stage.

### Part 2: Signal Conversion (Figure 43.6.9)

1.  **Linear Calibration**: The `<VP_FUP_MES>` signal (from the averaging stage) is first multiplied by the `C_FUP_MES_SLOP` (V.5.5 multiplication block) and then the `C_VP_FUP_MES_OFS` is added (V.5.4 addition block). This implements a linear conversion formula: `CalibratedValue = VP_FUP_MES * Slope + Offset`.
2.  **Value Limiting**: The result of the linear calibration is fed into a saturation/limiter block (V.5.4), which constrains the value between `C_FUP_MES_MIN` and `C_FUP_MES_MAX`. The output of this block is labeled `FUP_MES`.
3.  **Compensated Pressure Calculation**: The `FUP_MES` signal is added to the `<AMP>` signal (V.7.2 sum block) to produce a compensated pressure value (`FUP_MES + AMP`).
4.  **Primary Output `<FUP_MES>` Determination**: The calibrated `FUP_MES` and the compensated `(FUP_MES + AMP)` values are routed through a series of switches (V.6.6 and V.6.1). The `LC_FUP_RAW_CLC_SWI` signal (V.6.4) likely controls these switches. This logic selects whether the final `<FUP_MES>` output will be the raw calibrated `FUP_MES` or the compensated `(FUP_MES + AMP)` value.
5.  **Unit Conversion for `<FUP_SAE>`**: The determined `<FUP_MES>` signal (output of V.6.1) is then multiplied by a unit conversion factor (`0.1 kPa / hPa`) using block V.7.3 to produce the `<FUP_SAE>` output.
6.  **Unit Conversion for `<FUP_H_SAE>`**: Similarly, the `FUP_MES` and `(FUP_MES + AMP)` values are fed into another switch block (V.6.6), again likely controlled by `LC_FUP_RAW_CLC_SWI`. The output of this switch is then multiplied by the same `0.1 kPa / hPa` conversion factor (V.7.3) to produce the `<FUP_H_SAE>` output. This output likely represents a specific, possibly compensated, fuel pressure value for high-accuracy or diagnostic purposes.


--- Page 83 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, titled "FUSL, Fuel pressure," is designed to process and validate a measured fuel pressure signal (`<VP_FUP_MES>`). Its primary function is to:
1.  Perform diagnostic checks on the measured fuel pressure to ensure it is within plausible operating limits.
2.  Rate-limit the measured fuel pressure to prevent unrealistic rapid changes, generating a smoothed, validated pressure signal.
3.  Derive an indication for low-pressure conditions (`[fup_lih]`) based on the rate-limited pressure and various control requests.
4.  Calculate a final, robust fuel pressure value (`FUP`) by combining the smoothed measured pressure, commanded setpoints, and calibration offsets.

In essence, it takes a raw fuel pressure measurement, validates it, smooths it, and then calculates a final, usable fuel pressure value for other vehicle systems, while also providing a diagnostic flag for invalid measurements.

## Inputs

*   **`<VP_FUP_MES>`**: Measured Fuel Pressure (main sensor input).
*   **`C_VP_FUP_MES_MIN_DIAG`**: Constant: Minimum diagnostic threshold for fuel pressure.
*   **`C_VP_FUP_MES_MAX_DIAG`**: Constant: Maximum diagnostic threshold for fuel pressure.
*   **`LC_VP_FUP_MES_LIM_ENA`**: Logical Variable: Enable signal for fuel pressure limiting/diagnostics.
*   **`C_FUP_MES_LIM_INC`**: Constant: Positive rate limit for fuel pressure changes (increment).
*   **`IP_FUP_MES_LIM_DEC`**: Interpolated Parameter: Negative rate limit for fuel pressure changes (decrement).
*   **`<MFF_SP_FUP_CTL>`**: Commanded Fuel Pressure Setpoint.
*   **`C_FUP_EFP_OFS_RED`**: Constant: Offset reduction for effective fuel pressure.
*   **`<FUP_EFP>`**: Effective Fuel Pressure (or a related signal).
*   **`<LV_FUP_MES_LIH_REQ>`**: Logical Variable: Request for Low Pressure (LIH) indication.
*   **`<LV_FUP_LIH_H_PRS_CTL_REQ>`**: Logical Variable: High-Pressure Control Request for Low Pressure (LIH).
*   **`C_FUP_MES_CRLC`**: Constant: Calibration value for calculating the final fuel pressure.
*   **`<FUP_AD_OFS>`**: Analog-to-Digital Offset for Fuel Pressure.

## Outputs

*   **`LV_VP_FUP_MES_NOT_VLD`**: Logical Variable: Flag indicating if the measured fuel pressure is NOT valid (due to diagnostics).
*   **`[fup_lih]`**: Low-pressure indication or a specific low-pressure derived value, often based on the rate-limited measurement.
*   **`FUP`**: The final, validated, and processed Fuel Pressure value.

## Logic Flow

The diagram processes the fuel pressure in several sequential and parallel stages:

1.  **Measured Fuel Pressure Diagnostics (Top Left):**
    *   The `VP_FUP_MES` signal is compared against `C_VP_FUP_MES_MIN_DIAG` (using a `<` block, V.6.2) and `C_VP_FUP_MES_MAX_DIAG` (using a `>` block, V.6.2).
    *   If the measured pressure is either below the minimum or above the maximum threshold, the respective comparison block outputs `TRUE`.
    *   These two `TRUE` outputs are combined by an `OR` gate (V.6.3).
    *   The output of the `OR` gate is then fed into an `AND` gate (V.6.6) along with `LC_VP_FUP_MES_LIM_ENA`.
    *   **Output:** `LV_VP_FUP_MES_NOT_VLD` is set to `TRUE` if the fuel pressure is outside the diagnostic limits AND the limiting feature is enabled. This flag indicates the invalidity of the measurement.

2.  **Rate Limiting of Measured Fuel Pressure (Middle Section):**
    *   The raw `VP_FUP_MES` signal is passed through a rate limiter block (V.7.3).
    *   `C_FUP_MES_LIM_INC` defines the maximum allowable positive rate of change (increment).
    *   `IP_FUP_MES_LIM_DEC` defines the maximum allowable negative rate of change (decrement).
    *   The output of this rate limiter, `x_out`, represents the smoothed and rate-limited fuel pressure.
    *   **Output:** This `x_out` signal is directly assigned to `[fup_lih]` and also used as the intermediate `<FUP>` signal that feeds into the final calculation stage.

3.  **Low-Pressure Indication / Request Logic (Bottom Left - part of Low Pressure path):**
    *   The validity flag `[LV_VP_FUP_MES_NOT_VLD]` (likely a re-routed or inverted version of the diagnostic output), `<LV_FUP_MES_LIH_REQ>`, and `<LV_FUP_LIH_H_PRS_CTL_REQ>` are combined in an `OR` gate (V.6.3).
    *   The output of this `OR` gate acts as a control signal for a `CHECK~=0` block (V.6.6). This block likely conditionally passes or modifies the `[fup_lih]` signal based on these requests.
    *   The `[fup_lih]` signal (from the rate limiter) also directly enters this `CHECK~=0` block.

4.  **Final Fuel Pressure Calculation (Bottom Right):**
    *   **Adjusted Setpoint:** The commanded fuel pressure `<MFF_SP_FUP_CTL>` is adjusted by subtracting `C_FUP_EFP_OFS_RED` and `<FUP_EFP>` using a sum/subtract block (V.7.2). This adjusted setpoint is then processed by a `CHECK~=0` block (V.6.6).
    *   **Calibration Factor Processing:** The constant `C_FUP_MES_CRLC` is processed by another `CHECK~=0` block (V.6.6).
    *   **Combination:** The outputs of these two `CHECK~=0` blocks are combined in a division block (indicated by the `+/-` symbol and the two inputs, with the top input being divided by the bottom one).
    *   **Offset Addition:** The result of this division is then summed with `<FUP_AD_OFS>` and another signal from the low-pressure path (likely an output of the controlled `CHECK~=0` block that processes `[fup_lih]`). This sum is labeled as `y` in the final gain block.
    *   **Final Gain/Scaling:** The signal `y` is fed into a block (V.5.3) which also takes an input `m` (likely a gain or a slope) and `<FUP>` (the rate-limited intermediate value).
    *   **Output:** The block V.5.3 outputs the final `FUP` value. This block likely applies a final scaling or correction based on `y`, `m`, and the rate-limited `<FUP>`.


--- Page 86 ---

This page contains a Simulink-style block diagram, characteristic of model-based design in automotive embedded systems.

## Function
The primary function of this module, titled "FUSL, Fuel pressure (Appl. Inc.)", is to manage and control fuel pressure, specifically focusing on adaptation and supervision of minimum fuel pressure values. It handles both the initialization and operational aspects of this fuel pressure management, incorporating various sensor inputs, system states, and adaptation parameters to produce corrected fuel pressure values and related status flags.

## Inputs
The diagram identifies several key inputs, categorized as initialization parameters, operational signals, and feedback.

**Initialization Parameters (Orange block, top left):**
*   `RST`: Reset signal/flag.
*   `ES2ERU`: (Likely) Electrical system related status or mode.
*   `NVMINI`: Non-volatile memory initialization status.
*   `NVMRES`: Non-volatile memory reset status.
*   `NVMSTO`: Non-volatile memory storage status.

**Operational Signals (Green blocks, left side):**
*   `<CYC_CAST>`: System cycle counter or casting variable.
*   `<CYC_ST>`: System cycle state.
*   `<FUP>`: Raw fuel pressure input.
*   `<FUP_EFP>`: Effective fuel pressure.
*   `<FUP_MES>`: Measured fuel pressure.
*   `<LV_ES>`: Level of electric supply (e.g., battery voltage status).
*   `<LV_FUP_AD_ENA>`: Enable flag for fuel pressure adaptation.
*   `<LV_FUP_MES_LIH_REQ>`: Request to inhibit low-level fuel pressure measurement.
*   `<LV_FUP_MIN_AD_ENA>`: Enable flag for minimum fuel pressure adaptation.
*   `<LV_FUP_MIN_AD_INH>`: Inhibit flag for minimum fuel pressure adaptation.
*   `<LV_FUP_MIN_AD_OFS_DIS>`: Disable flag for minimum fuel pressure adaptation offset.
*   `<LV_FUP_MIN_AD_OLD>`: Previous value for minimum fuel pressure adaptation.
*   `<LV_FUP_MIN_AD_MEM>`: Memory (stored) value for minimum fuel pressure adaptation.
*   `<LV_MFF_CST_FUP_ACT>`: Status for mass fuel flow constant fuel pressure active.
*   `<LV_STST_STOP_CYC>`: Status for start-stop cycle (engine start/stop events).
*   `<LV_ST_INJ_AUTH>`: Status for injection authorization.
*   `<TCO>`: Coolant temperature.
*   `<TCO_ST>`: Coolant temperature state.
*   `<T_AST>`: Ambient temperature.

**Interface/Feedback Inputs:**
*   `fc_INI`: Function call interface for initialization (passed to INIT X.1).
*   `<input>`: Generic input port, likely a bus or struct containing various signals, for both INIT and OPM blocks.
*   `<feedback>`: Generic feedback port, likely for internal state propagation, for both INIT and OPM blocks.
*   `fc_OPM`: Function call interface for operational mode (passed to OPM X.2).

## Outputs
The outputs (blue blocks, right side) represent the results of the fuel pressure management logic.

*   `CTR_FUP_MIN_AD`: Counter for minimum fuel pressure adaptation.
*   `FUP_AD_OFS`: Fuel pressure adaptation offset.
*   `FUP_MIN_AD`: Adapted minimum fuel pressure value.
*   `FUP_MIN_AD_TMP`: Temporary minimum fuel pressure adaptation value.
*   `FUP_SUB`: Subtracted/compensated fuel pressure (a derived or corrected pressure value).
*   `IDX_FUP_MIN_AD`: Index for minimum fuel pressure adaptation.
*   `ID_FUP_MIN_AD`: Identifier for minimum fuel pressure adaptation.
*   `LV_FUP_AD_AUTH`: Status indicating if fuel pressure adaptation is authorized.
*   `LV_FUP_AD_INH`: Status indicating if fuel pressure adaptation is inhibited.
*   `LV_FUP_MIN_AD_ACT`: Status indicating if minimum fuel pressure adaptation is active.
*   `LV_FUP_MIN_AD_ENA`: Status indicating if minimum fuel pressure adaptation is enabled.
*   `LV_ST_INJ_AUTH_OLD`: Previous status of injection authorization.

## Logic Flow

The system's logic flow is divided into two main execution phases: Initialization and Operational Mode, represented by the "INIT X.1" and "OPM X.2" blocks, respectively.

1.  **Initialization Phase (INIT X.1):**
    *   This block is responsible for setting up the initial conditions and states of the fuel pressure management system.
    *   It receives function call input `fc_INI` along with system initialization parameters (`RST`, `ES2ERU`, `NVMINI`, `NVMRES`, `NVMSTO`). These parameters are crucial for establishing the system's state upon startup or reset, potentially restoring values from non-volatile memory or setting default values.
    *   It also takes some operational inputs (via `<input>` and specific green blocks like `<CYC_CAST>`, `<CYC_ST>`, `<FUP>`) to potentially establish initial fuel pressure related states or calculations based on current conditions.
    *   `feedback` indicates that it might also rely on or update internal states.
    *   The specific outputs of the INIT block are not explicitly shown to connect to external signals in this diagram, but it's implied that its internal states or derived values are then used by the OPM block or other parts of the system. Its primary role is to ensure a stable and consistent starting point for the fuel pressure logic.

2.  **Operational Phase (OPM X.2):**
    *   This is the core functional block responsible for continuous fuel pressure management during normal vehicle operation.
    *   It receives `fc_OPM` for its function call and a wide array of inputs from the green blocks. These inputs cover fuel pressure measurements (`<FUP>`, `<FUP_EFP>`, `<FUP_MES>`), various enable/inhibit flags for adaptation (`<LV_FUP_AD_ENA>`, `<LV_FUP_MIN_AD_ENA>`, `<LV_FUP_MIN_AD_INH>`, etc.), temperature values (`<TCO>`, `<T_AST>`), and system states (`<CYC_ST>`, `<LV_ST_INJ_AUTH>`, `<LV_STST_STOP_CYC>`).
    *   Based on these inputs, the OPM block performs complex calculations and logical decisions to:
        *   **Calculate and Adapt Fuel Pressure:** Determine and update `FUP_AD_OFS`, `FUP_MIN_AD`, and `FUP_MIN_AD_TMP`. This suggests an adaptive control strategy where the minimum required fuel pressure or its offset is adjusted over time based on operating conditions and potentially long-term learning (implied by `_MEM` inputs).
        *   **Supervise Adaptation Status:** Output various status flags such as `LV_FUP_AD_AUTH`, `LV_FUP_AD_INH`, `LV_FUP_MIN_AD_ACT`, `LV_FUP_MIN_AD_ENA` to indicate the current state and authorization of the adaptation processes.
        *   **Provide Corrected Pressure:** Generate `FUP_SUB`, which is likely a modified or compensated fuel pressure value used by other engine control modules.
        *   **Manage Adaptation Meta-data:** Update `CTR_FUP_MIN_AD`, `IDX_FUP_MIN_AD`, and `ID_FUP_MIN_AD`, which could be used for tracking adaptation cycles, selecting adaptation maps, or identifying specific adaptation strategies.
    *   The `feedback` port implies that the OPM block also maintains internal states that are fed back into its own calculations for subsequent execution cycles.

The overall function "FUSL" operates recurrently based on the specified schedule: "SEG, 10MS, FIRST_TOOTH", meaning it runs on specific engine segments, every 10 milliseconds, and/or upon the detection of the "first tooth" of an engine speed signal, indicating real-time control within the ECU. Its activation is "always" and deactivation "never", signifying continuous operation during vehicle runtime, only ceasing with the ECU itself.


--- Page 87 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram's primary function is to determine a minimum fuel pressure setpoint (`FUP_MIN_AD`) and related status flags during engine initialization, specifically during the transition from engine stop to engine run, and upon system reset. It achieves this by performing a 1D lookup based on an engine operating state or temperature status (`TCO_ST`) and stores historical values of key signals.

## Inputs
*   `<TCO_ST>`: An input representing the engine's operating state or temperature status.
*   `<ID_FUP_MIN_AD>`: The data for the 1-dimensional lookup table that defines the minimum fuel pressure based on `TCO_ST`.
*   `<FUP>`: The current fuel pressure value.
*   `<LV_ST_INJ_AUTH>`: A logical flag indicating the authorization status of the fuel injector.

## Outputs
*   `<IDX_FUP_MIN_AD>`: The calculated index used for the lookup in the `ID_FUP_MIN_AD` table.
*   `<FUP_MIN_AD>`: The calculated minimum fuel pressure value, obtained from the 1D lookup table.
*   `<LV_FUP_AD_AUTH>`: A logical flag, likely indicating the authorization status of the minimum adiabatic fuel pressure. (The exact derivation is not fully visible in this snippet).
*   `<LV_FUP_AD_INH>`: A logical flag, likely indicating the inhibition status of the minimum adiabatic fuel pressure. (The exact derivation is not fully visible in this snippet).
*   `FUP_OLD`: The fuel pressure value from the previous time step.
*   `FUP_MIN_AD_TMP`: A temporary or delayed version of the index used for the `FUP_MIN_AD` lookup.
*   `LV_ST_INJ_AUTH_OLD`: The injector authorization status from the previous time step.

## Logic Flow

1.  **Engine State Index Calculation:** The input `<TCO_ST>` is fed into an `IndexSearch` block (labeled `IndexSearch Axis: LDPM_TCO_ST_FUP_MIN_AD V.6.8`). This block determines an index (`<IDX_FUP_MIN_AD>`) along a predefined axis based on the value of `<TCO_ST>`. This index represents the position in the lookup table corresponding to the current engine state.

2.  **Minimum Fuel Pressure Lookup:**
    *   The calculated index (`<IDX_FUP_MIN_AD>`), after passing through a unit delay block (labeled `V.6.1`), becomes the `x_frac` (fractional index) input to a 1D lookup table block (labeled `ID_CURVE_Array ID_FUP_MIN_AD V.7.3`).
    *   The `ID_CURVE_Array` block uses the `ID_FUP_MIN_AD` data as its table values.
    *   The lookup table then interpolates or selects a value based on the `x_frac` input, and this output (`ID_val`) is designated as `<FUP_MIN_AD>`, the calculated minimum fuel pressure.

3.  **Historical Data Storage:**
    *   The current fuel pressure input `<FUP>` is passed through a unit delay block (`V.6.1`) to store its value from the previous time step, output as `FUP_OLD`.
    *   Similarly, the injector authorization status input `<LV_ST_INJ_AUTH>` is passed through a unit delay block (`V.6.1`) to store its previous value, output as `LV_ST_INJ_AUTH_OLD`.
    *   The fractional index signal, before entering the `ID_CURVE_Array` block, is also passed through a separate unit delay block (`V.6.1`) to store a delayed version of this index, output as `FUP_MIN_AD_TMP`.

4.  **Logical Flag Outputs (Partially Visible):** Two logical flags, `<LV_FUP_AD_AUTH>` and `<LV_FUP_AD_INH>`, are shown as outputs. While their direct computation logic from the visible inputs is not entirely clear from this snippet, they are likely derived from `<TCO_ST>`, constants (like the `0` block), and potentially other internal logic, influencing the authorization and inhibition of the minimum adiabatic fuel pressure.


--- Page 89 ---

This page contains two Simulink diagrams, both related to fuel pressure adaptation.

## Function

This system's primary function is to calculate a **fuel pressure adaptation offset (`FUP_AD_OFS`)** for an automotive system. It first determines if such an **adaptation is authorized (`LV_FUP_AD_AUTH`)** based on various measured parameters and system states. If authorized, it then calculates a compensation value by comparing measured fuel pressure against an expected value, while incorporating rate limiting and saturation to ensure stable and safe operation within defined bounds. This adaptation likely aims to correct deviations in the low-pressure fuel circuit.

## Inputs

The key inputs to this system are:

*   **`<FUP_MES>`**: Measured fuel pressure (float).
*   **`<TCO>`**: Measured coolant temperature (float).
*   **`<LV_FUP_AD_ENA>`**: Boolean flag indicating if fuel pressure adaptation is generally enabled.
*   **`<LV_FUP_AD_INH>`**: Boolean flag indicating if fuel pressure adaptation is inhibited.
*   **`<LV_STST_CYC>`**: Boolean flag indicating if the vehicle is in a Start-Stop cycle.
*   **`<FUP_EFP>`**: Expected fuel pressure (float).
*   **`C_FUP_MES_AD_TOL`**: Constant representing the tolerance for measured fuel pressure for adaptation (float).
*   **`C_TCO_FUP_AD_TOL`**: Constant representing the upper tolerance for coolant temperature for adaptation (float).
*   **`C_TCO_FUP_AD_BOL`**: Constant representing the lower boundary for coolant temperature for adaptation (float).
*   **`C_FUP_AD_COR`**: Constant used for correcting the expected fuel pressure in the adaptation calculation (float).
*   **`C_FUP_AD_MAX`**: Constant representing the maximum allowed fuel pressure adaptation offset (float).
*   **`C_FUP_AD_MIN`**: Constant representing the minimum allowed fuel pressure adaptation offset (float).

## Outputs

The key outputs from this system are:

*   **`<LV_FUP_AD_AUTH>`**: A boolean flag indicating whether fuel pressure adaptation is currently authorized.
*   **`<FUP_AD_OFS>`**: The calculated fuel pressure adaptation offset (float).

## Logic Flow

The system operates in two main stages: Authorization and Offset Calculation.

**Stage 1: Calculation of Fuel Pressure Adaptation Authorization (`LV_FUP_AD_AUTH`)**

1.  **Measured Fuel Pressure Check**: The measured fuel pressure (`<FUP_MES>`) is compared to a tolerance constant (`C_FUP_MES_AD_TOL`). The condition `FUP_MES <= C_FUP_MES_AD_TOL` must be true, implying adaptation is only allowed if the pressure is not excessively high.
2.  **Coolant Temperature Range Check**: The measured coolant temperature (`<TCO>`) is checked to be within a specific range defined by `C_TCO_FUP_AD_BOL` and `C_TCO_FUP_AD_TOL`. The condition `C_TCO_FUP_AD_BOL <= TCO <= C_TCO_FUP_AD_TOL` must be true.
3.  **Adaptation Enable Check**: The system checks if the adaptation is generally enabled (`<LV_FUP_AD_ENA>` must be true).
4.  **Adaptation Inhibit Check**: The system checks if the adaptation is *not* inhibited (`<LV_FUP_AD_INH>` must be false, i.e., `NOT LV_FUP_AD_INH`).
5.  **Start-Stop Cycle Check**: The system checks if the vehicle is *not* in a Start-Stop cycle (`<LV_STST_CYC>` must be false, i.e., `NOT LV_STST_CYC`).
6.  **Final Authorization**: All five conditions from steps 1-5 are combined using an `AND` logical operator. If all conditions are true, then `<LV_FUP_AD_AUTH>` is set to true, authorizing the fuel pressure adaptation.

**Stage 2: Calculation of Fuel Pressure Adaptation Offset (`FUP_AD_OFS`)**

1.  **Raw Offset Calculation**:
    *   The expected fuel pressure (`<FUP_EFP>`) is adjusted by adding the `C_FUP_AD_COR` constant.
    *   This adjusted expected pressure is then subtracted from the measured fuel pressure (`<FUP_MES>`). The result represents the raw deviation or error: `Raw_Offset = FUP_MES - (FUP_EFP + C_FUP_AD_COR)`.
2.  **Conditional Update**: The `Raw_Offset` is passed through a block that acts as a conditional updater. This block's output is updated with the `Raw_Offset` *only when* `<LV_FUP_AD_AUTH>` (calculated in Stage 1) is true. When `LV_FUP_AD_AUTH` is false, the block likely holds its last valid output value, preventing the adaptation offset from changing without authorization. The "Check ~= 0" block implies a logic for updating/holding the value depending on the enable signal.
3.  **Rate Limiting**: The conditionally updated offset value is then fed into a rate limiter. This block limits the maximum rate at which the adaptation offset can change, preventing sudden or excessively fast corrections, which could lead to system instability.
4.  **Saturation (Min/Max Limiting)**: The rate-limited offset value is then subjected to saturation limits:
    *   It is first compared against `C_FUP_AD_MIN` using a `max` function, ensuring the offset does not drop below the minimum allowed value.
    *   The result of this `max` operation is then compared against `C_FUP_AD_MAX` using a `min` function, ensuring the offset does not exceed the maximum allowed value.
    *   This two-step process clamps the adaptation offset within the valid range [`C_FUP_AD_MIN`, `C_FUP_AD_MAX`].
5.  **Final Offset Output**: The final, rate-limited and saturated value is output as `<FUP_AD_OFS>`, which is the fuel pressure adaptation offset used by other parts of the engine control system.


--- Page 90 ---

This page contains two Simulink diagrams, "Figure 43.7.7: Application of adapted values" and "Figure 43.7.8: Enabling of fuel pressure minimum adaptation", which together describe a system for adapting minimum fuel pressure.

## Function

The primary function of these Simulink diagrams is to calculate and apply an adapted minimum fuel pressure value and to control the enabling and disabling of this adaptation process. Figure 43.7.7 focuses on the actual calculation and application of the adapted value, while Figure 43.7.8 manages the complex logic for when this adaptation should be enabled or disabled, and also derives an index for the calculation.

## Inputs

**Common/External Inputs:**

*   `<TCO_ST>`: An engine operating status or condition signal, used to derive an index for the adaptation lookup.
*   `<CYC_CAST>`: A cycle counter or timer signal, likely related to engine operation time.
*   `<CYC_ST>`: Another cycle counter or status signal, used in combination with `CYC_CAST`.
*   `C_CYC_ST_OFS_FUP_MIN_AD`: A constant offset applied to the cycle counter summation.
*   `<CLC_ST_OPS_FUP_MIN_AD>`: A signal representing operational cycles or status relevant to fuel pressure minimum adaptation.
*   `<LV_MFF_CST_FUP_ACT>`: A master flag or command indicating whether fuel pressure adaptation is actively commanded.
*   `<LV_ST_INJ_AUTH>`: The current boolean status of fuel injection authorization.
*   `<LV_FUP_MIN_AD_ENA>`: A general enable signal for the fuel pressure minimum adaptation logic.
*   `<LV_FUP_MIN_AD_ACT>`: A status signal indicating if the fuel pressure minimum adaptation is currently active or performing its core function.
*   `<ID_FUP_MIN_AD>`: This represents the 1D lookup table data itself, containing the adapted fuel pressure values as a function of an index.

## Outputs

**Common/External Outputs:**

*   `<clc_fup_min_ad>`: The final calculated and applied minimum fuel pressure adaptation value. This value is potentially held in memory when adaptation is not enabled.
*   `<IDX_FUP_MIN_AD>`: An index or independent variable derived from `TCO_ST`, used as an input to the adaptation lookup table.
*   `<LV_FUP_MIN_AD_ENA_MEM>`: The latched (memory) state of the fuel pressure minimum adaptation enable. This signal indicates whether the system is currently authorized to perform/apply adaptation.
*   `<LV_ST_INJ_AUTH_OLD>`: The previous state of the fuel injection authorization signal, stored for detecting changes.

## Logic Flow

The logical flow can be broken down into two main parts, corresponding to the two diagrams:

### Figure 43.7.7: Application of Adapted Values

1.  **Adaptation Indexing:** The signal `<IDX_FUP_MIN_AD>` (which is calculated in Figure 43.7.8) serves as the input index to the `ID_FUP_MIN_AD` block (V.7.3).
2.  **Adapted Value Lookup:** The `ID_FUP_MIN_AD` block, which is a 1D lookup table, calculates an adapted fuel pressure value, labeled `FUP_MIN_AD`, by interpolating or directly retrieving a value based on the input `<IDX_FUP_MIN_AD>`.
3.  **Conditional Application:** The newly calculated `FUP_MIN_AD` is then conditionally passed through to the output `<clc_fup_min_ad>`.
    *   If `<clc_fup_min_ad_ena_mem>` (the latched enable signal from Figure 43.7.8) is true, the `FUP_MIN_AD` from the lookup table becomes the new `<clc_fup_min_ad>`.
    *   If `<clc_fup_min_ad_ena_mem>` is false, the existing value of `<clc_fup_min_ad>` is retained, effectively holding the last adapted value. The `clc_fup_min_ad` block itself acts as a memory or state-holding element.

### Figure 43.7.8: Enabling of Fuel Pressure Minimum Adaptation

1.  **Index Calculation (`IDX_FUP_MIN_AD`):**
    *   The `<TCO_ST>` signal is fed into an `IndexSearch` block (V.6.8). This block, configured with `Axis: LDPM_TCO_ST_FUP_MIN_AD`, determines and outputs the index `<IDX_FUP_MIN_AD>`. This index is then used by the adaptation value calculation in Figure 43.7.7.

2.  **Injection Authorization History (`LV_ST_INJ_AUTH_OLD`):**
    *   The current fuel injection authorization status `<LV_ST_INJ_AUTH>` is passed through a memory block (V.6.4).
    *   This block outputs `<LV_ST_INJ_AUTH_OLD>`, which represents the value of `<LV_ST_INJ_AUTH>` from the previous time step, and stores the current `<LV_ST_INJ_AUTH>` for the next cycle. This is crucial for detecting changes in injection authorization (e.g., a rising edge).

3.  **Adaptation Enable Memory Logic (`LV_FUP_MIN_AD_ENA_MEM`):**
    *   The core of this section is an SR-Latch/Flip-Flop (FF, V.6.7) whose `Q` output is `<LV_FUP_MIN_AD_ENA_MEM>`, representing the latched enable state for adaptation.
    *   **SET Condition:** The `SET` input of the Flip-Flop is driven by an `AND` gate (V.6.6), meaning the FF is set (and `<LV_FUP_MIN_AD_ENA_MEM>` becomes true) only if *all* of the following conditions are simultaneously met:
        *   **Cycle Duration:** (`<CYC_CAST>` + `<CYC_ST>` + `C_CYC_ST_OFS_FUP_MIN_AD`) > `<CLC_ST_OPS_FUP_MIN_AD>`: Ensures a minimum operating time or number of cycles has elapsed.
        *   **Injection Authorization Status:** A condition derived from block V.6.4 and `<LV_ST_INJ_AUTH>`. This typically implies a rising edge detection (injection just became authorized) or `LV_ST_INJ_AUTH` being active under specific circumstances (e.g., when it was previously inactive).
        *   **Master Activation:** `<LV_MFF_CST_FUP_ACT>` is true (an explicit command to activate adaptation).
        *   **General Enable:** `<LV_FUP_MIN_AD_ENA>` is true (a general system-level enable).
        *   **Adaptation Active:** `<LV_FUP_MIN_AD_ACT>` is true (the adaptation process is currently considered active).
        *   **Self-Holding Feedback:** The current state of `<LV_FUP_MIN_AD_ENA_MEM>` is fed back into the `AND` gate. This creates a self-holding mechanism; once enabled, it tends to remain enabled as long as other conditions are met, even if a transient trigger disappears.
    *   **RESET Condition:** The `RST` input of the Flip-Flop is directly connected to `<LV_FUP_MIN_AD_ACT>`.
        *   This means if `<LV_FUP_MIN_AD_ACT>` becomes true (signifying that the adaptation has entered its "active" phase, or perhaps completed a cycle), the Flip-Flop is reset, making `<LV_FUP_MIN_AD_ENA_MEM>` false. This suggests that `<LV_FUP_MIN_AD_ENA_MEM>` acts as a transient "permission to adapt" signal, which is cleared once the actual adaptation activity begins or concludes.


--- Page 91 ---

This page contains two Simulink diagrams, which describe the "Enabled and disabled fuel pressure minimum adaptation" logic. I will analyze the top-level diagram (Figure 43.7.9) as the primary function, and then describe Figure 43.7.10 as the detailed implementation of one of its sub-components.

---

## Function
The primary function of this Simulink diagram (Figure 43.7.9) is to manage the adaptation of a minimum fuel pressure value in an automotive system. It implements a conditional logic that switches between an "enabled" adaptation mode and a "disabled" adaptation mode based on a control flag. The goal is to produce an adapted minimum fuel pressure value and associated state variables for subsequent use in the fuel pressure control strategy.

## Inputs
The system takes the following key inputs:

*   **`clc_fup_min_ad_ena_mem`**: A boolean or logical signal that determines whether the fuel pressure minimum adaptation is enabled (true) or disabled (false). This acts as the control signal for the 'If-Else' logic.
*   **`<input>` (Bus)**: This is a bus grouping multiple signals representing current measurements and parameters required for adaptation. These include:
    *   `FUP`: Current Fuel Pressure.
    *   `FUP_OLD`: Fuel Pressure from the previous control cycle.
    *   `FUP_MIN_AD_TMP`: A temporary value for the minimum adapted fuel pressure.
    *   `ID_FUP_MIN_AD`: An identifier or flag related to the adaptation process.
    *   `LV_FUP_MIN_AD_ACT`: The actual active level or value of the minimum adapted fuel pressure.
    *   `CTR_FUP_MIN_AD`: A counter specifically for the minimum fuel pressure adaptation.
    *   `IDX_FUP_MIN_AD`: An index or threshold value used within the adaptation logic.
*   **`<feedback>` (Bus)**: This is another bus containing state variables or feedback signals from the previous control cycle. Its contents are similar to `<input>`, indicating that many of the processed values are persistent states updated each cycle. The specific signals identified are: `IDX_FUP_MIN_AD`, `FUP`, `ID_FUP_MIN_AD`, `LV_FUP_MIN_AD_ACT`, `CTR_FUP_MIN_AD`, and `FUP_OLD`.

## Outputs
The system produces a single output bus:

*   **`clc_id_fup_min_ad` (Bus)**: This bus merges all the adapted fuel pressure minimum values and related state variables resulting from the chosen adaptation path. It contains the following signals:
    *   `FUP_OLD`
    *   `FUP_MIN_AD_TMP`
    *   `LV_FUP_MIN_AD_ACT`
    *   `CTR_FUP_MIN_AD`
    *   `ID_FUP_MIN_AD`
    *   `FUP_MIN_AD_ENA` (Likely a status signal indicating the outcome of the 'enabled' path, not the enable flag itself.)
    *   `IDX_FUP_MIN_AD`

## Logic Flow

The overall logic flow is based on a conditional execution determined by the `clc_fup_min_ad_ena_mem` signal.

1.  **Mode Selection:**
    *   The `cond_if` (V.6.0) block acts as an 'If-Else' conditional switch.
    *   It evaluates the `clc_fup_min_ad_ena_mem` signal.
    *   **If `clc_fup_min_ad_ena_mem` is true (non-zero):** The "enabled" adaptation path is selected, and the `FUP_MIN_AD_ENA` sub-system (referenced as `X.2.2.1.3.1`) is executed.
    *   **If `clc_fup_min_ad_ena_mem` is false (zero):** The "disabled" adaptation path is selected, and the `FUP_MIN_AD_DI` sub-system (referenced as `X.2.2.1.3.2`) is executed.

2.  **Enabled Adaptation Path (Detailed in Figure 43.7.10 - `FUP_MIN_AD_ENA`):**
    *   This sub-system takes current (`FUP`) and historical (`FUP_OLD`, `FUP_MIN_AD_TMP`, `CTR_FUP_MIN_AD`, `ID_FUP_MIN_AD`, `IDX_FUP_MIN_AD`) fuel pressure and adaptation state values as inputs.
    *   **`FUP_OLD` Update:** The current `FUP` signal is passed through a Unit Delay block (V.6.1) to become the `FUP_OLD` for the *next* simulation step, effectively capturing the previous fuel pressure.
    *   **Pressure Drop Detection:** The current `FUP` is compared with `FUP_OLD` using a "less than" comparator (V.6.2). A true output indicates a drop in fuel pressure.
    *   **Debounce/Threshold Logic (`V.7.3` and `V.6.3`):** The output of the pressure drop comparison, along with `IDX_FUP_MIN_AD` (likely a threshold or duration for debouncing), feeds into a stateful block (V.7.3, which often represents a debouncer, rate limiter, or state-holding logic). A `NOT` gate (V.6.3) in a feedback loop with `V.7.3` suggests logic for resetting or modifying the debounced state. The output `x_out` from V.7.3 indicates a sustained or validated pressure drop condition.
    *   **State and Counter Management:**
        *   The `x_out` signal (debounced pressure drop) is used, along with existing `ID_FUP_MIN_AD` and `CTR_FUP_MIN_AD` values, to update `ID_FUP_MIN_AD` and `CTR_FUP_MIN_AD`.
        *   A multi-input switch-like block (e.g., U1 -> Y, U2 -> Y(E)) and a `Check ~= 0` block (V.6.6) determine the new values. This typically means `ID_FUP_MIN_AD` might be set to indicate an active adaptation, and `CTR_FUP_MIN_AD` might be incremented, decremented, or reset to `C_CTR_FUP_MIN_AD_INI` based on the detected pressure dynamics and adaptation state.
    *   **`FUP_MIN_AD_TMP` Adaptation:** The `FUP_MIN_AD_TMP` (temporary minimum adapted pressure) is conditionally updated. If the conditions for adaptation (derived from the debounced pressure drop, counter, and ID signals) are met, `FUP_MIN_AD_TMP` is updated to the current `FUP`, establishing a new minimum.
    *   **`LV_FUP_MIN_AD_ACT` Calculation:** `LV_FUP_MIN_AD_ACT` (the actual minimum adapted fuel pressure level) is derived from the updated `FUP_MIN_AD_TMP` and/or `ID_FUP_MIN_AD`, likely representing the finalized setpoint for the current cycle.
    *   The updated values for `FUP_OLD`, `FUP_MIN_AD_TMP`, `LV_FUP_MIN_AD_ACT`, `CTR_FUP_MIN_AD`, and `ID_FUP_MIN_AD` are output from this sub-system.

3.  **Disabled Adaptation Path (`FUP_MIN_AD_DI`):**
    *   The internal logic of this sub-system (`X.2.2.1.3.2`) is not detailed in the provided image. However, typically in a "disabled" state, it would likely perform one of the following:
        *   Pass through the input values directly as outputs (no adaptation).
        *   Output fixed default values.
        *   Hold the last valid adapted values.
        *   Reset certain state variables.
    *   It also takes inputs and feedback similar to the enabled path and produces outputs for `FUP_OLD`, `LV_FUP_MIN_AD_ACT`, `CTR_FUP_MIN_AD`, `ID_FUP_MIN_AD`, and a signal named `FUP_MIN_AD_ENA`.

4.  **Output Merging:**
    *   Regardless of which path was executed (enabled or disabled), the resulting outputs from the active sub-system are fed into a `BusMerge` block.
    *   This `BusMerge` block consolidates all the individual output signals into the structured bus `clc_id_fup_min_ad`, providing a single, consistent output interface for the entire fuel pressure minimum adaptation logic. These outputs are typically stored as state variables (feedback) for the next execution cycle.


--- Page 92 ---

This page contains multiple Simulink-like diagrams. Based on the heading "43.7.2.1.3.2 Disabled fuel pressure minimum adaptation", the primary diagram for analysis will be Figure 43.7.11.

---

## Function
This Simulink diagram (Figure 43.7.11), titled "Disabled fuel pressure minimum adaptation," is designed to calculate and manage a temporary minimum fuel pressure adaptive value (`<FUP_MIN_AD_TMP>`) and store the previous fuel pressure value (`FUP_OLD`). Its core function is to select between a pre-calculated adaptive minimum fuel pressure and the current actual fuel pressure based on whether the adaptation process is actively enabled. It also provides a direct pass-through for several related control and identification signals.

## Inputs
*   **`<LV_FUP_MIN_AD_ACT>`**: (Live Value Fuel Pressure Minimum Adaptation Active) - A boolean flag indicating if the minimum fuel pressure adaptation is currently enabled or active.
*   **`<IDX_FUP_MIN_AD>`**: (Index for Fuel Pressure Minimum Adaptation) - An index value used to select a specific adaptive fuel pressure parameter or data point from a lookup structure.
*   **`<ID_FUP_MIN_AD>`**: (Identifier for Fuel Pressure Minimum Adaptation) - An identifier, possibly corresponding to a specific adaptation state, mode, or map.
*   **`<FUP>`**: (Fuel Pressure) - The current or real-time measured fuel pressure value.
*   **`<CTR_FUP_MIN_AD>`**: (Counter for Fuel Pressure Minimum Adaptation) - A counter signal, potentially used for timing, sequencing, or event counting within the adaptation logic.

## Outputs
*   **`LV_FUP_MIN_AD_ACT`**: The direct output of the adaptation active flag.
*   **`<FUP_MIN_AD_TMP>`**: (Fuel Pressure Minimum Adaptation Temporary) - The calculated temporary minimum fuel pressure value resulting from the selection logic.
*   **`FUP_OLD`**: The fuel pressure value from the previous time step.
*   **`ID_FUP_MIN_AD`**: The direct output of the adaptation identifier.
*   **`CTR_FUP_MIN_AD`**: The direct output of the adaptation counter.

## Logic Flow
1.  **Input Acquisition**: The diagram begins by receiving all specified input signals: `<LV_FUP_MIN_AD_ACT>`, `<IDX_FUP_MIN_AD>`, `<ID_FUP_MIN_AD>`, `<FUP>`, and `<CTR_FUP_MIN_AD>`.
2.  **Adaptive Value Retrieval**: The `<IDX_FUP_MIN_AD>` and `<ID_FUP_MIN_AD>` signals are fed into a block labeled `V.6.9` (represented by `[..]`). This block likely functions as a Selector or a multi-dimensional Lookup Table. Its purpose is to retrieve a specific adaptive minimum fuel pressure value (let's call this `AdaptedMinPressure`) based on the provided index and identifier.
3.  **Old Fuel Pressure Storage**: The current `<FUP>` (Fuel Pressure) signal is passed as input to a Unit Delay block (the H-shaped component within `V.6.6`). This block delays its input by one sample time, effectively storing the value of `<FUP>` from the previous time step, which is then output as `FUP_OLD`.
4.  **Temporary Minimum Fuel Pressure Selection**:
    *   A Switch block (the T-shaped component within `V.6.6`, labeled "Check ~= 0") is used to determine the value of `<FUP_MIN_AD_TMP>`.
    *   This Switch block has three inputs:
        *   The top input is the `AdaptedMinPressure` value from block `V.6.9`.
        *   The middle input is the current `<FUP>` value.
        *   The control input for the switch is `<LV_FUP_MIN_AD_ACT>`.
    *   The logic of the switch is: If `<LV_FUP_MIN_AD_ACT>` is true (i.e., its value is non-zero, indicated by "Check ~= 0"), the Switch selects and outputs the `AdaptedMinPressure` (the top input).
    *   If `<LV_FUP_MIN_AD_ACT>` is false (i.e., its value is zero), the Switch selects and outputs the current `<FUP>` value (the middle input).
    *   The chosen value becomes the `<FUP_MIN_AD_TMP>` output.
5.  **Direct Signal Pass-Through**: The input signals `LV_FUP_MIN_AD_ACT`, `ID_FUP_MIN_AD`, and `CTR_FUP_MIN_AD` are routed directly to output ports with the same names (without angle brackets). This typically signifies that these are signals managed or set externally and merely passed through or exposed as outputs of this subsystem.


--- Page 93 ---

This page contains a Simulink diagram, specifically two diagrams: Figure 43.7.14 showing a high-level subsystem, and Figure 43.7.15 detailing the internal logic of "Calculation of fuel pressure offset adaptation." The analysis below focuses on Figure 43.7.15, as it provides the operational details.

## Function

The primary function of this Simulink diagram is to calculate and adapt a fuel pressure offset (`FUP_AD_OFS`). According to the accompanying text, the system removes (resets) a memorized adaptation value (`FUP_AD_OFS`) towards zero with a gradient limitation when a certain fuel pressure threshold is exceeded and the adaptation is not inhibited. It also manages an inhibition flag (`LV_FUP_AD_INH`).

## Inputs

1.  **`C_FUP_AD_LGRD`**: A constant parameter defining the lower (and implicitly, upper) gradient limit for the adaptation rate. This controls how fast `FUP_AD_OFS` can change.
2.  **`LV_FUP_AD_INH`**: A boolean flag indicating the current state of inhibition for the fuel pressure offset adaptation. `true` typically means adaptation is inhibited.
3.  **`FUP_AD_OFS`**: The current memorized fuel pressure adaptation offset value. This is a state input that will be adapted.
4.  **`FUP`**: The current measured fuel pressure value.
5.  **`C_FUP_AD_TOL`**: A constant parameter defining a tolerance or threshold value for the fuel pressure.

## Outputs

1.  **`FUP_AD_OFS`**: The updated, adapted fuel pressure offset value, calculated by moving the previous offset towards zero with rate limitation or by a reset.
2.  **`LV_FUP_AD_INH`**: The updated state of the fuel pressure adaptation inhibition flag. This is a state output, indicating whether further adaptation should be inhibited.

## Logic Flow

The diagram implements a conditional adaptation mechanism for the `FUP_AD_OFS` value.

1.  **Check for Adaptation Conditions:**
    *   The current `LV_FUP_AD_INH` signal is inverted by a `NOT` gate (V.6.3). The output is `true` if adaptation is *not* inhibited.
    *   The current fuel pressure `FUP` is compared against the `C_FUP_AD_TOL` threshold by a `>` (greater than) comparator (V.6.2). The output is `true` if `FUP` exceeds the tolerance.
    *   An `AND` gate (V.6.6) combines these two conditions. Its output is `true` only if the adaptation is *not* inhibited (`NOT LV_FUP_AD_INH`) AND the fuel pressure exceeds the tolerance (`FUP > C_FUP_AD_TOL`). This boolean signal determines if the adaptation process should be active.

2.  **Adaptive Offset Calculation (V.7.3):**
    *   Block `V.7.3` is a specialized rate limiter/controller that computes the new `FUP_AD_OFS` (`x_out`).
    *   It takes the current `FUP_AD_OFS` as its `x_in` (the value to be adapted).
    *   It aims to drive `x_out` towards a target value of `0` (input `U=0`), as indicated by the text "removed... towards zero."
    *   The rate at which `x_out` can change is limited by:
        *   `LU` (Upper Limit): `C_FUP_AD_LGRD` (positive rate of change).
        *   `LD` (Lower Limit): `-C_FUP_AD_LGRD` (negative rate of change, derived by negating `C_FUP_AD_LGRD` via the `+/-` block V.6.5).
    *   The `R` (Reset) input of `V.7.3` is controlled by the `cond_if` block (V.6.0). If `R` is asserted, `x_out` is forced to `0` (its `IV` - Initial Value). If `R` is de-asserted, `x_out` will gradually move towards `0` at the rate limited by `C_FUP_AD_LGRD`.

3.  **Conditional Logic and State Update (`cond_if`, V.6.0):**
    *   This conditional subsystem receives the result of the `AND` gate (V.6.6) along with `LV_FUP_AD_INH`, the `FUP > C_FUP_AD_TOL` flag, current `FUP_AD_OFS`, and `C_FUP_AD_LGRD`.
    *   The `cond_if` block determines:
        *   **When to reset `FUP_AD_OFS` (via `R` input of V.7.3):** The output of `cond_if` connected to the `R` input of `V.7.3` dictates whether `FUP_AD_OFS` should be immediately forced to `0` or allowed to undergo rate-limited adaptation. Given the overall description of "gradient limitation," it is plausible that `cond_if` ensures `R` is de-asserted (allowing gradual change) when the `AND` gate's condition is met, and asserted only for specific reset conditions (e.g., initial state or error).
        *   **When to update `LV_FUP_AD_INH`:** Another output path from `cond_if` (via the constant `1` block V.6.4) updates the `LV_FUP_AD_INH` flag. This means `cond_if` can set `LV_FUP_AD_INH` to `1` (inhibit further adaptation) based on its internal logic (e.g., if `FUP_AD_OFS` has successfully reached zero or if other conditions warrant inhibition).

In essence, the system continuously evaluates if the fuel pressure offset should be adapted (removed towards zero). If conditions allow, it either gradually reduces the offset at a defined rate or, under specific circumstances determined by `cond_if`, immediately resets it to zero. The adaptation process itself can be inhibited by `LV_FUP_AD_INH`, which can also be set by this very function.


--- Page 95 ---

This page contains a Simulink-like signal flow diagram.

## Function
The primary function of this diagram is to acquire, synchronize, and process raw fuel pressure sensor voltage for a low-pressure fuel pump (FUSL). It handles signal acquisition at a 1ms recurrence and processes it at a 10ms recurrence, utilizing alternating buffers to prevent read/write inconsistencies between asynchronous tasks. The goal is to provide various processed and validated fuel pressure values as module outputs.

## Inputs
*   **`FUSL_M405Z_RST`**: A reset signal for the system.
*   **`<ACTION_INFR_GetVFupEfpSens>`**: The raw sensor voltage input for the fuel pump, acquired via an import action.
*   **`<LV_FUP_EFP_MES_LIH_REQ>`**: Another input signal related to fuel pressure measurement or limits.
*   **`FUSL_M405Z_1MS` (implicit trigger)**: A 1ms trigger or timing signal, generated internally to drive 1ms operations.
*   **`FUSL_M405Z_10MS` (implicit trigger)**: A 10ms trigger or timing signal, generated internally to drive 10ms operations.
*   **`fc_OPM_1MS`**: A function call or trigger signal, originating from `FUSL_M405Z_1MS`, used to activate the 1ms processing block.
*   **`fc_OPM_10MS`**: A function call or trigger signal, originating from `FUSL_M405Z_10MS`, used to activate the 10ms processing block.
*   **`opm_10ms` (feedback)**: The processed 10ms fuel pressure value, fed back into the 1ms processing block for synchronization.
*   **`opm_1ms` (feedback)**: The processed 1ms fuel pressure value, fed back into the 10ms processing block for synchronization.

## Outputs
*   **`<FUP_EFP>`**: Processed fuel pressure value.
*   **`<FUP_EFP_MES>`**: Measured/processed fuel pressure value.
*   **`<VP_FUP_EFP_MES>`**: Validated/processed fuel pressure value.
*   **`opm_1ms`**: Intermediate processed fuel pressure value at 1ms recurrence.
*   **`opm_10ms`**: Intermediate processed fuel pressure value at 10ms recurrence.

## Logic Flow
1.  **Initialization and Timing:** The system begins with a reset (`FUSL_M405Z_RST`). Independent timing blocks (`FUSL_M405Z_1MS` and `FUSL_M405Z_10MS`) generate periodic trigger signals (`fc_OPM_1MS` at 1ms and `fc_OPM_10MS` at 10ms recurrence) to synchronize subsequent processing steps.

2.  **Raw Signal Acquisition:** The raw fuel pressure sensor voltage is acquired via the `<ACTION_INFR_GetVFupEfpSens>` import action, along with another input `<LV_FUP_EFP_MES_LIH_REQ>`. These raw inputs are then routed to two parallel processing paths.

3.  **Parallel Processing (1ms and 10ms):**
    *   **1ms Processing (`OPM_1MS` - X.1):** This block receives the raw sensor input (`input`), the 1ms trigger (`fc_OPM_1MS`), and crucially, the `opm_10ms` value (processed at 10ms recurrence) and the `fc_OPM_10MS` trigger. It processes the raw data at a 1ms rate, producing an intermediate output `opm_1ms`. The input `opm_10ms` suggests it uses a synchronized or buffered value from the 10ms path.
    *   **10ms Processing (`OPM_10MS` - X.2):** This block also receives the raw sensor input (`input`), the 10ms trigger (`fc_OPM_10MS`), and the `opm_1ms` value (processed at 1ms recurrence) and the `fc_OPM_1MS` trigger. It processes the raw data at a 10ms rate, producing an intermediate output `opm_10ms`. The input `opm_1ms` suggests it uses a synchronized or buffered value from the 1ms path.

4.  **Buffer Synchronization:** The feedback loops where `opm_1ms` feeds into `OPM_10MS` and `opm_10ms` feeds into `OPM_1MS` are critical for synchronization. As stated in the accompanying text, "Two alternating pairs of buffers are used for synchronization of signal acquisition at 1ms recurrence, and signal processing at 10 ms recurrence... Thus read/write inconsistencies due to asynchronous task execution are prevented." This mechanism ensures that the faster 1ms acquisition and the slower 10ms processing can operate asynchronously without data integrity issues.

5.  **Final Output Generation:** The synchronized `opm_1ms` and `opm_10ms` values, along with other internal states (like `CTR_VP_FUP_EFP_MES`, `FUP_EFP_MMV`, `VP_FUP_EFP_RAW`, etc., as indicated in block V.6.4), are fed into a final processing stage (block V.6.4). This stage generates the three main module outputs: `<FUP_EFP>`, `<FUP_EFP_MES>`, and `<VP_FUP_EFP_MES>`, which likely represent different forms or validations of the low-pressure fuel pump's pressure.


--- Page 96 ---

This page contains multiple Simulink diagrams.

## Function
This system is designed to manage the acquisition, initialization, and buffering of fuel pressure sensor data for a low-pressure pump within an automotive system (indicated by "FUSL Fuel pressure of low pressure pump"). It orchestrates the execution of initialization routines and continuous operational signal acquisition, ensuring data is sampled, accumulated, and made available at specified recurrence rates.

## Inputs
*   **`FUISL_LPMP_RST`**: A reset signal for the low-pressure pump fuel pressure module.
*   **`FUISL_LPMP_1MS`**: A 1ms recurrence or heartbeat signal that drives the main scheduling logic.
*   **`<input>` (multiple instances)**: Generic input signals, likely representing raw sensor values or other system states.
    *   Specifically, one is connected to `INI X.1.1`.
    *   Multiple are connected to `Signal acquisition OPM X.1.2`.
*   **`ACTION_INFR_GetVfupEfpSens_T2`**: A trigger signal to initiate the acquisition of fuel pressure sensor data (voltage).
*   **`<VP_FUP_EFP_RAW>`**: The raw voltage signal from the fuel pressure sensor.
*   **`opm_10ms`**: An input to the operational signal acquisition block, possibly for configuration or a 10ms recurring input.
*   **`LV_FUP_EFP_MES_SEG`**: A signal used to select the active buffer segment for storing measurements, implying a multi-segment buffer strategy.

## Outputs
*   **`fc_INI`**: A function call trigger, signaling the execution of the initialization routine.
*   **`fc_OPM`**: A function call trigger, signaling the execution of the operational signal acquisition routine.
*   **`opm_1ms`**: The processed output signal from the operational signal acquisition, available at a 1ms rate.
*   **`ini`**: An output from the initialization process (specifically from Figure 43.8.3), likely indicating the completion or status of initialization for data storage.
*   **`CTR_VP_FUP_EFP_MES` (Data Store)**: A counter for the number of fuel pressure sensor measurements.
*   **`VP_FUP_EFP_MES_SUM` (Data Store)**: The accumulated sum of fuel pressure sensor measurements.

## Logic Flow

The system can be broken down into two main parts, Initialization/Scheduling (Figure 43.8.2) and Signal Buffering/Accumulation (Figure 43.8.3), which work in conjunction:

1.  **System Scheduling and Control (Figure 43.8.2 - `APP_CDN` Block):**
    *   The `APP_CDN V.5.13` block acts as the central scheduler and state manager for the module.
    *   It receives `FUISL_LPMP_RST` for system reset and `FUISL_LPMP_1MS` as a periodic 1ms trigger.
    *   Based on its internal configuration ("Recurrence: 1MS", "Init: RST", "Activation: always", "Deactivation: never"), it continuously generates two function call triggers: `fc_INI` (for initialization) and `fc_OPM` (for operational signal acquisition).

2.  **Initialization Routine (Figure 43.8.2 - `INI X.1.1` & Figure 43.8.3):**
    *   When the `fc_INI` trigger is activated by `APP_CDN`, the `INI X.1.1` subsystem executes. This subsystem handles the overall initialization logic.
    *   Part of this initialization is detailed in Figure 43.8.3. An `ActionImport PRM_VP_FUP_EFP` block, likely triggered by `ACTION_INFR_GetVfupEfpSens_T2`, is responsible for acquiring the raw fuel pressure sensor voltage (`<VP_FUP_EFP_RAW>`).
    *   During this process, the system initializes or updates persistent data stores. Specifically, two array data stores, `CTR_VP_FUP_EFP_MES` (for measurement count) and `VP_FUP_EFP_MES_SUM` (for the sum of measurements), are initialized. These are typically set to zero at the start.
    *   The `LV_FUP_EFP_MES_SEG` input is used to select the specific segment or index within these arrays where the initialization (or subsequent accumulation) should occur.
    *   The `ini` signal is output from this initialization phase, indicating its state or completion.

3.  **Operational Signal Acquisition (Figure 43.8.2 - `Signal acquisition OPM X.1.2`):**
    *   When the `fc_OPM` trigger is activated by `APP_CDN`, the `Signal acquisition OPM X.1.2` subsystem executes. This is the main operational phase.
    *   It receives various `<input>` signals and `opm_10ms` (potentially a 10ms recurrence signal or data).
    *   This block's primary function is to perform continuous signal acquisition and initial processing of the fuel pressure sensor data during normal operation.
    *   As described in the text "Raw voltage of sensor is accumulated for each 10 ms / segment recurrence at 1 ms sample rate. Number of considered samples is counted accordingly in active buffer selected by LV_FUP_EFP_MES_SEG.", this block (or a sub-function it calls) samples the raw sensor voltage at a 1ms rate. It then accumulates these samples (sum) and counts them for each 10ms segment, storing them into the `CTR_VP_FUP_EFP_MES` and `VP_FUP_EFP_MES_SUM` data stores, using `LV_FUP_EFP_MES_SEG` to manage the active buffer.

4.  **Output Merging and Final Signal (Figure 43.8.2):**
    *   The outputs from both the `INI X.1.1` and `Signal acquisition OPM X.1.2` blocks are channeled into a `BusMerge V.5.35` block, combining their processed data.
    *   This merged bus is then passed to a `V.6.1 opm_1ms` block (likely a final processing or output interface subsystem).
    *   The `V.6.1 opm_1ms` block generates the final output signal `opm_1ms`, which represents the continuously processed fuel pressure data at a 1ms recurrence rate.


--- Page 97 ---

This page contains a Simulink diagram illustrating a specific function within an automotive control system, likely related to fuel pressure measurement.

## Function

The primary function of this Simulink diagram is to **process and filter the raw fuel pressure sensor signal from a low-pressure fuel pump** to generate a robust and measured fuel pressure value (`CTR_VP_FUP_EFP_MES`) for the engine control unit (ECU). It likely implements a form of digital filtering or accumulation, integrating current raw sensor data with historical measurements in a periodic task (10ms recurrence).

## Inputs

1.  **`ACTION_INFR_GetVfupEfpSens_T2`**: An action or event signal (sourced from the `<input>` port) that triggers or provides data for the raw sensor voltage/pressure acquisition.
2.  **`PRM_VP_FUP_EFP`**: A parameter (likely a calibration constant or conversion factor) used by the `ACTION_INFR_GetVfupEfpSens` block during raw sensor value processing.
3.  **`LV_FUP_EFP_MES_SEG`**: A "Low Voltage Fuel Unit Pump Electric Fuel Pump Measured Segment" value. This signal is a feedback input, representing a segment of previous measurements used in the filtering logic. It comes from the `<feedback>` port.
4.  **`CTR_VP_FUP_EFP_MES_SUM`**: A "Controller Voltage Fuel Unit Pump Electric Fuel Pump Measured Sum" value. This signal is also a feedback input, representing an accumulated sum from previous calculation cycles, used for maintaining a running total or average. It comes from the `<feedback>` port.

*(Note: The `<opm_10ms>` port appears to be an abstract task trigger and does not directly carry a data signal into the shown processing logic, but rather indicates the periodic nature of the function.)*

## Outputs

1.  **`CTR_VP_FUP_EFP_MES`**: The main output, representing the "Controller Voltage Fuel Unit Pump Electric Fuel Pump Measured" value. This is the processed and filtered fuel pressure, ready for use by other ECU functions.
2.  **`opm`**: An additional output signal, potentially indicating an "operating pressure measurement" or some other derived status related to the fuel pump operation.

## Logic Flow

The diagram describes a periodic function (recurrence: 10MS) that processes fuel pressure data. The logic flow can be broken down into the following steps:

1.  **Raw Sensor Data Acquisition (Top Path):**
    *   An input trigger or data, `ACTION_INFR_GetVfupEfpSens_T2`, activates the `ACTION_INFR_GetVfupEfpSens` block.
    *   This block, utilizing the `PRM_VP_FUP_EFP` parameter, interfaces with the low-pressure fuel pump sensor to acquire and convert its raw electrical signal (e.g., voltage) into a raw fuel pressure value, outputting it as `VP_FUP_EFP_RAW`.

2.  **Previous Segment Value Processing (Lower Left Path):**
    *   The `LV_FUP_EFP_MES_SEG` signal (from feedback) enters a unit delay block (`V.6.9`, initialized to `C0`). This block holds and outputs the value of `LV_FUP_EFP_MES_SEG` from the *previous* 10ms execution cycle.
    *   The delayed `LV_FUP_EFP_MES_SEG` is then added to a constant value of `1` (from `V.6.4`) in a sum block (`V.5.4`). The result is an intermediate value, `(previous_LV_FUP_EFP_MES_SEG + 1)`. The exact purpose of adding `1` to the segment value is specific to the filter algorithm, possibly incrementing a counter or applying a specific offset.

3.  **Previous Accumulated Sum Processing (Lower Middle Path):**
    *   The `CTR_VP_FUP_EFP_MES_SUM` signal (from feedback) enters another unit delay block (`V.7.10`, initialized to `C0`). This block outputs the value of `CTR_VP_FUP_EFP_MES_SUM` from the *previous* 10ms execution cycle.

4.  **Final Summation and Output Generation (Main Vertical Line):**
    *   The three key signals – the current raw pressure `VP_FUP_EFP_RAW`, the processed segment value `(previous_LV_FUP_EFP_MES_SEG + 1)`, and the previous accumulated sum `previous_CTR_VP_FUP_EFP_MES_SUM` – are all fed into a central, thick vertical line. This structure implies a summation or accumulation of these values.
    *   The combined sum becomes the primary output signal, `CTR_VP_FUP_EFP_MES`, representing the current processed and filtered fuel pressure.
    *   This combined sum also feeds the `opm` output port.

5.  **Feedback for Next Cycle:**
    *   The newly calculated `CTR_VP_FUP_EFP_MES` (or the underlying accumulated value before final output) is internally fed back to become the `CTR_VP_FUP_EFP_MES_SUM` for the next 10ms cycle.
    *   Similarly, the current `LV_FUP_EFP_MES_SEG` for the next cycle would be determined, likely from a component of the current calculation or a specific system state update.

In essence, the diagram implements a recursive digital filter where the current measured fuel pressure (`CTR_VP_FUP_EFP_MES`) is a function of the current raw sensor input and the previously calculated internal states (`LV_FUP_EFP_MES_SEG` and `CTR_VP_FUP_EFP_MES_SUM`).


--- Page 98 ---

This page contains two Simulink diagrams, Figure 43.8.5 and Figure 43.8.6, which together describe aspects of a "Fuel pressure of low pressure pump" system.

## Function

The primary function of this system is two-fold:
1.  **Operational Mode Management and Scheduling (Figure 43.8.5):** To control the application's operational state, manage initialization, handle recurrent tasks at specified rates (10ms), and standardize signals for further processing.
2.  **Fuel Pressure Measurement Processing and Validation (Figure 43.8.6):** To acquire, accumulate, calculate, and validate fuel pressure measurements, specifically segment-based pressure values, sums, and associated counters, likely for calculating an average or overall fuel pressure.

## Inputs

**From Figure 43.8.5 (Operational Mode Management):**
*   `<FUSL_M405Z_RST>`: A reset signal for the FUSL (Fuel pressure of low pressure pump) application.
*   `<FUSL_M405Z_10MS>`: A 10ms recurrent trigger signal for the FUSL application, indicating a periodic task execution.
*   `<opm_1ms>`: An operational mode or process data signal, sampled at a 1ms rate.
*   `<input>`: An unspecified input to the `fc()` block, distinct from `<opm_1ms>`.

**From Figure 43.8.6 (Measurement Processing):**
*   `<LV_FUP_EFP_MES_SEG>`: Low Voltage Fuel Pump, Electric Fuel Pump Measured Segment value (multiple instances), likely representing individual pressure readings or data points for a specific segment.
*   `<LV_FUP_EFP_MES_SUM>`: Low Voltage Fuel Pump, Electric Fuel Pump Measured Sum, possibly a cumulative total of pressure readings.
*   `<CTR_VP_FUP_EFP_MES>`: Counter for Vapor/Volume Pressure Fuel Pump, Electric Fuel Pump Measured (multiple instances), likely tracking the number of segments or samples.

## Outputs

**From Figure 43.8.5 (Operational Mode Management):**
*   `<fc_INI>`: An initialization signal derived from the application control logic.
*   `<fc_OPM>`: An operational mode signal generated by the application control.
*   `opm_10ms`: The `<opm_1ms>` signal, downsampled or synchronized to a 10ms rate.
*   (Unnamed output from `BusMerge`): A consolidated bus containing various processed operational and status signals.

**From Figure 43.8.6 (Measurement Processing):**
*   `<VP_FUP_EFP_MES>`: The calculated Vapor/Volume Pressure, Electric Fuel Pump Measured value, typically an average or ratio.
*   `<VP_FUP_EFP_MES_SEG>`: A processed or validated segment-based pressure value.
*   `<VP_FUP_EFP_MES_SUM>`: A processed or validated sum of fuel pressure measurements.
*   `<CTR_VP_FUP_EFP_MES>`: A processed or validated counter for pressure measurements.

## Logic Flow

The system's logic can be broken down into two main parts corresponding to the two figures:

**Part 1: Operational Mode Management and Signal Standardization (Figure 43.8.5)**

1.  **Application Control (`APP_CDN`):**
    *   The central `APP_CDN` block (V.5.13) orchestrates the application's execution. It takes a reset command (`<FUSL_M405Z_RST>`) and a periodic 10ms trigger (`<FUSL_M405Z_10MS>`).
    *   Based on its internal configuration ("Recurrence: 10MS", "Init: RST", "Activation: always", "Deactivation: never"), it determines the application's state and generates an initialization signal (`fc_INI`) and an operational mode signal (`fc_OPM`).
2.  **Initialization Function (`fc()`):**
    *   The `fc()` block (X.2.1) processes `<opm_1ms>` and another input, likely performing initialization-specific logic, controlled by the `fc_INI` signal. It outputs an `ini` signal.
3.  **Signal Standardization:**
    *   The `Signal standardization` block (X.2.2) receives the `fc_OPM` signal and converts it into a standardized format or range suitable for subsequent components.
4.  **Rate Transition:**
    *   The `<opm_1ms>` signal, which operates at a 1ms rate, is passed through a rate transition (V.6.1) to produce `opm_10ms`. This indicates that the 1ms signal is either sampled or synchronized to a 10ms execution cycle.
5.  **Bus Merging:**
    *   Finally, a `BusMerge` block (V.5.35) combines `opm_10ms` and the output of the `Signal standardization` block (along with other unseen inputs) into a single logical bus. This bus likely aggregates status and control signals for the overall fuel pressure system.

**Part 2: Fuel Pressure Measurement Processing (Figure 43.8.6)**

1.  **Segmented Pressure Calculation (Upper Path):**
    *   Two instances of the `<LV_FUP_EFP_MES_SEG>` signal are fed into two "conditional hold/latch" blocks (V.6.9). The output of the top `V.6.9` block is logically inverted by a `NOT` gate (V.6.3), which then acts as a control input to the second `V.6.9` block. This setup suggests a conditional accumulation or selection of segments.
    *   The outputs of these two `V.6.9` blocks serve as the numerator and denominator for a division block (`V.7.2`). This operation likely calculates a ratio or average pressure (`<VP_FUP_EFP_MES>`) based on the segmented measurements.
    *   The calculated `<VP_FUP_EFP_MES>` is then passed through a "Check ~= 0" block (V.6.6). This block performs a validation or safety check, ensuring the calculated pressure value is not zero (e.g., to prevent division by zero errors in further processing or to indicate a fault condition). The validated output becomes the `<VP_FUP_EFP_MES_SEG>` output.

2.  **Sum and Counter Management (Lower Path):**
    *   The `<LV_FUP_EFP_MES_SUM>` input and a constant '0' are fed into a "conditional accumulation/reset" block (V.7.10). This block likely accumulates the sum of measurements, with the '0' potentially serving as an initial value or reset condition. The output becomes the `<VP_FUP_EFP_MES_SUM>` output.
    *   Similarly, the `<CTR_VP_FUP_EFP_MES>` input and a constant '0' are fed into another `V.7.10` block. This block likely manages a counter for the measurements, with '0' as an initial value or reset. The output becomes the `<CTR_VP_FUP_EFP_MES>` output.
    *   The 'u' input on the `V.7.10` blocks, though not explicitly connected to a source in this diagram, suggests an external control signal (e.g., from the operational mode management) that can trigger the reset or initialization of these accumulators/counters with the '0' value.


--- Page 99 ---

This page contains Simulink-like diagrams commonly used in automotive embedded software development (often using tools like TargetLink which share Simulink's visual conventions).

## Function
The primary function of these diagrams is to process and manage signals related to the low-pressure fuel pump (FUP_EFP) within an automotive system. Specifically, the diagrams handle the linearization and conditioning of a raw measured fuel pressure signal, calculate a modeled or monitored fuel pressure value, and subsequently apply or select values based on specific limit conditions or requests. This forms part of the overall fuel pressure control and monitoring strategy.

## Inputs
1.  **`<VP_FUP_EFP_MES>`**: Raw measured fuel pressure from the low-pressure pump sensor (likely a voltage or frequency signal that needs conversion).
2.  **`C_FUP_EFP_MES_CRLC`**: A constant or calibration parameter used in the calculation of the modeled fuel pressure, possibly defining a gain or offset for the control logic.
3.  **`<FUP_EFP_MMV>`** (input to Diagram 1): The current or previously calculated modeled/monitored fuel pressure value, used for iterative calculation or dynamic modeling.
4.  **`C_FUP_EFP_LIH`**: A constant or calibration parameter related to the low-pressure fuel pump's limit handling, possibly defining a hard limit.
5.  **`<FUP_EFP_MES_LIH_REQ>`**: A requested value or a signal indicating a specific limit handling requirement for the low-pressure fuel pump's measured value.
6.  **`<FUP_EFP_MMV>`** (input to Diagram 2): The modeled/monitored fuel pressure value, passed from the first diagram for limit handling.

## Outputs
1.  **`FUP_EFP_MES`**: The processed and linearized measured fuel pressure value, ready for use by other system components.
2.  **`FUP_EFP_MMV`**: The calculated or updated modeled/monitored value of the low-pressure fuel pump pressure. This value likely reflects a dynamically filtered or estimated pressure.
3.  **`<FUP_EFP_>`**: An output signal representing the result of the fuel pressure limit handling logic. The full signal name is truncated, but it likely represents a final limited or selected fuel pressure value.

## Logic Flow

The image contains two distinct diagrams, referred to as Figure 43.8.7 and Figure 43.8.8, which appear to be interconnected.

### Diagram 1 (Figure 43.8.7: Fuel Pressure Measurement Processing and Model Value Calculation)

1.  **Measured Pressure Linearization:**
    *   The raw measured fuel pressure signal, `<VP_FUP_EFP_MES>`, enters the `IP_FUP_EFP V.7.3` block as `x_val`. This block is depicted as a 1D lookup table (indicated by the graph symbol).
    *   The lookup table performs a linearization or conversion of the raw sensor input (e.g., voltage) into a physical pressure value, outputting `IP_val`. This is a common step to convert non-linear sensor responses into usable engineering units.
2.  **Final Processed Measured Pressure:**
    *   The `IP_val` signal then passes through block `V.6.1`. Given its shape and position, this block likely represents a simple scaling, unit conversion, or a direct pass-through, resulting in the final processed measured fuel pressure `FUP_EFP_MES`.
3.  **Modeled/Monitored Pressure Calculation (`FUP_EFP_MMV`):**
    *   The `V.7.1` block (indicated by an 'm' function symbol, suggesting a mathematical function or a specific model) is responsible for calculating or updating the `FUP_EFP_MMV`.
    *   It takes three inputs: `C_FUP_EFP_MES_CRLC` (a calibration constant) into input `m`, `<FUP_EFP_MMV>` (the existing modeled value) into input `u`, and `IP_val` (the linearized measured pressure) into input `x_in`.
    *   Based on these inputs, the `V.7.1` block computes an `x_out` which becomes the updated `FUP_EFP_MMV`. This suggests a filtering process, a dynamic model, or a comparison logic where the modeled value is continuously adjusted based on the measured pressure and system parameters.

### Diagram 2 (Figure 43.8.8: Fuel Pressure Limit Handling/Selection)

1.  **Input Gathering:**
    *   This diagram receives three inputs related to fuel pressure limits and values: `C_FUP_EFP_LIH` (a constant limit value), `<FUP_EFP_MES_LIH_REQ>` (a requested limit value or status), and `<FUP_EFP_MMV>` (the modeled/monitored pressure calculated in Diagram 1).
2.  **Conditional Selection/Processing:**
    *   These three inputs feed into block `V.6.6`, which is depicted as a multiplexer or switch-like block with the annotation "Check ~= 0".
    *   This block acts as a decision point: if the "Check" condition is not equal to 0 (i.e., true), it selects one of its inputs or performs an operation based on the inputs. If "Check" is 0 (false), it might select another. This commonly implements a fail-safe strategy, an override, or a selection between different operating modes/limits.
3.  **Output of Limit Handling:**
    *   The result of this conditional selection or processing is output as `<FUP_EFP_>`. This output represents the final fuel pressure value or status after considering various limits and requests, ensuring the system operates within defined safe or nominal boundaries.


--- Page 102 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, identified as "FUSL_M906A", is primarily responsible for calculating the **fuel pressure setpoint of the low-pressure pump**. It operates periodically every 100 milliseconds and also includes an initialization routine. It takes various engine and vehicle state parameters as inputs to determine the target fuel pressure and related diagnostic or status flags.

## Inputs
The diagram receives 15 distinct inputs, which appear to be various engine, fuel system, and vehicle state parameters:

1.  `kfflafin_w` (likely a pre-filtered fuel flow or air mass related value)
2.  `pu_w` (likely a pressure unit or raw pressure value)
3.  `B_ebks` (Boolean flag, perhaps "Electric Brake System" or similar status)
4.  `B_pbksprof` (Boolean flag, potentially "Pump Brake System Profile" or related)
5.  `B_fa` (Boolean flag, general fault or function active)
6.  `B_fabks` (Boolean flag, likely related to fuel system active or fault state)
7.  `B_hst` (Boolean flag, perhaps "Heating System Active" or "Hot Start")
8.  `tfuelmx` (Fuel temperature, mixed or maximum)
9.  `nmot_w` (Engine speed)
10. `tmst` (Engine coolant temperature or oil temperature)
11. `tmot` (Engine oil temperature or another motor temperature)
12. `tnsez_w` (Another temperature or sensor value, potentially intake air temp or exhaust temp)
13. `B_sshev` (Boolean flag, possibly "Stop-Start System Active" or related)
14. `tnse_w` (Another temperature or sensor value)
15. `B_kl15` (Ignition ON signal, terminal 15)

## Outputs
The diagram produces 4 distinct outputs:

1.  `B_kfntbks` (Boolean flag, likely "Fuel Pressure Not Bypassed" or a related status)
2.  `B_ktaabks` (Boolean flag, potentially "Fuel Pump Active Acknowledge" or another status)
3.  `kfflafinf_w` (Final filtered fuel flow or air mass related value, a processed version of input `kfflafin_w`)
4.  `pbksoll_w` (The primary output: **Low-pressure fuel pump target pressure / setpoint**)

## Logic Flow

1.  **Scheduling and Activation:**
    *   The `APP_CDN V.7.3` block is responsible for managing the activation and deactivation of the function.
    *   **Initialization (INI):** When `IGKON` (Ignition On) or `RST` (Reset) conditions are met, `APP_CDN` generates an `fc_INI` signal, triggering the `INI X.1` sub-function block. This block performs necessary one-time initialization tasks, such as setting default values or internal states for the subsequent operational logic. The output of the `INI X.1` block is fed into the main `OPM_100MS X.2` block.
    *   **Periodic Operation (OPM):** The `APP_CDN` block also generates a `fc_OPM_100MS` signal every 100 milliseconds. This signal triggers the main operational sub-function block, `OPM_100MS X.2`. The function is marked as "always" active once initialized and "never" deactivated, implying continuous operation while the system is running.

2.  **Input Gathering:**
    *   The `OPM_100MS X.2` block receives the 15 input signals from the left side. These signals provide real-time data about the engine, fuel system, and overall vehicle state (e.g., engine speed, fuel temperature, various boolean flags indicating system status).

3.  **Core Logic Execution:**
    *   Inside the `OPM_100MS X.2` block, the core algorithms for calculating the fuel pressure setpoint are executed. This block takes the current inputs, potentially the initialized states from `INI X.1`, and historical data (via the `feedback` loop) to perform its calculations.
    *   The `feedback` connection to the `OPM_100MS X.2` block suggests that the calculation might involve dynamic elements such as filtering, integration, or state-dependent logic, where previous outputs or internal states influence the current computation.

4.  **Output Management:**
    *   The results of the `OPM_100MS X.2` block's calculations (internal outputs for the fuel pressure setpoint and status flags) are passed to the `Signal Manager V.6.4` block.
    *   The `Signal Manager` acts as an interface to the rest of the system, routing and potentially scaling or formatting these internal values into the named external output signals: `B_kfntbks`, `B_ktaabks`, `kfflafinf_w`, and crucially, `pbksoll_w` (the fuel pressure setpoint).


--- Page 103 ---

This page contains a Simulink-style diagram, likely generated from a model-based development tool like TargetLink or Simulink itself, given the context of automotive embedded systems by Continental.

## Function

The primary function of this diagram, as indicated by the title "43.9.1 Initialization," is to **initialize a set of system parameters to a default value of zero**. These parameters are critical for the control of a fuel pressure system, specifically related to the "Fuel pressure setpoint of low pressure pump" (FUSL), as mentioned in the top right. This initialization ensures that the system starts in a known, safe state, typically upon power-up or a reset event.

## Inputs

In the context of this specific diagram, there are no external *variable* inputs.
*   **fc**: This block with "f()" on top and "fc" below it likely represents a function call or the execution context within which this initialization routine is performed. It acts as a trigger or a signal indicating that the initialization process should run.
*   **Constant '0' values**: While technically internal, these blocks provide the *input values* for the initialization. Each is a constant block outputting `0`. The "V. 6.4" beneath each `0` likely denotes the data type or scaling of the constant, implying these zeros are cast to a specific numerical format (e.g., fixed-point number) suitable for the target embedded controller.

## Outputs

The outputs are the initialized variables, aggregated and passed to the "ini" block. The "ini" block itself represents the completion of the initialization process, effectively outputting these initialized values to the rest of the system for use.

*   `kfflafint_w`
*   `pbksollmx_w`
*   `B_ktaabks`
*   `B_fapbksol`
*   `pbkszw_w`
*   `pbksprof_w`
*   `psrohbks_w`
*   `B_kfntbks`
*   `psstbks_w`

These are likely internal system variables or calibration parameters, all initialized to zero. The suffix `_w` often denotes working variables.

## Logic Flow

The logical flow of this initialization diagram is straightforward:

1.  **Trigger/Context**: The process is initiated within a specific function call or context, indicated by the "f() / fc" block. This implies that the initialization routine is executed when "fc" is active or called.
2.  **Constant Value Generation**: For each parameter to be initialized, a dedicated constant block is used. These blocks are hardcoded to output the value `0`. The annotation "V. 6.4" likely specifies the data type (e.g., a specific fixed-point format) to which this `0` is converted, ensuring type compatibility with the target variables.
3.  **Parameter Assignment**: The constant `0` value from each block is then routed as a signal. Each signal is explicitly named (e.g., `kfflafint_w`, `pbksollmx_w`, etc.), indicating that these are the specific variables being targeted for initialization.
4.  **Aggregation and Output**: All these zero-initialized signals converge into a single vertical black bar. This bar typically represents a "Bus Creator" block, which bundles multiple individual signals into a single bus signal, or simply a visual boundary for multiple outputs.
5.  **Initialization Completion**: This aggregated bus signal (or the individual signals if the bar is purely visual) is then passed to the block labeled "ini". This "ini" block represents the final stage or an output port of the initialization routine. It signifies that these variables have been successfully initialized to `0` and are now ready for use by other parts of the automotive control system.


--- Page 104 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "FUSL, Fuel pressure setpoint of low pressure pump", is designed to calculate and output the target fuel pressure setpoint for a low-pressure fuel pump in an automotive system. It takes into account various operational parameters, engine states (e.g., start, hot start), temperatures, engine speed, and system configuration flags to determine the highest required pressure, ensuring proper fuel supply under diverse conditions. It also incorporates limiting and error handling mechanisms.

## Inputs
The diagram receives numerous inputs representing various sensor readings, status flags, and configuration parameters:

*   **`fc`**: Function code or general control input.
*   **`kfllaflin_w`**: A weighted factor or base value for pressure calculation.
*   **`pu_w`**: Pressure unit or a base pressure value.
*   **`B_kl15`**: Status of ignition terminal 15 (power supply status, often indicating ignition ON).
*   **`B_fabks`**: Fuel pump active/status.
*   **`B_ebks`**: Electric fuel pump status.
*   **`B_pbksprof`**: Fuel pump pressure profiling enable/status.
*   **`In` (port 1)**: An external input for configuration-based setpoint selection (e.g., bitmask).
*   **`bit_sel0` / `num_dec` (internal to PSKKBKS/PSNHSLL)**: Bit selection and number of decimals for bit extraction.
*   **`B_hst`**: Hot start condition status.
*   **`tfuelmx`**: Maximum fuel temperature.
*   **`nmot_w`**: Engine speed.
*   **`tmst`**: Engine (motor) start temperature (e.g., coolant or oil temperature at engine start).
*   **`tmot`**: Engine operating temperature.
*   **`tnsez_w`**: A specific engine speed/operation value after start.
*   **`B_sshev`**: A system status flag, potentially related to engine operation or safety.
*   **`tnse_w`**: Another engine speed/operation value.

## Outputs
The primary output of the diagram is the calculated fuel pressure setpoint. There are also several internal outputs from the "Errorhandling" subsystem that likely serve as diagnostic or status flags for other parts of the system:

*   **`opm_100ms` (port 1)**: The final, calculated fuel pressure setpoint for the low-pressure pump, potentially smoothed or updated at a 100ms interval.
*   **`pbksollcor` (from Errorhandling)**: Corrected pressure setpoint, possibly based on error conditions.
*   **`B_pbksol` (from Errorhandling)**: A boolean flag related to pressure setpoint validity or status.
*   **`pbkszw_w` (from Errorhandling)**: Pressure setpoint switch-off value or status.
*   **`pbksprof_w` (from Errorhandling)**: Pressure setpoint for profiling.
*   **`psrohbks_w` (from Errorhandling)**: Raw setpoint for feedback or monitoring.
*   **`B_kfntbks` (from Errorhandling)**: Status flag related to the `KFNTPKS` calculation.
*   **`psstbks_w` (from Errorhandling)**: Pressure setpoint for start conditions.

## Logic Flow

1.  **Base Setpoint Calculation (`CALC_PBKSOLLMX`)**:
    *   The `CALC_PBKSOLLMX` subsystem (X.2.1) processes `kfllaflin_w`, `pu_w`, and `B_kl15` to establish a preliminary maximum pressure setpoint, `pbksollmx_w`. This block includes a feedback loop (signal '2') which might indicate dynamic adjustment or a controller.

2.  **Primary Setpoint Aggregation and Limiting**:
    *   The `pbksollmx_w` signal is routed to a summing junction where it is combined with a `feedback` signal (labeled '2'). The resulting signal is `<pbksoll_w>`.
    *   `<pbksoll_w>` then passes through a calibration block `PSKRMN` (V.6.4), which likely applies further scaling or mapping.
    *   The output of `PSKRMN` is fed into a `pbksoll_w_Lim` block (V.6.8), which is a saturation block that constrains the setpoint between minimum (`MN`) and maximum (`MX`) values.

3.  **Conditional Setpoint Generation**: Several parallel paths calculate alternative or overriding setpoints based on specific conditions:
    *   **Configuration-based Setpoint (`PSKKBKS`)**: The `In` signal (from port 1) is processed along with `bit_sel0` and `num_dec` by `GET BIT` logic (V.7.0). This extracts specific bits from the input, which are then checked (`Check ~= 0`, V.6.6) to enable a specific pressure value (e.g., a constant `0`). This allows for dynamic setpoint adjustments based on configuration.
    *   **Hot Start Test Setpoint (`PSNHSLL`)**: Similar `GET BIT` and `Check ~= 0` logic is applied to the `B_hst` (Hot Start status) input, and potentially combined with another input (port 1 labeled `In`) for "Freigabe Heissstart-Test" (Enable Hot Start Test). This path likely provides a specific pressure setpoint required during hot start test procedures.
    *   **Temperature-dependent Start Setpoint (`KFNTPKS`)**: A 2D lookup table `KFNTPKS` (V.7.3) determines a pressure setpoint (`IP_val`) based on `tfuelmx` (max fuel temperature) and `nmot_w` (engine speed). The description suggests this is for setpoint pressure dependent on fuel temperature and engine speed at start.
    *   **Engine Start Temperature Setpoint (`KLKFPSS`)**: A 1D lookup table `KLKFPSS` (V.7.3) calculates a pressure setpoint (`IP_val`) based on `tmst` (engine start temperature).
    *   **Engine Speed/Status Setpoint (`KFPSNS`)**: A 2D lookup table `KFPSNS` (V.7.3) calculates a pressure setpoint (`IP_val`) based on `tnsez_w` and `tnse_w` (engine speed-related values) and `B_sshev` (a status flag).

4.  **Maximum Setpoint Selection**:
    *   Multiple `Max` blocks (V.6.6) are used throughout the diagram. These blocks compare the various conditionally generated setpoints (from `PSKKBKS`, `PSNHSLL`, `KFNTPKS`, `KLKFPSS`, `KFPSNS`, and the limited `pbksoll_w`) and select the highest value. This "max" logic ensures that the fuel pump always targets the highest pressure demanded by any active condition or scenario.
    *   A relational operator (`>=`, V.6.2) compares one of the max-selected values with another signal, the result of which feeds into the Errorhandling subsystem.

5.  **Error Handling (`Errorhandling X.2.2`)**:
    *   This subsystem receives a broad range of inputs, including `pbksollmx_w`, various `B_` status flags (`B_ktaabks`, `B_ebks`, `B_pbksprof`, `B_kl15`), and a signal derived from the `Max` selection logic.
    *   It processes these inputs to detect faults, generate diagnostic information, and potentially output corrected or status-specific pressure values (`pbksollcor`, `B_pbksol`, `pbkszw_w`, `pbksprof_w`, `psrohbks_w`, `B_kfntbks`, `psstbks_w`).

6.  **Final Output**:
    *   The highest selected pressure setpoint (after all `Max` operations) is processed through a final gain block (V.6.1).
    *   The output of this gain block is then sent to the output port, labeled `opm_100ms`, representing the final fuel pressure setpoint for the low-pressure pump.


--- Page 105 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, titled "CALC_PBKSOLLMX" (Calculate PBKSoll Max) within the FUSL (Fuel Systems Logic) context, is designed to determine the **maximum setpoint for the low-pressure fuel pump (`pbksollmx_w`)**. It calculates this maximum setpoint by considering filtered fuel flow demand and a dynamic upper pressure limit, ensuring the pump operates safely and effectively.

## Inputs

1.  **`B_kl15` (Boolean):** Represents the ignition status (e.g., Terminal 15). Used to control the reset behavior of the fuel flow filter.
2.  **`kfflafin_w` (Real):** The raw, unfiltered input signal representing fuel flow demand or a related parameter.
3.  **`pu_w` (Real):** An input pressure, likely ambient pressure, with units indicated as "kPa/hPa", suggesting a need for unit conversion.
4.  **`ZKPFFLAFF` (Constant):** A parameter representing the time constant for the fuel flow filter.
5.  **`PBKSDBGV` (Constant):** A constant used in the calculation of the dynamic pressure limit.
6.  **`PBKSDBMXF` (Constant):** Another constant used in the calculation of the dynamic pressure limit.
7.  **`IP_val` (Lookup Table Data):** The 1D lookup table data that maps filtered fuel flow to a base pressure setpoint.

## Outputs

1.  **`kfflafinf_w` (Real):** The filtered fuel flow demand, derived from `kfflafin_w`.
2.  **`pbksollmx_w` (Real):** The primary output, representing the calculated maximum setpoint for the low-pressure fuel pump.

## Logic Flow

The logical flow can be broken down into three main stages: Fuel Flow Filtering, Base Pressure Determination, and Dynamic Pressure Limit Calculation, followed by the final maximum setpoint selection.

1.  **Fuel Flow Filtering:**
    *   The `B_kl15` (ignition status) signal is inverted by a `NOT` gate.
    *   The raw fuel flow demand, `kfflafin_w`, is fed as the primary input (`u`) to a filter block (V. 5.3, likely a rate limiter or a low-pass filter with reset).
    *   This filter uses `ZKPFFLAFF` as its time constant (`T`).
    *   The `NOT B_kl15` signal is connected to the filter's reset input (`R`), and `0` is set as the initial value (`IV`). This means that when the ignition is OFF (`B_kl15` is FALSE, thus `NOT B_kl15` is TRUE), the filtered fuel flow `kfflafinf_w` is reset to `0`. This ensures a defined startup condition for the filter when the engine is started.
    *   The output of this filter is `kfflafinf_w`, representing the smoothly varying, filtered fuel flow demand.

2.  **Base Pressure Determination from Filtered Fuel Flow:**
    *   The filtered fuel flow `kfflafinf_w` is used as the independent variable (`x_val`) for a 1D lookup table block (V. 7.3, labeled `IP_val`).
    *   This lookup table converts the current filtered fuel flow into a corresponding base pressure setpoint, `KLPSKRMXX`. This value likely represents the pressure required to deliver the current fuel flow demand under ideal conditions.

3.  **Dynamic Pressure Limit Calculation:**
    *   The input pressure `pu_w` is multiplied by a constant `0.1` (V. 6.4). This step suggests a unit conversion (e.g., from hPa to kPa, or vice-versa) to standardize pressure units within the system.
    *   This scaled pressure value is then summed with two constant values, `PBKSDBGV` and `PBKSDBMXF`, using two successive `SUM` blocks (V. 7.2).
    *   The resulting sum represents a dynamic maximum allowable pressure. The accompanying German text clarifies this as "Max-Begrenzung des Solldrucks durch DBV-Maximaldruck + Umgebungsdruck" (Maximum limitation of the setpoint pressure by DBV-Maximum pressure + ambient pressure), indicating that `pu_w` likely represents ambient pressure, and `PBKSDBGV` and `PBKSDBMXF` contribute to a limit imposed by a pressure limiting valve (DBV).

4.  **Final Maximum Setpoint Selection:**
    *   The base pressure setpoint `KLPSKRMXX` (from the lookup table) and the dynamically calculated maximum pressure limit (from step 3) are fed into a `MIN` block (V. 6.6).
    *   The `MIN` block outputs the numerically smaller of these two values. This ensures that the determined maximum pump setpoint (`pbksollmx_w`) never exceeds the physical or safety limits, while also satisfying the fuel flow demand.
    *   The output of the `MIN` block is `pbksollmx_w`, which is the final maximum setpoint for the low-pressure fuel pump.

*(Note: The `OR` gate taking `B_kl15` and `NOT B_kl15` would logically always output TRUE. As its output is not connected to any processing blocks within this diagram, it is considered an unused signal within this specific subsystem's function or an output to an external part not shown here.)*


--- Page 106 ---

This page clearly displays a Simulink diagram.

## Function
This Simulink diagram, titled "43.9.2.2 Errorhandling" and related to "FUSL, Fuel pressure setpoint of low pressure pump," is designed to implement robust error handling logic for a low-pressure fuel pump's setpoint. Its primary function is to monitor various internal fault flags and operational conditions, and based on these, modify, override, or select appropriate fallback setpoints for the fuel pump. It calculates a corrected fuel pressure setpoint, a flag for a fault-activated setpoint, and a profiled setpoint, ensuring safe system operation even in the presence of faults.

## Inputs
*   **CWBKS3**: A status word, likely containing various diagnostic bits.
*   **CWBKS**: Another status word, similar to CWBKS3, containing diagnostic or operational bits.
*   **pkbksollcor**: The initial or nominal corrected fuel pressure setpoint. (Note: This is also an output, indicating it's an input to be processed and then outputted as the final corrected value).
*   **B_ebks**: A specific fallback setpoint or value used under certain fault conditions.
*   **B_ktaabks**: Another specific fallback setpoint or value used under different fault conditions.
*   **ZBKSOL**: A setpoint value, potentially related to engine operating conditions.
*   **DPBKSOLFD**: A delta pressure setpoint or adjustment factor.
*   **B_kl15**: A boolean signal, likely indicating ignition terminal 15 status (engine run status).
*   **PSBKSFA**: A factor or offset for the profiled setpoint.
*   **PSKRMX**: Another factor or offset for the profiled setpoint.
*   **prohbks**: A boolean signal, possibly related to prohibiting the normal setpoint.
*   **B_pbksprof**: A boolean signal, likely indicating a profiling mode or fault.
*   **PBKSPROF**: A parameter for profiling the fuel pressure setpoint.
*   **ZPBKSOF**: Another parameter for profiling the fuel pressure setpoint.
*   **oflafbks_w_ITL**: An input to a lookup table, potentially representing an operating range or ambient temperature.
*   **B_fapbksol_EF**: An external flag used to reset the B_fapbksol flip-flop.

## Outputs
*   **pbksollcor**: The final, fault-conditioned, corrected fuel pressure setpoint for the low-pressure pump.
*   **B_fapbksol**: A boolean flag indicating whether a fault-activated fixed pump setpoint is active.
*   **pbkszw_w**: A combined fault/state flag, asserted when specific bit conditions are met.
*   **pbksprof_w**: A final, fault-conditioned, and profiled fuel pressure setpoint.

## Logic Flow

The diagram can be conceptually divided into three main logical paths:

### 1. Fault Bit Extraction and Combined Fault Generation (`pbkszw_w`):
*   Specific bits are extracted from the input status words `CWBKS3` (bit 6) and `CWBKS` (bit 7) using "GET BIT" blocks. These extracted bits represent individual fault conditions or operational states, named `[pbkszw_1]` (from CWBKS3 bit 6) and `[pbkszw_2]` (from CWBKS bit 7).
*   An `AND` gate combines `[pbkszw_1]` and `[pbkszw_2]` to produce `pbkszw_w`. This output signal indicates a more critical or compound fault condition when both individual flags are active.

### 2. Primary Setpoint Correction (`pbksollcor` path):
*   The initial `pkbksollcor` (input) undergoes sequential modification through three `Switch` blocks, creating an internal `pbksoll` signal which then becomes the output `pbksollcor`.
    *   **First Switch:** If `pbkszw_w` (the combined fault flag) is active (not 0), the switch outputs a constant `0`. Otherwise, it passes the current `pkbksollcor` value. This acts as a hard override to `0` for the most severe combined fault.
    *   **Second Switch:** If `[pbkszw_1]` (fault bit from CWBKS3) is active, the switch outputs `B_ebks` (an emergency or fallback setpoint). Otherwise, it passes the output from the first switch.
    *   **Third Switch:** If `[pbkszw_2]` (fault bit from CWBKS) is active, the switch outputs `B_ktaabks` (another emergency or fallback setpoint). Otherwise, it passes the output from the second switch.
*   The final output of this cascade of switches is `pbksoll`, which is then sent out as `pbksollcor`, representing the fully corrected and fault-conditioned fuel pressure setpoint.

### 3. Fault-Activated Fixed Setpoint Logic (`B_fapbksol` path):
*   Two bits are extracted again from `CWBKS` (bit 7) and `CWBKS3` (bit 6).
*   The `CWBKS` bit 7 is inverted by a `NOT` gate. The inverted bit and `CWBKS3` bit 6 are then combined by an `OR` gate. The output of this `OR` gate acts as an 'E' (Enable/Mode) input to a 1D Lookup Table (`pbksoll_w_LT`).
*   The `pbksoll_w_LT` lookup table also takes `ZBKSOL` as a 'T' (Table Index) input, producing a specific setpoint value.
*   This output `pbksoll_w_LT` is compared with the derived `pbksoll` (from the primary setpoint correction path) using a "less than" relational operator.
*   In a parallel path, `pbksoll` is added to `DPBKSOLFD` and then processed by a saturation block. This result is then compared (`<`) with `B_kl15`.
*   The result of `(pbksoll_w_LT < pbksoll)` and the inverse of `B_kl15` (`NOT B_kl15`) are combined by an `OR` gate. This `OR` gate's output feeds the `SET` input of an `SR Flip-Flop`.
*   The `RESET` input of the `SR Flip-Flop` is driven by another `OR` gate, combining `pbkszw_w` and `B_fapbksol_EF`.
*   The `Q` output of this `SR Flip-Flop` is `B_fapbksol`, a persistent flag that becomes true if certain conditions are met (e.g., setpoint comparison, engine run status) and is reset by the combined fault `pbkszw_w` or an external reset signal `B_fapbksol_EF`.

### 4. Profiled Setpoint Correction (`pbksprof_w` path):
*   `oflafbks_w_ITL` (operating range) and parameters `PBKSPROF`, `ZPBKSOF` (profiling data) are used as inputs to a 1D Lookup Table (`pflabks_w_ITL`). The signal `prohbks` and `NOT B_pbksprof` also contribute to this section, likely influencing the selection of the profiling curve or its activation.
*   The output of the lookup table is adjusted by `PSBKSFA` and `PSKRMX` through `Sum` blocks, forming an adjusted profiled setpoint.
*   This adjusted profiled setpoint then passes through a cascade of `Switch` blocks, similar to the `pbksollcor` path, but in reverse order of conditions:
    *   **Bottom Switch:** If `[pbkszw_2]` is active, it outputs `0`; otherwise, it passes its input.
    *   **Middle Switch:** If `[pbkszw_1]` is active, it outputs `0`; otherwise, it passes its input.
    *   **Top Switch:** If `pbkszw_w` is active, it outputs `0`; otherwise, it passes its input.
*   This sequence ensures that if any of the specific fault conditions (`pbkszw_w`, `[pbkszw_1]`, or `[pbkszw_2]`) are active, the profiled setpoint `pbksprof_w` is forced to `0`. Otherwise, it outputs the adjusted profiled value. The final output of this path is `pbksprof_w`.


--- Page 112 ---

This page does contain a Simulink diagram.

## Function

This Simulink diagram, labeled "FUSL, Fuel pump low pressure control," implements the control logic for the low-pressure fuel pump system within an automotive application. Its primary function is to process various vehicle, driver, and system status inputs, execute complex algorithms at specified time intervals (20ms and 100ms), and generate appropriate output signals to manage and monitor the fuel pump's low-pressure operation. It appears to integrate closely with braking system states and non-volatile memory for persistent data storage.

## Inputs

The diagram receives a comprehensive set of inputs, categorized as follows:

**System & Timing Signals:**
*   `fc_INI`: Initialization trigger.
*   `fc_OPM_20MS`: 20ms operational trigger.
*   `fc_OPM_100MS`: 100ms operational trigger.
*   `_fc_CLRFMY`: Internal feedback/control signal.
*   `RST` (implied from the top block): Reset signal.

**Vehicle State & Sensor Inputs (example signals; many are likely boolean flags (B_) or word values (_w)):**
*   `pbksoll_w`: Pressure brake system nominal/desired value (word).
*   `B_nmot`: Engine speed flag (boolean).
*   `B_ktaabks`: Brake system request flag.
*   `B_sa`: Ignition switch / vehicle ON status.
*   `B_efahr`: Electric driving mode active.
*   `B_dhbks`: Dynamic brake assist system active.
*   `B_ekponbks`: Brake system component active.
*   `B_erdbksy`: Regenerative braking system active.
*   `pbkist_w`: Pressure brake system actual value (word).
*   `B_kfnbks`: Brake fluid level OK flag.
*   `B_ebks`: Electronic brake system active.
*   `dmkrhdev_w`: Brake system deviation monitoring value.
*   `B_bksspa`: Brake system pressure sensor active.
*   `nmot_w`: Engine speed (word).
*   `B_stend`: Vehicle standstill flag.
*   `tmot`: Engine temperature.
*   `vfzg_w`: Vehicle speed (word).
*   `B_flafobks`: Brake pedal pressed flag.
*   `B_kuppl`: Clutch pedal pressed flag.
*   `tnse_w`: Gear engaged (word).
*   `B_fstcanok`: CAN bus for brake system communication OK.
*   `B_tflstok`: Fuel tank level OK.
*   `B_pbksprof`: Brake pressure sensor fault flag.
*   `B_getankt`: Fuel tank filled flag.
*   `B_tflstausw`: Fuel tank level sensor active.
*   `B_hrdynaw`: Hydraulic brake dynamic active.
*   `B_kl15`: Ignition key position 15 (ON).
*   `vgeshdp_w`: Vehicle total distance high precision.
*   `vrhdr_w`: Vehicle resistance factor.
*   `B_switchbks`: Brake system switch status.
*   `E_edbks`, `E_ebks`, `E_erdbksy`: Error flags related to braking systems.
*   `B_tmbkser`: Brake system malfunction flag.
*   `B_clbks`: Clear brake system fault.
*   `ADBKSMINI`: Brake system minimum pressure setting.
*   `CWBKS`, `CWBKS2`, `CWBKS3`, `CWBKS4`: Various brake warning light statuses.
*   `PBKSSP`: Brake system pressure sensor raw value.
*   `lepwmbks_w`: Pulse width modulation for brake system.
*   `B_frdbks`: Front wheel brake active.
*   `CWBKSMPI`: Brake system fault flag (MPI).
*   `B_mpi`: Multi-point injection system active.
*   `nvmv_pbksadr_w`: Non-volatile memory value for pressure brake system.

## Outputs

The diagram generates a range of output signals, primarily related to brake system status, pressure values, and control flags:

*   `B_aabks`: Output status for "AABKS" (specific brake function).
*   `B_adbks`: Output status for "ADBKS".
*   `B_irgfrbks`: Output status for "IRGFRBKS" (e.g., intervention requested).
*   `B_wbkse`: Output status for "WBKSE".
*   `B_wobze`: Output status for "WOBZE".
*   `B_zadks`: Output status for "ZADKS".
*   `dmkrhdef_w`: Output for brake system deviation definition.
*   `pbksadg_w`: Pressure brake system desired gain (word).
*   `pbksadr_w`: Pressure brake system actual pressure (word).
*   `pbksadw_w`: Pressure brake system warning pressure (word).
*   `pbksadwa_w`: Pressure brake system warning active (word).
*   `pbksaw_w`: Pressure brake system warning.
*   `pbksdiff_w`: Pressure brake system difference.
*   `pbksia_w`: Pressure brake system idle active.
*   `pbksollmod_w`: Pressure brake system modified nominal/desired value (word).
*   `vrhdrf_w`: Vehicle resistance factor filtered (word).
*   `nvmv_pbksadr_w`: Updated non-volatile memory value for pressure brake system.

## Logic Flow

The logical flow of the diagram can be broken down into initialization, timed execution, and core processing blocks with feedback mechanisms:

1.  **Initialization (Top right block and INI X.1):**
    *   The top right orange block with "Init:", "CLRFMY", "NVMRES", etc., along with the `fc_INI` signal and the `INI` block (X.1), suggests an initialization routine that runs at startup. This sets initial states or loads parameters, possibly from non-volatile memory (NVM). The `ini` output is used for subsequent blocks.

2.  **Timed Execution (OPM_20MS, OPM_100MS):**
    *   The diagram is designed for periodic execution at two different rates: 20ms and 100ms. This is indicated by the "Recurrence: 20MS, 100MS" text, and the `fc_OPM_20MS` and `fc_OPM_100MS` trigger signals feeding into respective timed subsystems (X.3 and X.4).
    *   `OPM_20MS` (X.3): This subsystem, likely `LV_CLR_FMY_BKS_ACT`, runs every 20ms. It takes various inputs, including feedback, and calculates `B_irgfrbks` and `pbksia_w`.
    *   `OPM_100MS` (X.4): This subsystem, also `LV_CLR_FMY_BKS_ACT`, runs every 100ms. It processes a different set of inputs, including outputs from the 20ms task, and interacts with non-volatile memory.

3.  **Input Processing & Data Flow:**
    *   Numerous input signals on the left (e.g., `pbksoll_w`, `B_nmot`, `vfzg_w`, `tmot`) are fed into the core processing blocks.
    *   Some inputs first pass through a block related to "Recurrence" (the orange block at the top left), which might be responsible for sampling or preprocessing signals based on the recurrence rates.

4.  **Core Logic Blocks (`LV_CLR_FMY_BKS_ACT` X.2, X.3, X.4):**
    *   These green blocks represent the main functional logic. "LV_CLR_FMY_BKS_ACT" likely stands for "Low-Voltage Clear Functionality Monitoring for Brake System Activation" or something similar, indicating complex control logic related to brake system status and fuel pump operation.
    *   **FCMCLR (X.2):** This block appears to handle a clearing or reset function, potentially for fault states or pressure values. It takes `fc_OPM_20MS`, a feedback signal, and `rst_pbksadr_w` (reset pressure brake system actual pressure) as inputs.
    *   **OPM_20MS (X.3):** This block receives inputs like `fc_OPM_20MS`, `LV_CLR_FMY_BKS_ACT` (perhaps an enable or state), and an `In` signal (potentially from X.2). It outputs `B_irgfrbks` (brake intervention requested) and `pbksia_w` (pressure brake system idle active).
    *   **OPM_100MS (X.4):** This block receives `fc_OPM_100MS`, `B_irgfrbks`, `pbksia_w`, `rst_pbksadr_w`, an `In` signal, and `nvmv_pbksadr_w`. It processes these to calculate and update `nvmv_pbksadr_w`, indicating persistent storage of a critical pressure value or state.

5.  **Feedback and Non-Volatile Memory (NVM) Management:**
    *   There are clear feedback loops. For example, the `pbksadr_w` signal (actual pressure) can be routed back through a multiplexer to become `rst_pbksadr_w`, suggesting a self-correction or reset mechanism.
    *   The `nvmv_pbksadr_w` signal is both an input to and an output from the OPM_100MS block (X.4), explicitly showing interaction with non-volatile memory to read and store critical pressure-related data.

6.  **Output Generation (Signal Manager):**
    *   Various internal signals from the core logic blocks are routed to the "Signal Manager" block on the right. This block acts as an aggregator, collecting the final computed states, pressures, and flags, and presenting them as the system's outputs. These outputs (`B_aabks`, `pbksadr_w`, etc.) would then be used by other parts of the vehicle's control unit or for diagnostics.

In essence, the system continuously monitors a wide array of vehicle conditions, processes them through time-critical algorithms, potentially modifies a desired fuel pressure setpoint or activation state, and stores critical parameters persistently, all while integrating with the vehicle's braking system.


--- Page 113 ---

This page contains a block diagram that follows the principles of graphical modeling tools like Simulink, commonly used in automotive embedded systems development.

## Function

This diagram describes the "Initialization" (INI) sub-system for the "Fuel pump low pressure control" (FUSL) module. Its primary function is to manage various startup and non-volatile memory (NVM) related operations. This includes system reset handling, NVM initialization (setting defaults), NVM restoration (loading saved data), and NVM storage (saving current data) based on specific triggers and conditions. It consolidates the statuses of these operations into a single output.

## Inputs

*   **fc_INI (Port 1):** Main initialization trigger, likely a boolean signal indicating that the overall initialization process should begin or is active. This signal appears to enable the parallel execution of the reset and NVM functions.
*   **<fc_RST>:** A specific trigger signal for the system reset operation.
*   **<fc_IGKON>:** An ignition ON trigger signal, likely used in conjunction with `<fc_RST>` to determine reset conditions.
*   **<fc_NVMUNI>:** A trigger signal for initiating the non-volatile memory initialization process. (Label looks like NVMUNI or NVM_INI, assuming NVMUNI as a common abbreviation).
*   **<fc_NVMRES>:** A trigger signal for initiating the non-volatile memory restoration process (loading saved data).
*   **<fc_NVMSTO>:** A trigger signal for initiating the non-volatile memory storage process (saving current data).
*   **feedback (Port 2):** An additional input specifically for the NVM_STO block, likely representing a status or a condition that influences the NVM storage operation.

## Outputs

*   **ini (Port 1):** The primary output of this initialization sub-system. This signal appears to be a bus or a combined status signal that consolidates the outputs from the `RST`, `NVM_INI`, `NVM_RES`, and `NVM_STO` blocks. It indicates the overall state or completion of the various initialization and NVM operations.
*   **nvm_ini:** Output from the `NVM_INI` block, likely indicating the status or completion of the NVM initialization.
*   **nvm_res:** Output from the `NVM_RES` block, likely indicating the status or completion of the NVM restoration.
*   **nvm_sto:** Output from the `NVM_STO` block, likely indicating the status or completion of the NVM storage.

## Logic Flow

The diagram illustrates a parallel execution model for different initialization and NVM tasks, all broadly orchestrated by the `fc_INI` trigger.

1.  **Overall Enablement:** The main input `fc_INI` (Port 1) acts as a common enabling signal, distributed to the `RST`, `NVM_INI`, `NVM_RES`, and `NVM_STO` blocks. This suggests that these blocks are active or can perform their functions when `fc_INI` is asserted.

2.  **Reset (RST) Block (X.1.1):**
    *   This block receives `fc_INI` as an implicit enable.
    *   It also takes two specific triggers, `<fc_RST>` and `<fc_IGKON>`, which are combined (likely ORed or subject to internal logic within the input block represented by the vertical bar) to trigger the `fc()` function.
    *   The `fc()` function inside the `RST` block handles system reset logic.
    *   Its output, labeled `ini` (internally, distinct from the final output port), represents the status or result of the reset operation.

3.  **NVM Initialization (NVM_INI) Block (X.1.2):**
    *   This block also receives `fc_INI` as an implicit enable.
    *   It is explicitly triggered by the `<fc_NVMUNI>` signal.
    *   The `fc()` function within `NVM_INI` is responsible for initializing non-volatile memory, typically by setting default values or formatting NVM areas.
    *   Its output, `nvm_ini`, indicates the status or completion of the NVM initialization.

4.  **NVM Restore (NVM_RES) Block (X.1.3):**
    *   Enabled by `fc_INI`.
    *   Triggered by the `<fc_NVMRES>` signal.
    *   The `fc()` function inside `NVM_RES` manages restoring previously saved data from non-volatile memory.
    *   Its output, `nvm_res`, indicates the status or completion of the NVM restoration.

5.  **NVM Store (NVM_STO) Block (X.1.4):**
    *   Enabled by `fc_INI`.
    *   Triggered by the `<fc_NVMSTO>` signal, and also takes a `feedback` signal (Port 2) as an input. The `feedback` input likely represents a system state or condition that determines when or how NVM storage should occur.
    *   The `fc()` function within `NVM_STO` handles saving current system parameters or data to non-volatile memory.
    *   Its output, `nvm_sto`, indicates the status or completion of the NVM storage.

6.  **Consolidated Output:** The outputs from all four functional blocks (`ini` from RST, `nvm_ini`, `nvm_res`, and `nvm_sto`) are directed into a vertical bar on the right side. This vertical bar acts as a Bus Creator (or similar signal combiner), bundling these individual statuses into a single, consolidated output signal named `ini` (Port 1). This final `ini` signal provides a comprehensive status of all the initialization and NVM operations managed by this sub-system.


--- Page 114 ---

This page contains a Simulink-like diagram, likely representing an initialization or reset routine within an automotive control system.

## Function
This diagram's primary function is to initialize or reset a large set of internal variables and states related to the "Fuel pump low pressure control" system (FUSL). The "INI/RST" in the path name `FUSL_M9014/INI/RST` strongly indicates this is an Initialization/Reset module. It sets these variables to predefined default values (mostly zero, but some to specific non-zero values) to ensure a known and stable operating condition at startup or after a reset event.

## Inputs
There are no explicit data input ports in the traditional Simulink sense (i.e., "Inport" blocks) visible in this diagram. The function operates primarily by assigning constant values.
*   **Implicit Trigger:** The `f()` block (labeled `fc`) at the top left likely represents a function call or an event signal that triggers the execution of this initialization routine (e.g., power-on reset, mode change). This trigger is the implicit input to the overall subsystem.

## Outputs
The outputs of this diagram are the initialized values of numerous internal variables and states used by the fuel pump low-pressure control logic. These signals become available for subsequent system operations.
*   **Initialized Variables (partial list of visible outputs):**
    *   pbksia_w
    *   pbksiao_w
    *   pbksiad_w
    *   B_aadw
    *   zaabks_w
    *   B_cl_w
    *   pbksadg_w
    *   B_zadks
    *   B_adpfbks
    *   pbksaw_w
    *   B_bkserr
    *   B_regfrbks
    *   B_irgfrbks
    *   pbksdiff_w
    *   B_fueldpm
    *   pbkspa_w
    *   pbksda_w
    *   pbksdio_w
    *   pbksdr_w
    *   pbksolmod_w
    *   B_spksacwe
    *   B_wspwfbks
    *   B_krhdf_w
    *   dmkrhst
    *   dmkrwb
    *   pbkswb
    *   adbkswb
    *   adbksez
    *   B_vobkse
    *   pbksadw_w
    *   pbkswobze
    *   pbkswobokvd
    *   pbkswobpos_w
    *   pbksollsoll_w
    *   B_admfwobbks
    *   B_f_adrf_w
    *   B_fwobres
*   **Initialization Status:** A single output port labeled `ini` on the far right. This likely represents a status flag indicating that the initialization process has completed successfully, or it could potentially represent a bus containing all the initialized values.

## Logic Flow
1.  **Trigger Event:** The initialization process is initiated, likely by an external trigger or function call (indicated by the `f()` block).
2.  **Constant Value Generation:** A series of constant blocks, typically labeled with '0' or '1' (e.g., the block connected to `B_vobkse`), are activated. The "V.6.4" annotation beneath the constant value likely specifies the data type and scaling (e.g., a fixed-point format with 6 integer bits and 4 fractional bits, or similar).
3.  **Parallel Assignment:** Each constant block's output value is simultaneously assigned to a specific internal system variable or state. Most variables are initialized to `0`. For example, `pbksia_w` is initialized to `0`, and `B_vobkse` is initialized to `1`.
4.  **Variable State Setting:** This parallel assignment process effectively sets the initial (or reset) state for all listed variables within the fuel pump low-pressure control system.
5.  **Completion Signal:** Once all assignments are made, the `ini` output port is activated, signaling that the initialization routine is complete and the system variables are in their default operational state.


--- Page 115 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "43.10.1.2 NVM_INI," describes a Non-Volatile Memory (NVM) initialization routine. It is explicitly linked to "FUSL, Fuel pump low pressure control," indicating its role within the fuel system's control logic. The primary function of this module is to read or initialize specific persistent data related to fuel pump blockage acknowledgment from NVM and then provide a signal indicating the completion or status of this initialization.

## Inputs
*   **`fc` (Function-Call Trigger):** This input, represented by the `f()` block, acts as a function-call trigger or an event input. It signifies that this subsystem is executed when `fc` is called, initiating the NVM read/initialization operations.

## Outputs
*   **`nvm_ini` (NVM Initialization Status):** This is the main output signal of the diagram. It represents the overall status or completion of the NVM initialization process for the specific variables handled within this module. It is likely a boolean flag indicating success (e.g., 1) or a collective status.

## Logic Flow
1.  **Initiation by Function Call:** The process begins when the `f()` block, labeled `fc`, is activated. This block serves as a trigger, signaling the start of the NVM initialization routine.
2.  **Persistent Variable `pbksadr_w` Handling:** The first `NVMY[read/init]` block is responsible for interacting with the Non-Volatile Memory concerning the variable `pbksadr_w`. This block attempts to read the stored value of `pbksadr_w` from NVM. If a valid value is found, it is retrieved. If the NVM data is not available, corrupted, or if this is a first-time initialization, the variable `pbksadr_w` is initialized to its default value (specified as `init:0`). The variable is a scalar (`size: 1`) and its version is indicated as `V. 6.5`.
3.  **Persistent Variable `pbksadwa_w` Handling:** Simultaneously or sequentially, the second `NVMY[read/init]` block performs a similar operation for the variable `pbksadwa_w`. It reads or initializes `pbksadwa_w` from NVM, setting it to `init:0` if necessary. This variable also has `size: 1` and `V. 6.5`.
4.  **Signal Aggregation:** The output signals from both NVM blocks, `pbksadr_w` and `pbksadwa_w`, are directed to a thick vertical bar. In Simulink, this typically represents a Bus Creator or a Mux block, which aggregates these individual signals into a single output. This aggregated signal is labeled `nvm_ini`.
5.  **Output Generation:** Finally, the combined `nvm_ini` signal is connected to the Outport block (labeled `1` and `nvm_ini`). This makes the aggregated NVM initialization status available as an output from this subsystem to other parts of the automotive control system, indicating that the persistent data for fuel pump blockage acknowledgment has been appropriately handled during startup.


--- Page 116 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, named "43.10.1.3 NVM_RES" and belonging to the "FUSL, Fuel pump low pressure control" context, primarily functions to **retrieve two specific data parameters from Non-Volatile Memory (NVM) and combine them into a single output signal.** This process likely serves for initialization, configuration, or status reporting of persistent data critical for the fuel pump low-pressure control system. The `f()` block suggests this operation is executed as a triggered function call within the overall system.

## Inputs
*   **fc (Function Call Trigger):** Represented by the `f()` block, this is not a data input but rather a trigger that initiates the execution of the logic within this subsystem.
*   **Implicit NVM Data:** The "NVMY[read/init]" blocks implicitly take data from the Non-Volatile Memory as their source. Specifically, the data for `pbksadr_w` and `pbksadwa_w` are read from NVM.

## Outputs
*   **nvm_res:** This is the primary output of the subsystem. It is a combined signal (likely a bus or vector) formed from the `pbksadr_w` and `pbksadwa_w` values read from NVM.

## Logic Flow
1.  **Function Call Initiation:** The subsystem's execution is initiated by a function call, indicated by the `f()` block labeled "fc". This means the logic inside will run when triggered by an external event or scheduled task.
2.  **NVM Data Retrieval for `pbksadr_w`:** One "NVMY[read/init]" block is activated. This block is configured to interact with a Non-Volatile Memory variable named `pbksadr_w`. It either reads the current value of `pbksadr_w` from NVM or initializes it if required (e.g., at first boot or after a reset). The output of this block is the `pbksadr_w` signal, which is a scalar (size: 1).
3.  **NVM Data Retrieval for `pbksadwa_w`:** Simultaneously or sequentially, a second "NVMY[read/init]" block operates to retrieve or initialize another Non-Volatile Memory variable named `pbksadwa_w`. Similar to the first, it reads the persistent value of `pbksadwa_w` or initializes it. The output of this block is the `pbksadwa_w` signal, also a scalar (size: 1).
4.  **Signal Aggregation:** The `pbksadr_w` and `pbksadwa_w` signals are then fed into a vertical bar block. In Simulink, this typically represents a Bus Creator or Mux block, which combines multiple individual signals into a single, structured composite signal (a bus) or a vector.
5.  **Output Generation:** The combined signal from the aggregation step is assigned the name `nvm_res`. This `nvm_res` signal is then routed to an Outport block (labeled "1" and also named `nvm_res`), making it the final output of this Simulink subsystem.


--- Page 117 ---

This page contains a Simulink diagram.

## Function
This Simulink subsystem, named `NVM_STO` (Non-Volatile Memory Store), is designed to persist specific data variables (`pbksadr_w` and `pbksadwa_w`) into non-volatile memory. It operates within the context of a "Fuel pump low pressure control" system, suggesting that these stored variables are crucial for the fuel pump's operational parameters or calibration, ensuring they are retained across power cycles. The subsystem is triggered by a function call and consolidates the status or values related to the storage operations along with an external feedback signal into a single output.

## Inputs
*   **fc (Function Call Trigger):** This is a trigger input, indicating that the subsystem's execution is initiated by a function call event from a higher-level scheduler or task.
*   **feedback (Inport block, numerical value 1):** An external input signal, likely a control flag, status, or enable signal that influences the subsystem's behavior or is passed through to the output.
*   **<pbksadr_w> (Signal):** The current value of the `pbksadr_w` parameter, which is intended to be stored in non-volatile memory. The `<...>` notation often indicates a data store read or a global variable input.
*   **<pbksadwa_w> (Signal):** The current value of the `pbksadwa_w` parameter, which is also intended to be stored in non-volatile memory. Similar to `<pbksadr_w>`, this is likely a data store read or global variable input.

## Outputs
*   **nvm_sto (Outport block, numerical value 1):** The primary output of the subsystem. Based on common Simulink practices where a thick line feeds a single outport, this is likely a bus or a structured signal containing the aggregated status or values from the storage operations and the `feedback` input. It effectively reports the outcome or state of the NVM storage process.

## Logic Flow
1.  **Function Call Trigger:** The subsystem execution is initiated by an external function call, symbolized by the `fc` trigger. This ensures the NVM storage routine is executed at specific, defined points in the system's operation (e.g., at shutdown, after calibration changes, or periodically).

2.  **Data Input for Storage:** Upon activation, the subsystem receives two crucial data inputs: `<pbksadr_w>` and `<pbksadwa_w>`. These represent the current values of the fuel pump related parameters that need to be permanently saved.

3.  **Non-Volatile Memory Storage Operations:**
    *   The first `NVMY[store]` block takes the `<pbksadr_w>` signal as its input. This block is responsible for writing the received value into the designated non-volatile memory location for `pbksadr_w`. The block's parameters specify that `pbksadr_w` has a size of 1 unit (likely a single word or scalar) and an initialization value taken from `pbksadr_w` itself (indicating that the NVM module manages its initialization based on the RAM variable). It then outputs a signal also named `pbksadr_w`, which could represent the successfully stored value or a status confirming the write operation.
    *   Concurrently, the second `NVMY[store]` block performs an identical operation for the `<pbksadwa_w>` signal. It writes this value to its respective NVM location (parameters indicate `pbksadwa_w`, size 1, initialized from `pbksadwa_w`) and outputs a signal named `pbksadwa_w`, signifying the stored value or status.

4.  **Feedback Integration:** An external `feedback` signal is also provided to the subsystem. This signal could be an enable for the NVM storage, a status from a previous operation, or another control input that needs to be communicated alongside the NVM storage outcomes.

5.  **Output Aggregation:** The outputs from the two `NVMY[store]` blocks (`pbksadr_w` and `pbksadwa_w`) and the `feedback` input are then aggregated. The thick vertical line leading to the `nvm_sto` outport suggests these three signals are grouped together, likely forming a bus or a structure that is then output as `nvm_sto`. This output, therefore, provides a comprehensive status or a collection of critical values related to the NVM storage operation within the `FUSL` system.


--- Page 118 ---

This page contains a Simulink diagram.

## Function
This Simulink subsystem, identified as "FCMCLR" (likely **F**ault **C**ode **M**emory **CL**ea**R**), is part of a larger "Fuel pump low pressure control" system. Its primary function is to manage the conditions and signals related to the clearing of fault memory and the resetting of adaptation values. It processes various system status and error flags ("bks" signals) along with a potential external clear command/code to generate specific reset signals and an active flag for fault memory clearing. The subsystem must be calculated before the overarching error management system erases all errors.

## Inputs
1.  **`cond_if`**: A general conditional input, possibly indicating an overall system state or diagnostic mode, that influences various logical branches. (Appears multiple times as a control input to 'If' blocks).
2.  **`<B_switchbks>`**: A boolean or status flag, likely related to a switch-back or specific error condition.
3.  **`<E_edbks>`**: An error or status flag, possibly related to an "end" or "event" back signal.
4.  **`<E_ebks>`**: Another error or status flag.
5.  **`<B_tmbkser>`**: A boolean or status flag, possibly indicating a time-based or timer-related error.
6.  **`<B_clbks>`**: A boolean or status flag, possibly related to a 'clear' or 'close' back signal.
7.  **`In1`**: An input port labeled as an "external bit value for clearing of fault code memory." This is likely a diagnostic code or command word used to trigger specific fault clearing actions.
8.  **`In2` (`<ADKBSINI>`)**: An input port, likely providing an initial or default value for the fault clear logic, possibly related to adaptation value initialization.

## Outputs
1.  **`rst_pbksadr_w`**: A reset signal for a "path block address" or similar internal address, driven by conditional logic.
2.  **`LV_CLR_FMY_BKS_ACT`**: The core output signal, indicating that the **L**evel **C**lea**R** **F**ault **M**emor**Y** (for specific **B**ac**K** **S**ignals) is **ACT**ive. This signal is crucial for controlling fault memory and adaptation value resets.
3.  **`pbksadw_w`**: A signal outputted as part of a bus, potentially a "path block acknowledge data word" or similar diagnostic value.
4.  **`pbksaw_w`**: Another signal outputted as part of a bus, possibly a "path block acknowledge write" or related value.
5.  **`pbksadwa_w`**: A third signal outputted as part of a bus, likely related to "path block address data write".
6.  **`clrfmy`**: A "clear fault memory" signal, which is directly derived from `LV_CLR_FMY_BKS_ACT`.

## Logic Flow

The subsystem processes inputs through a series of conditional branches and logical operations to determine the appropriate fault clearing and reset actions:

1.  **Initial Conditional Branching (Top Left):**
    *   The `cond_if` input controls the first `If` block.
    *   If `cond_if` is true (IF branch), a constant `1` is passed through.
    *   If `cond_if` is false (ELSE branch), the signals `<B_switchbks>`, `<E_edbks>`, `<E_ebks>`, `<B_tmbkser>`, and `<B_clbks>` are logically OR-ed together (using block V.6.3). This effectively checks if *any* of these specific "back-signal" or error flags are active. The result of this OR operation is then passed through.

2.  **Determining `rst_pbksadr_w` (Reset Path Block Address):**
    *   The output from the first `If` block (from step 1) feeds into a second `If` block, also controlled by `cond_if`.
    *   If this `cond_if` is true (IF branch), a constant `1` (V.6.4) is output.
    *   If false (ELSE branch), a constant `0` (V.6.4) is output.
    *   The result is then merged (V.6.4) to generate the `rst_pbksadr_w` output, which is a conditional reset signal.

3.  **Processing Fault Clearing Request from External Code (Lower Left):**
    *   The input `In1` (the external bit value for fault memory clearing) is fed into a `GET BIT` block (V.7.0). This block extracts a specific bit (index 0, as indicated by the constant `0` input) from `In1`. A `bit_sel` block (V.6.4) also uses `In1` and a constant `6`, likely to configure the bit extraction or other related processing.
    *   The extracted bit's value is then checked to see if it's not equal to zero (`Check ~= 0` block V.6.6). This result signals if a specific clear command bit is active within `In1`.

4.  **Combined Condition for Main Fault Clear Activation:**
    *   The output from the `Check ~= 0` block (step 3) is logically AND-ed (V.6.6) with the OR-ed "bks" signals from step 1 (the output of block V.6.3).
    *   This `AND` operation creates a crucial condition: a fault memory clear will be considered active only if a specific bit in the `In1` code is set *AND* at least one of the defined "bks" error/status flags is active. This combined condition then controls a subsequent `If` block.

5.  **Determining `LV_CLR_FMY_BKS_ACT` (Level Clear Fault Memory Backs Active):**
    *   A third `If` block (V.6.0) is controlled by the output of the `AND` gate from step 4.
    *   If the `AND` condition is true (IF branch), a constant `1` (V.6.4) is output.
    *   If the `AND` condition is false (ELSE branch), the input `In2` (`<ADKBSINI>`) is propagated.
    *   The output of this `If` block feeds into a `Merge` block (V.6.1), which also receives `In2` itself and a constant `1`. This `Merge` block effectively selects the final value for `LV_CLR_FMY_BKS_ACT` based on the conditional logic and potentially a default or initial state provided by `In2`. This signal is then outputted from the subsystem.

6.  **Derivation of Other Outputs (`pbksadw_w`, `pbksaw_w`, `pbksadwa_w`, `clrfmy`):**
    *   The `clrfmy` (clear fault memory) output is directly driven by the `LV_CLR_FMY_BKS_ACT` signal, indicating that when the "Level Clear Fault Memory Backs Active" flag is set, the general fault memory clear signal is also active.
    *   The signals `pbksadw_w`, `pbksaw_w`, and `pbksadwa_w` are also derived from internal logic and routed through a `Mux` block labeled "Out" along with `clrfmy`. These outputs likely represent specific diagnostic or acknowledgment data related to the fault clearing process, possibly used by other parts of the fuel pump control or error management system.


--- Page 119 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram depicts a control system for "FUSL Fuel pump low pressure control," likely for an automotive application. Its primary function is to regulate the low-pressure fuel supply by processing various vehicle operating conditions, driver demands, and feedback signals. The system incorporates Proportional-Integral (PI) control logic with adaptive capabilities (`PI_ADAP_20MS`) and a "wobble" or dither adaptation strategy (`WOBBEL_ADAP`), operating at a 20ms sample interval for robust and precise control of the fuel pump.

## Inputs
The system receives a comprehensive set of inputs, reflecting various states and conditions of the vehicle and its subsystems:

*   **Braking System Inputs:** `B_switchbks`, `B_ktaabks`, `B_dhbks`, `B_ekponbks`, `B_erdbksy`, `pbkist_w`, `B_frdbks`, `B_ebks`, `B_bkssspa`, `PBKSSP`, `B_dbewbks_fb` (feedback).
*   **Vehicle & Engine Status/Demands:** `B_sa` (general status), `B_efahr` (driving state), `B_kl15` (ignition status), `lepwmbks_w`, `B_pbksprof` (brake profile/request), `B_getankt` (fuel level), `B_tffstausw` (fluid temperature/status), `B_hrdynaw` (hydraulic dynamic state), `vgeshdp_w` (desired hydraulic pressure), `vrhdr_w` (hydraulic pressure return), `dmkrhdev_w` (deviation), `nmot_w` (engine speed), `B_stend` (standstill status), `tmmot` (engine temperature), `vfzg_w` (vehicle speed), `B_flafo` (fuel level status), `B_kuppl` (clutch status), `tnse_w`, `B_fstcanok` (CAN communication status), `B_tffstok` (fluid temperature status OK), `ADBKSSINI` (initialization signal), `CWBKS`, `CWBKS2`, `CWBKS3`, `CWBKSMPI`, `B_mpi`.
*   **Desired/Feedback Setpoints:** `pbksoll_w` (desired setpoint), `pbksadw_w_fb` (feedback of adapted values), `pbksadwa_w_fb` (feedback of adapted wobble values).
*   **Internal Feedback Signals:** `B_irgfrbks` (from `LV_CLR_FMY_BKS_ACT`), `pbksia_w` (from `LV_CLR_FMY_BKS_ACT`).
*   **Generic Feedback:** `feedback`.

## Outputs
The system produces several outputs, which include the final control command for the fuel pump and various intermediate control parameters and status flags:

*   **Primary Fuel Pump Control Output:** `opm_20ms` (likely the final control command signal for the low-pressure fuel pump, potentially a duty cycle or voltage command).
*   **Outputs from `LV_CLR_FMY_BKS_ACT`:** `B_regfrbks`, `B_irgfrbks`, `pbksdiff_w`, `pbkspa_w`, `pbksda_w`, `pbksdio_w`, `pbksia_w`, `B_regwindup`.
*   **Outputs from `PI_ADAP_20MS`:** `pbksollmod_w` (modified setpoint), `B_bksacwe`, `B_spwfbks`, `dmkrhdef_w`, `B_dmkrhst`, `B_dmkrwb`, `B_pbkswb`, `B_ladbksm`, `B_wbksez`, `B_wbkse`, `B_wobze`, `B_wobokvd`, `twobpos_w`, `dpbksoll_w`.
*   **Outputs from `WOBBEL_ADAP`:** `B_ffwobres`, `vrhrdf_w`, `B_dbewbks`, `pbksaw_w`, `pbksadw_w`, `pbksadwa_w`, `LV_CLR_FMY_BKS_ACT_tmp`.

## Logic Flow

The control logic unfolds in a parallel and sequential manner, processing inputs through specialized subsystems at a regular time interval (20ms):

1.  **Input Gathering and Distribution:** At the start of each 20ms cycle, all external inputs are sampled and distributed to the three main functional subsystems: `LV_CLR_FMY_BKS_ACT`, `PI_ADAP_20MS`, and `WOBBEL_ADAP`.
2.  **`LV_CLR_FMY_BKS_ACT` Subsystem:**
    *   This subsystem receives a primary set of inputs, including various braking status flags and the general `feedback` signal.
    *   It processes these inputs to determine specific functional states or initiate actions, possibly related to clearing system flags or activating/deactivating brake-related functionalities.
    *   It outputs several intermediate control and status signals, notably `B_irgfrbks` and `pbksia_w`, which are then fed forward as inputs to the `PI_ADAP_20MS` and `WOBBEL_ADAP` subsystems, respectively, establishing feedback and feedforward paths.
3.  **`PI_ADAP_20MS` Subsystem:**
    *   This is a central control component, receiving a significant portion of the total inputs, including desired setpoints (`pbksoll_w`), engine/vehicle operating conditions (e.g., `nmot_w`, `vfzg_w`), and feedback from `LV_CLR_FMY_BKS_ACT` (`B_irgfrbks`, `pbksia_w`).
    *   It implements a Proportional-Integral (PI) control algorithm. The "ADAP" in its name signifies that the PI controller's parameters are adaptively tuned based on current operating conditions to optimize fuel pressure regulation, maintaining stability and performance.
    *   It calculates a modified setpoint `pbksollmod_w` and a wide array of control-specific parameters and status indicators necessary for the next stage.
4.  **`WOBBEL_ADAP` Subsystem:**
    *   Operating in parallel, this subsystem receives inputs related to system health (`B_fstcanok`, `ADBKSSINI`), various control words, and critical feedback signals (`pbksia_w`, `pbksadw_w_fb`, `pbksadwa_w_fb`, `B_dbewbks_fb`) from the previous cycle's outputs.
    *   The "Wobbel" (German for wobble) combined with "ADAP" suggests an adaptive dithering or oscillation strategy. This might involve introducing small, intentional disturbances to a control signal to improve the resolution of a mechanical actuator (like a fuel pump's control valve), reduce hysteresis or static friction, and enhance control precision, particularly at low flow rates or pressures.
    *   It generates its own set of output signals, some of which (`pbksadw_w`, `pbksadwa_w`, `B_dbewbks`) are explicitly fed back into its inputs for continuous adaptation.
5.  **Output Aggregation and Final Command Generation:**
    *   The `pbksollmod_w` signal from `PI_ADAP_20MS` passes through a `Merge` block. While only one input is explicitly shown for this merge, it typically implies a point where multiple signal paths converge, possibly with conditional selection.
    *   All calculated outputs from the three subsystems are directed to global output ports.
    *   Finally, the `opm_20ms` block, itself a subsystem, receives the merged `pbksollmod_w` and potentially other bundled control signals from `PI_ADAP_20MS`. It then processes these inputs to generate the final `Out` signal, which represents the control command sent to the physical low-pressure fuel pump.

This entire process operates cyclically, with feedback loops enabling the system to continuously monitor and adjust the fuel pump's operation for optimal low-pressure regulation.


--- Page 120 ---

This page contains a Simulink-like diagram, likely representing a control function for automotive systems.

## Function
The primary function of this diagram, as indicated by the title "FUSL, Fuel pump low pressure control", is to implement a control strategy for managing the low-pressure fuel pump. It comprises two main subsystems: a PI (Proportional-Integral) controller (`PI_Regler`) and a setpoint adaptation module (`PSOLL_ADAP`). Together, these modules process various sensor inputs, status flags, and setpoints to regulate fuel pressure and generate a modified, adaptive setpoint for the fuel pump.

## Inputs
The diagram identifies several inputs, primarily Boolean status flags and real-valued measurements or setpoints.

**Inputs to `PI_Regler` (Left Green Block):**
1.  `B_ktaabks`: Boolean, likely "K-Terminal active braking system" status.
2.  `B_sa`: Boolean, "System active" status.
3.  `B_efahr`: Boolean, "Electric driving/operation" status.
4.  `B_dhbks`: Boolean, "Deceleration fuel cut-off active braking system" status.
5.  `B_ekponbks`: Boolean, "Electric pump on/off status (braking system related)".
6.  `B_erdbksy`: Boolean, "Earth braking system" status.
7.  `pbksoll_w`: Real, "Pump pressure setpoint value (initial/raw)".
8.  `pbkist_w`: Real, "Pump pressure actual (IST) value".
9.  `B_kl15`: Boolean, "Terminal 15 (ignition on) status".
10. `CWBKS3`: (Control Word for Braking System, possibly indicating mode or configuration).
11. `lepwmbks_w`: Real, "Low-pressure pump PWM (Pulse Width Modulation) value (braking system related)".
12. `B_frdbks`: Boolean, "Feedback braking system" status.

**Inputs to `PSOLL_ADAP` (Right Green Block):**
1.  `pbksdr_w`: Real, "Pump pressure raw sensor value" (received from `PI_Regler`).
2.  `pbksoll_w1`: Real, "Pump pressure setpoint value 1" (another reference setpoint).
3.  `B_erdbksy1`: Boolean, "Earth braking system 1" status.
4.  `B_sa1`: Boolean, "System active 1" status.
5.  `CWBKS2`: (Control Word for Braking System, possibly for different adaptations).

*(Note: `fc` is likely a functional context label, not a direct input to the logic shown.)*

## Outputs
The outputs are signals generated by the subsystems for further use in the control architecture.

**Outputs from `PI_Regler` (Right of first green block):**
1.  `B_regfrbks`: Boolean, "Regulator feedback braking system" status.
2.  `B_irgfrbks`: Boolean, "Integrator feedback braking system" status.
3.  `pbksdiff_w`: Real, "Pump pressure difference value".
4.  `pbkspa_w`: Real, "Pump pressure setpoint adaptation value".
5.  `pbksda_w`: Real, "Pump pressure sensor actual value".
6.  `pbksdio_w`: Real, "Pump pressure diagnostic I/O value".
7.  `pbksia_w`: Real, "Pump pressure integrator actual value".
8.  `B_regwindup`: Boolean, "Regulator windup status".
9.  `pbksdr_w`: Real, "Pump pressure raw sensor value" (also fed to `PSOLL_ADAP`).

**Outputs from `PSOLL_ADAP` (Right of second green block):**
1.  `pbksollmod_w`: Real, "Modified pump pressure setpoint value".

## Logic Flow

The logical flow can be described in two main stages, corresponding to the two subsystems:

1.  **`PI_Regler` Subsystem Operation:**
    *   The `PI_Regler` acts as a core controller, receiving a comprehensive set of inputs: various system status flags (e.g., `B_sa`, `B_kl15`), specific operational conditions (e.g., `B_efahr`, `B_dhbks`), actual and desired pump pressure values (`pbkist_w`, `pbksoll_w`), and pump control signals (`lepwmbks_w`).
    *   Internally, this subsystem likely calculates the error between the desired `pbksoll_w` and the actual `pbkist_w`, and applies Proportional-Integral control logic. The various boolean inputs would serve to enable/disable the controller, modify its behavior, or provide contextual information.
    *   It produces a range of outputs, including internal control states like `B_regfrbks` (regulator feedback), `B_irgfrbks` (integrator feedback), and `B_regwindup` (anti-windup status). It also outputs diagnostic values (`pbksdio_w`), the difference signal (`pbksdiff_w`), and importantly, a raw pump pressure sensor value `pbksdr_w`.

2.  **Setpoint Adaptation (`PSOLL_ADAP`) Subsystem Operation:**
    *   The `PSOLL_ADAP` subsystem is responsible for refining or adapting the pump pressure setpoint.
    *   It takes `pbksdr_w` (the raw pump pressure sensor value from the `PI_Regler`) as a key input. This indicates that the adaptation is driven by actual pump pressure data.
    *   Additionally, it receives its own set of status flags (`B_erdbksy1`, `B_sa1`) and a distinct setpoint reference (`pbksoll_w1`), along with a control word (`CWBKS2`). These inputs likely allow the adaptation logic to consider different operational modes or external requirements.
    *   Based on these inputs, the `PSOLL_ADAP` calculates and outputs `pbksollmod_w`, which is the "modified pump pressure setpoint value." This modified setpoint is likely a more refined or optimized target pressure, taking into account dynamic conditions, efficiency goals, or specific system requirements that go beyond the basic PI control loop.

**Overall Flow and Purpose:**
The overall system functions as a hierarchical or two-stage control for the low-pressure fuel pump. The `PI_Regler` handles the immediate regulation based on a base setpoint and real-time conditions, providing basic control and raw sensor data. This raw sensor data, along with other parameters, then feeds into the `PSOLL_ADAP` module, which intelligently modifies the ultimate target pressure. This adapted setpoint (`pbksollmod_w`) would then likely be fed to the actual fuel pump actuator or a lower-level controller to achieve precise and robust low-pressure fuel control.


--- Page 121 ---

This page clearly contains a Simulink diagram.

## Function

This Simulink diagram implements a sophisticated **PID (Proportional-Integral-Derivative) controller with an anti-windup mechanism and various enabling/disabling conditions** for a fuel pump low-pressure control system. The overall goal is to regulate the `pbksdiff_w` (likely a pressure difference or error signal) by calculating a composite regulator output `pbksdr_w`. The "CHK_WINDUP" component specifically suggests the anti-windup logic, which prevents the integral term from accumulating excessively when the control output is saturated.

## Inputs

*   **lepwmbs_w:** Boolean, likely related to low-pressure PWM block status.
*   **B_frdbks:** Boolean, likely a feedback status signal.
*   **pbksdiff_w:** The primary error signal or pressure difference that the controller aims to minimize.
*   **B_regwindup:** Boolean, indicates if regulator windup is active or detected.
*   **B_sperr_w:** Boolean, a general lock or inhibit signal.
*   **B_fahr_w:** Boolean, indicates a driving condition.
*   **B_ekpo_w:** Boolean, likely pump operational status or enable.
*   **B_erd_w:** Boolean, possibly related to ground/enable status.
*   **B_kl15:** Boolean, ignition terminal 15 (power supply) status. Used for integral reset.
*   **B_ktabs_w:** Boolean, likely brake system active test switch.
*   **B_einspr:** Boolean, injection system status.
*   **B_ms_onbks:** Boolean, motor speed on brake switch.
*   **B_ms_onsy:** Boolean, motor speed on sync.
*   **KIBKSRF:** Constant/gain, likely for feed-forward or specific integral term scaling.
*   **KIBKSKTA:** Constant/gain, likely for adaptive integral term limiting or scaling.
*   **PBKSMX:** Constant, maximum limit for the integral component.
*   **PBKSMN:** Constant, minimum limit for the integral component.
*   **KLKPBKSR:** 2D Lookup Table, provides the proportional gain based on an input `x_val`.
*   **KDBKSR:** Constant/gain for the derivative component.
*   **x_val:** Input to the `KLKPBKSR` lookup table, determines proportional gain.
*   **IP_val:** Output of the `KLKPBKSR` lookup table, representing the proportional gain.
*   **Constant '0'**: Used in comparison and for integral initialization.
*   **Constant '4'**: Used as a bit selection input for `GET BIT` block.
*   **Bitfield Input to GET BIT**: An unnamed input word/register for bit extraction.

## Outputs

*   **B_irgfbrks:** Boolean, integral regulator feedback status.
*   **B_regfrbks:** Boolean, general regulator feedback status.
*   **pbksdiff_w_IKLim:** The limited input to the integrator, preventing integral windup.
*   **pbksia_w:** The integral component of the controller output.
*   **pbkspa_w:** The proportional component of the controller output.
*   **pbksda_w:** The derivative component of the controller output.
*   **pbksdio_w:** An intermediate derivative-related output, combining derivative with a filtered error.
*   **pbksdr_w:** The final combined PID regulator output.

## Logic Flow

The logical flow can be broken down into several concurrent and interdependent paths:

1.  **Anti-Windup and Regulator Feedback Logic (Top Left):**
    *   The `CHK_WINDUP` signal is generated by an `AND` gate. Its inputs are `lepwmbs_w`, `B_frdbks`, and the `NOT` logic of `B_sperr_w`, `B_fahr_w`, `B_ekpo_w`, and `B_erd_w`. This means `CHK_WINDUP` is active only if specific conditions (pump, driving, etc.) are met and no system locks are active.
    *   `B_irgfbrks` and `B_regfrbks` (integral and general regulator feedback) are derived from `B_regwindup` and `B_sperr_w` through `NOT` and `OR` gates. These signals likely communicate the current state of the regulator's integral action and overall feedback.

2.  **Integral Component Calculation (Left Middle):**
    *   The main error signal `pbksdiff_w` is first evaluated through a comparison `>` with `0` and a complex limiter (V.6.6) that uses `0`, `KIBKSRF`, and `KIBKSKTA`. This block appears to conditionally limit `pbksdiff_w` or a derived value, likely based on operating conditions or specific thresholds, producing `Check ~= 0`.
    *   This `Check ~= 0` signal is then passed to a `LIMIT` block (V.6.6) with `PBKSMX` and `PBKSMN`, producing `pbksdiff_w_IKLim`. This explicitly limits the range of the error signal that feeds into the integrator, a direct anti-windup measure.
    *   `pbksdiff_w_IKLim` is integrated over time by the `1/z` (discrete-time integrator) block to produce `pbksia_w`.
    *   The integrator has a reset input (from `NOT B_kl15` via a V.5.3 hysteresis block), meaning the integral term `pbksia_w` can be reset to `0` if `B_kl15` (ignition) is off or other conditions trigger the reset. The `CHK_WINDUP` signal also influences the integral path by controlling the input to the integrator.

3.  **Proportional Component Calculation (Right Middle):**
    *   The `x_val` input feeds into the `KLKPBKSR` 2D Lookup Table, which outputs the proportional gain (`IP_val`).
    *   `pbksdiff_w` is multiplied by this `IP_val` (the proportional gain) to calculate the proportional component `pbkspa_w`.

4.  **Derivative Component Calculation (Bottom Right):**
    *   `pbksdiff_w` is processed through a block (V.7.3, likely a rate limiter or filter represented by the 'x' with a curve) and then multiplied by the `KDBKSR` gain to produce `pbksda_w`, the derivative component. The label "D-Anteil ausbedatet ueber KDBKSR=0" suggests the D-part is calculated, but effectively disabled if `KDBKSR` is zero.
    *   Separately, `pbksdiff_w` is fed into a `GET BIT` block (V.7.0) with an input `4` for bit selection, possibly extracting a specific bit or field. This output, along with `B_ms_onsy`, `B_ms_onbks` (via NOT and AND gates, then an 'if' block V.6.0), and `CHK_WINDUP`, feeds into a conditional summation.
    *   `pbksda_w` and the output of the `GET BIT` branch (potentially zero if conditions are not met) are summed to produce `pbksdio_w`.

5.  **Final Regulator Output (Bottom Middle):**
    *   The `pbksia_w` (integral component) and `pbkspa_w` (proportional component) are summed together.
    *   The result of this sum is then combined with `pbksdio_w` (derivative-related component) in a final summation block (V.7.2).
    *   The output of this final summation is `pbksdr_w`, the complete PID regulator output which will drive the fuel pump low-pressure control.


--- Page 122 ---

This page contains two Simulink diagrams, analyzing automotive control logic related to fuel pump pressure.

## Function

The document presents two interconnected control diagrams:
1.  **Figure 43.10.11 (FUSL, Fuel pump low pressure control):** This diagram's primary function is to determine a boolean flag `B_regwindup`, likely indicating a condition for regulator anti-windup or a specific operational state for the fuel pump low pressure control. It evaluates various pressure thresholds and system feedback/status bits.
2.  **Figure 43.10.12 (OPM_20MS/PI_ADAP_20MS/PSOLL_ADAP):** This diagram calculates a modified pressure setpoint `pbksollmod_w`. It combines a nominal pressure setpoint (`pbksoll_w`), a scaled measured pressure (`pbksdr_w`), and an output from a feedback regulator (`FBREG`). The `FBREG`'s operation (specifically its "weighting") is adapted based on safety/overrun conditions and BKS (Bremse Kraft Sensor / Brake Force Sensor) errors.

## Inputs

**For Figure 43.10.11 (FUSL):**
*   `lepwmbks_w`: (Input Port 1) A pressure-related value, likely actual or demand.
*   `pbksdiff_w`: (Input Port 3) A pressure difference or deviation.
*   `B_frdbks`: (Input Port 2) A boolean feedback or fault status flag.
*   `CWBKS5`: An integer value, likely containing status bits.
*   **Parameters/Constants:** `LEPWMUMX`, `PBKSDFWUOF`, `LEPWMUMN`, `-1`, `PBKSDFWUOFS` (boolean flag or parameter), `Index Base: 0`, `bit_sel = 2`.

**For Figure 43.10.12 (OPM_20MS/PI_ADAP_20MS/PSOLL_ADAP):**
*   `pbksoll_w`: (Input Port 2) Nominal pressure setpoint.
*   `pbksdr_w`: (Input Port 1) Measured or actual pressure.
*   `B_sa`: (Input Port 4) A boolean flag, possibly related to safety or overrun (Schubabschalten).
*   `CWBKS2`: (Input Port 5) An integer value, likely containing status bits.
*   `B_erdbksy`: (Input Port 3) A boolean flag, likely indicating a BKS-Error (Bremse Kraft Sensor / Brake Force Sensor error).
*   **Parameters/Constants:** `7`, `0` (used in bit selection and logical checks).

## Outputs

**For Figure 43.10.11 (FUSL):**
*   `B_regwindup`: (Output Port 1) A boolean flag indicating a regulator wind-up condition or specific operational state.

**For Figure 43.10.12 (OPM_20MS/PI_ADAP_20MS/PSOLL_ADAP):**
*   `pbksollmod_w`: (Output Port 1) The modified pressure setpoint.

## Logic Flow

**Figure 43.10.11 (FUSL):**

1.  **High Pressure Condition Check (Upper Path):**
    *   Compares `lepwmbks_w` with `LEPWMUMX`. If `lepwmbks_w > LEPWMUMX`, this condition is TRUE.
    *   Compares `pbksdiff_w` with `PBKSDFWUOF`. If `pbksdiff_w > PBKSDFWUOF`, this condition is TRUE.
    *   These two boolean conditions are combined with an `AND` gate (V.6.6). Let's call the result `Condition_High`.
2.  **Low Pressure Condition Check (Middle Path):**
    *   `pbksdiff_w` is multiplied by `-1` (V.7.3).
    *   The result is compared with `LEPWMUMN`. If `(pbksdiff_w * -1) < LEPWMUMN`, this condition is TRUE.
    *   This boolean result is combined with `PBKSDFWUOFS` (which is likely a boolean flag or parameter, V.6.4) using an `AND` gate (V.6.6). Let's call the result `Condition_Low`.
3.  **Combined Pressure Conditions:**
    *   `Condition_High` and `Condition_Low` are combined with an `OR` gate (V.6.3). Let's call the result `Pressure_Combined_OR`.
4.  **Feedback/Status Condition Check (Lower Path):**
    *   A `GET BIT` block (V.7.3) extracts bit `2` from the integer `CWBKS5`. The output is a boolean. Let's call it `Bit_CWBKS5_2`.
    *   The boolean `B_frdbks` is inverted by a `NOT` gate (V.6.3). Let's call it `NOT_B_frdbks`.
    *   `Bit_CWBKS5_2` and `NOT_B_frdbks` are combined with an `OR` gate (V.6.3). Let's call the result `Feedback_Combined_OR`.
5.  **Final Output:**
    *   `Pressure_Combined_OR` and `Feedback_Combined_OR` are combined by a final `AND` gate (V.6.6).
    *   The output of this final `AND` gate is `B_regwindup`.

**Figure 43.10.12 (OPM_20MS/PI_ADAP_20MS/PSOLL_ADAP):**

1.  **Scaled Measured Pressure:**
    *   The measured pressure `pbksdr_w` is multiplied by a constant `7` (V.7.3). Let's call this `Scaled_pbksdr`.
2.  **Controller Weighting Condition Logic:**
    *   `GET BIT` block (V.7.0): Extracts bit `0` from the integer `CWBKS2`. Let's call this `Bit_CWBKS2_0`.
    *   `Condition_A_Intermediate`: A block labeled "Check ~= 0" (V.6.6) processes `B_sa` and `Bit_CWBKS2_0`. This block likely outputs TRUE if `B_sa` is TRUE or `Bit_CWBKS2_0` is TRUE (effectively an OR gate).
    *   `Condition_B_Intermediate`: Another "Check ~= 0" block (V.6.6) processes `B_erdbksy`. This likely passes `B_erdbksy` directly as a boolean.
    *   These two intermediate conditions (`Condition_A_Intermediate` and `Condition_B_Intermediate`) are combined by an `OR` gate (V.6.3). Let's call the result `FBREG_Activation_Condition`.
3.  **Feedback Regulator (FBREG):**
    *   The `FBREG_Activation_Condition` is an input to the `FBREG` block (V.6.4). As per the German description, this condition "weights the controller part depending on overrun shutdown and BKS-Error." This suggests `FBREG` calculates a correction value (`FBREG_output`), and its magnitude or enabling is controlled by `FBREG_Activation_Condition`.
4.  **Modified Pressure Setpoint Calculation:**
    *   The final modified pressure setpoint `pbksollmod_w` is calculated by summing (`+` block, V.7.2) the nominal pressure setpoint `pbksoll_w`, the `Scaled_pbksdr`, and the `FBREG_output`.


--- Page 123 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, titled "OPM_20MS/WOBBEL_ADAP" under "FUSL, Fuel pump low pressure control," primarily functions as an **adaptive control module for the fuel pump low-pressure system.** Its main goal appears to be to calculate and adapt desired fuel pressure setpoints (`pbksoll_w` and its derivatives) by considering various vehicle states, driver inputs, and mitigating system oscillations or "wobbling" behavior. The "ADAP" in the name indicates an adaptive control strategy, likely to ensure stable and optimal fuel pressure delivery under diverse operating conditions and potential disturbances.

## Inputs

The diagram takes a comprehensive set of inputs, reflecting various states and conditions of the vehicle and its subsystems. These inputs are fed into the different processing blocks. Key inputs include:

*   **Brake System Signals:** `B_dbewbks_fb1`, `pbksadw_w_fb`, `B_bksspa`, `B_dhbks`, `B_flafobks`, `B_fstcanok`, `B_tfstok`, `B_kfntbks`, `B_pbksprof`, `B_ebks`, `B_spwfbks`, `B_dmkrhst`, `B_dmkrwb`, `B_pbkswb`, `B_ladbksm`, `B_bksacwe`, `CWBKS2`, `CWBKS3`, `CW_BK_1`, `CW_BK_2`. Many of these are likely feedback or status signals from the brake system (`bks` often denotes *Bremssystem*).
*   **Engine/Vehicle Dynamics:** `nmot_w` (engine speed), `tmot` (engine temperature), `vfzg_w` (vehicle speed), `dmkrhdev_w` (engine torque deviation?), `dmkrhdef_w` (engine torque default?), `vgeshdp_w` (total vehicle power?).
*   **Driver & Ignition Status:** `B_kuppl` (clutch status), `tnse_w` (gear engaged?), `B_efahr` (drive status), `B_getankt` (refueling status), `B_tfstausw` (fuel tank status selection?), `B_kl15` (ignition terminal 15 status - "ignition on").
*   **Desired Pressure/Reference:** `pbksoll_w1` (initial desired pressure), `pbksadw_w_in` (adaptive desired pressure input).
*   **System Internal/Adaptive Flags:** `ADBK SINI` (adaptive system initialization feedback), `LV_CLR_FMY_BKS_ACT_tmp` (low voltage clear family brake system activate temporary), `reset_vrhdrf_LT` (reset long-term history of reference header).

## Outputs

The diagram produces several outputs, primarily modified or adapted pressure setpoints and various status flags or processed signals:

*   **Adapted Pressure Setpoints:** `pbksoll_w` (modified desired pressure), `twobpos_w` (oscillation threshold/position), `dpbksoll_w` (desired pressure derivative/difference), `pbksollmod_w` (modified desired pressure), `pbksadwa_w` (adapted desired pressure), `pbksadw_w` (final adapted desired pressure), `pbksaw_w` (likely an alternative or further processed adapted pressure).
*   **Brake System Processed Values:** `B_dbewbks`, `B_bksspa`, `dmkrhdev_w`, `nmot_w`, `tmot`, `B_dhbks`, `B_sa`, `vfzg_w`, `B_flafobks`, `B_kuppl`, `tnse_w`, `B_fstcanok`, `B_tfstok`, `B_efahr`, `B_kfntbks`, `B_pbksprof`, `B_ebks`, `B_getankt`, `B_tfstausw`, `B_kl15`, `B_spwfbks`, `dmkrhdef_w`, `B_dmkrhst`, `B_dmkrwb`, `B_pbkswb`, `B_ladbksm`, `B_wbksez`, `B_bksacwe`, `B_wbkse`, `CW_BKS`, `CWBKS3`, `CWBKS2`, `PBKSSP`, `CWBKSMPI`, `B_mpi`. Many of these are "pass-through" outputs, meaning they are inputs that are also propagated outwards, potentially for monitoring or use in other modules.
*   **Adaptive Control Status/Signals:** `B_nfwohbks` (no "wobble" brake system status?), `vrhdrf_w` (filtered reference header), `B_ffwobres` (feed-forward wobble result?), `LV_CLR_FMY_BKS_ACT` (low voltage clear family brake system activate), `B_wobze` (wobble time?), `B_wobokvd` (wobble OK voltage/deviation?).

## Logic Flow

The diagram processes inputs through a series of interconnected subsystems, each likely performing a specialized task in the adaptive fuel pressure control:

1.  **Initial Signal Collection and Forwarding:** A multitude of raw and pre-processed signals enter the main system. Many of these signals are immediately forwarded as outputs, serving as data points for other modules or for logging/display.
2.  **`CWBKS` (X.3.2.1) - Characteristic Brake System Values:** This subsystem takes numerous brake-related inputs (`B_bksacwe`, `B_wbkse`, `B_kl15_1`, etc.). It likely processes these raw brake signals to derive characteristic values or consolidated status flags (e.g., `CW_BKS`, `CWBKS3`, `PBKSSP`) that abstract the brake system's state for subsequent control logic.
3.  **`WOBBELN` (X.3.2.2) - Oscillation Mitigation/Analysis:** This block receives the initial desired pressure (`pbksoll_w1`), brake system status (`B_wbkse`, `B_kl15`), and a feedback signal (`B_nfwohbks`), as well as adapted pressure feedback (`pbksadw_w_fb`). Its primary role is to analyze or mitigate pressure oscillations ("WOBBELN"). It produces a modified desired pressure (`pbksollmod_w`), signals related to oscillation characteristics (`twobpos_w`, `dpbksoll_w`), and an updated `B_nfwohbks`. This suggests it could be a disturbance observer or a filter to smooth out pressure commands.
4.  **`ADAP` (X.3.2.3) - Adaptive Control Core:** This is the central adaptive component. It takes adapted pressure input (`pbksadw_w_in`), dynamic signals (`vgeshdp_w`, `vrhdr_w`, `dmkrhdev_w`, `B_hrdynaw`), and adaptive initialization signals (`ADBK SINI`, `LV_CLR_FMY_BKS_ACT_tmp`, `reset_vrhdrf_LT`). It computes adapted pressure values (`pbksadwa_w`), filter parameters (`vrhdrf_w`), feed-forward terms (`B_ffwobres`), and status flags (`LV_CLR_FMY_BKS_ACT`, `B_wobze`, `B_wobokvd`). This module likely implements the core adaptive algorithms, adjusting control parameters or setpoints based on real-time conditions and system responses.
5.  **`PBKSADWA` (X.3.2.4) - Adapted Pressure Finalization:** This subsystem refines the adapted pressure values. It takes inputs such as a temporary adapted pressure (`pbksadw_w_tmp`), brake system status (`B_ebks1`), refueling status (`B_getankt1`), and other dynamic signals. It uses these to produce the final adapted pressure outputs (`pbksadw_w`, `pbksaw_w`). The presence of `V.6.1` suggests potential versioning or selection logic for these outputs, possibly switching between different adaptation strategies or fixed values based on conditions.
6.  **`ADBSINI1` - Adaptive Initialization:** This small block within the diagram, indicated by `1/z` (a delay or memory block) and `Init = 0`, likely handles the initialization or reset logic for adaptive parameters. It receives `LV_CLR_FMY_BKS_ACT_tmp` and outputs `ADBK SINI`, which feeds back into the `ADAP` and `PBKSADWA` modules, ensuring that the adaptive states are correctly initialized or re-initialized under specific conditions (e.g., ignition on, system reset).

In summary, the logical flow moves from collecting raw vehicle data, processing it into characteristic states (especially brake-related), mitigating oscillations, applying adaptive control algorithms, and finally producing refined, adapted fuel pressure setpoints for the low-pressure fuel pump, all while managing the initialization of adaptive states.


--- Page 124 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "FUSL Fuel pump low pressure control", is responsible for determining the activation status of a "wobble" function (`B_wobkse`) within the fuel pump low-pressure control system. The "wobble" likely refers to a specific operational mode, adaptation strategy, or diagnostic routine for the fuel pump, aiming to manage pressure pulsations or optimize pump performance under various conditions. The system combines numerous vehicle status flags, sensor readings, and calculated values through a series of logical operations and checks to enable or disable this function. The path "OPM_20MS/WOBBEL_ADAP/BEDWOB/BWOBSP" suggests it's part of an operational mode (20ms cycle) for wobble adaptation and potentially a "bed wobble" (related to pump mounting or specific operating states), ultimately yielding a Boolean wobble setpoint or active flag.

## Inputs
The diagram receives a comprehensive set of inputs, encompassing digital status words, analog sensor readings, and boolean flags:

1.  **`CWDKS` (24), `CWDKS3` (25), `CWDKS2` (26), `CWDKSMPI` (28):** Digital status words, likely containing multiple bit-encoded information about various system states.
2.  **`pbksoll_w` (2):** Analog input, likely the desired (Sollwert) low-pressure value.
3.  **`pbksadw_w_fb` (3):** Analog input, likely the actual low-pressure feedback value or an adaptation factor.
4.  **`B_bksspa` (4):** Boolean, indicating if the brake pedal is active or brake system status.
5.  **`PBKSSP` (27):** Analog, a pressure threshold or setpoint for the brake system.
6.  **`tmot` (8):** Analog, engine or motor temperature.
7.  **`B_dhbks` (9):** Boolean, status related to a high brake condition or deceleration.
8.  **`B_sa` (10):** Boolean, possibly "System Active" or "Self-Adaptation" status.
9.  **`B_efahr` (17):** Boolean, indicating electric driving or engine running status.
10. **`B_stend` (7):** Boolean, indicating engine stop status.
11. **`PBKSWBMX`, `PBKSWBMN`:** Analog values, likely maximum and minimum limits for low-pressure wobble management.
12. **`B_ebks` (20):** Boolean, status of the Electronic Brake System.
13. **`vfzg_w` (11):** Analog, vehicle speed.
14. **`VFZGWBDKSE` (12):** Analog, a vehicle speed threshold for wobble activation.
15. **`B_flbfbks` (18):** Boolean, possibly related to brake fluid level.
16. **`B_kfntbks` (13):** Boolean, status of a comfort brake system.
17. **`B_kuppl` (14):** Boolean, indicating clutch engagement status.
18. **`tnse_w` (14):** Analog, engine speed.
19. **`TWATFSMX`:** Analog, a maximum time or temperature window for wobble activation.
20. **`B_fstcanok` (15), `B_fstok` (16):** Booleans, indicating CAN communication status (OK) and general system fault status (OK).
21. **`PBRSMX`, `PBRSMN`:** Analog values, likely maximum and minimum limits for pressure regulator speed management.
22. **`B_mpi` (29):** Boolean, status related to Multi-Point Injection.
23. **`B_kl15` (23):** Boolean, status of Ignition Terminal 15 (ignition ON).
24. **`B_dbewbks` (1):** Boolean, likely related to "de-wobble" or brake system condition.
25. **`B_tfstausw` (22):** Boolean, a temperature fault switch status.
26. **`B_getankt` (21):** Boolean, indicating if the vehicle has been refueled or fuel tank is full.
27. **`B_pbksprof` (19):** Boolean, indicating a low-pressure profile or pressure brake system profile.

## Outputs
The diagram produces several outputs, with `B_wobkse` being the primary overall output:

1.  **`B_bksacwe` (1):** Boolean, "Brake System Active" or "Wobble Control Enabled".
2.  **`B_spwfbs` (3):** Boolean, possibly "Speed Wobble Feedback System" status.
3.  **`dmkrhdef_w` (4):** Analog, likely related to a default damper motor control or high-pressure value.
4.  **`B_dmkrhst` (5):** Boolean, status of a damper motor control (high).
5.  **`B_dmkrwb` (6):** Boolean, status of damper motor control (wobble).
6.  **`B_wobkse` (2):** Boolean, the primary output indicating the "Wobble Active State" of the fuel pump low-pressure control.
7.  **`B_wbksez` (9):** Boolean, "Wobble Active Enabled Zone" or a similar readiness flag.

## Logic Flow

The logical flow can be broken down into three main sections represented by the subsystems, all contributing to the final decision for `B_wobkse`:

1.  **Input Conditioning and Pre-processing:**
    *   Various digital inputs (`CWDKS`, `CWDKS3`, `CWDKSMPI`) are processed by `GET BIT` blocks to extract specific bits. These bits are then often negated using `NOT` gates.
    *   Analog inputs like `tmot`, `vfzg_w`, `tnse_w`, `pbksoll_w`, `pbksadw_w_fb` are compared against thresholds (`PBKSSP`, `VFZGWBDKSE`, `TWATFSMX`) using `>` comparison blocks.
    *   `MIN/MAX` blocks (`MX`, `MN`) are used to select boundary values from inputs like `PBKSWBMX`/`PBKSWBMN` and `PBRSMX`/`PBRSMN`.
    *   Multiple boolean input flags (`B_dhbks`, `B_sa`, `B_efahr`, `B_stend`, `B_ebks`, `B_flbfbks`, `B_kfntbks`, `B_kuppl`, `B_fstcanok`, `B_fstok`, `B_mpi`) are directly used or negated.

2.  **Subsystem Processing:**

    *   **PBKSM Subsystem (`X.3.2.1.1`):** This large subsystem consolidates many of the pre-processed inputs.
        *   It feeds into a `TRUTHTABLE` block (`ZBSADWBKSE`), which is a complex decision logic. This `TRUTHTABLE` receives numerous boolean conditions and the outputs from the `MIN/MAX` blocks (`u`, `y`).
        *   The `TRUTHTABLE` outputs `B_bksacwe`, `B_ladbksm`, and `B_pbkswb`. These are critical intermediate boolean results for the final decision.
        *   Other outputs from PBKSM include `B_spwfbs`, `dmkrhdef_w`, `B_dmkrhst`, and `B_dmkrwb`, which are derived from internal logic involving `pbksoll_w`, `pbksadw_w_fb`, `B_bksspa`, `CWDKS2`, `PBKSSP`, and the `DMKR_CONTR` subsystem.

    *   **DMKR_CONTR Subsystem (`X.3.2.1.2`):** This block takes `B_kl15` (Ignition ON) as an input and outputs `B_dmkrwb`. This suggests it controls or determines a damper motor's wobble status based on the ignition state.

    *   **TWWOB Subsystem (`X.3.2.1.3` - "Wartezeit Wobbeln" / "Wobble Waiting Time"):** This subsystem processes `B_dbewbks`, `B_tfstausw`, `B_getankt`, and `B_pbksprof`. It likely implements a timer or state machine to determine if a specific waiting period or set of conditions related to "wobble" initiation has been met, outputting `B_wbksez`.

3.  **Final `B_wobkse` Decision:**
    *   The ultimate output `B_wobkse` is determined by a large `AND` gate (V.6.6) that combines 14 different boolean conditions.
    *   For `B_wobkse` to be TRUE, *all* 14 inputs to this final `AND` gate must be TRUE. These inputs include:
        *   `B_bksacwe` (from the PBKSM subsystem, indicating overall wobble control enablement).
        *   `B_dmkrwb` (from the DMKR_CONTR subsystem, related to damper motor wobble).
        *   A condition checking `NOT B_mpi` AND a specific bit from `CWDKSMPI`.
        *   A complex condition involving `NOT B_kuppl`, `NOT B_flbfbks`, `B_kfntbks`, `B_fstcanok`, `B_fstok`, and the comparison `tnse_w > TWATFSMX`. This section seems to evaluate driving conditions, clutch status, and system health.
        *   `NOT B_ebks` (Electronic Brake System not active).
        *   `NOT (vfzg_w > VFZGWBDKSE)` (Vehicle speed is not above a certain threshold).
        *   `B_ladbksm` (from the PBKSM TRUTHTABLE, likely "Load Brake System Active").
        *   `B_pbkswb` (from the PBKSM TRUTHTABLE, possibly "Low Pressure Brake System Wobble").
        *   `B_wbksez` (from the TWWOB subsystem, indicating that wobble waiting time conditions are met).

In essence, the diagram enforces strict logical conditions from various operational domains (engine, brakes, fuel system, vehicle dynamics, diagnostics, and timing) to safely and appropriately activate the fuel pump's "wobble" function for low-pressure control.


--- Page 125 ---

This page contains two Simulink diagrams, both related to "FUSL, Fuel pump low pressure control."

## Function
The primary function of these Simulink diagrams is to **monitor and diagnose the low-pressure fuel system for deviations, instabilities, and potential faults.** They process various pressure-related signals, system statuses, and engine parameters to generate diagnostic flags and a conditioned deviation value.

Specifically:
*   **Figure 43.10.15 (BWOBSP):** Detects conditions indicating a "wobble feedback status" (`B_spwfbks`), likely a fault or abnormal operating state, based on the difference between target and actual pressure, a defined wobble amplitude, and other system flags.
*   **Figure 43.10.16 (DMKR_CONTR):** Monitors a "pressure medium circuit" (DMKR, likely a fuel pressure circuit) for deviations from defined limits, applies hysteresis and time delays to filter transient events, and outputs a pressure window violation flag (`B_dmkrwb`), a time-delayed fault flag (`B_dmkrhst`), and a conditioned pressure deviation value (`dmkrhdef_w`).

## Inputs

**For Figure 43.10.15 (BWOBSP):**
*   `pbksoll_w`: Target or desired fuel low pressure.
*   `pbksadw_w`: Actual or measured fuel low pressure.
*   `AMPLWOB`: Wobble amplitude threshold (a parameter).
*   `PBKSSP`: Pressure setpoint status or a specific pressure-related parameter.
*   `B_bkssppa`: A boolean status signal, possibly related to pressure or a system enable.
*   `CWKBKS2`: An integer value containing various bit flags.
*   `bit_sel`: The specific bit index to be extracted from `CWKBKS2`.
*   `num_dec`: Input to the `GET BIT` block, possibly a reference value.

**For Figure 43.10.16 (DMKR_CONTR):**
*   `dmkrhdev_w`: Pressure deviation for the "pressure medium circuit".
*   `n_mot_w`: Engine speed (RPM).
*   `B_kl15`: Ignition status (true when ignition is on, Klemme 15).
*   `DMKRWBBMN`: Minimum boundary for the DMKR pressure window.
*   `DMKRWBBMX`: Maximum boundary for the DMKR pressure window.
*   `HDMKRWB`: Hysteresis band for the DMKR pressure window check.
*   `ZDMKRHDEV`: Zero deviation threshold for DMKR, used in hysteresis and rate limiting.
*   `KLGDDDMKR`: A 2D lookup table that maps engine speed to a time delay value.

## Outputs

**For Figure 43.10.15 (BWOBSP):**
*   `B_spwfbks` (Boolean): Wobble feedback status. This flag is true if a wobble-related anomaly is detected.

**For Figure 43.10.16 (DMKR_CONTR):**
*   `dmkrhdef_w` (Numeric): A conditioned or compensated value of the DMKR pressure deviation.
*   `B_dmkrhst` (Boolean): DMKR hysteresis status. This flag becomes true if the pressure deviation exceeds a specific threshold and persists for a duration determined by engine speed.
*   `B_dmkrwb` (Boolean): DMKR wobble status. This flag becomes true if the pressure deviation falls outside the defined operating window (considering hysteresis).

## Logic Flow

The image contains two distinct functional blocks:

**Logic Flow for Figure 43.10.15 (BWOBSP):**
1.  **Calculate Pressure Difference:** The absolute difference between `pbksoll_w` (target pressure) and `pbksadw_w` (actual pressure) is computed.
2.  **Check Wobble Amplitude:** This absolute pressure difference is compared against `AMPLWOB` (wobble amplitude threshold). If `|pbksoll_w - pbksadw_w| <= AMPLWOB` is true, this condition is satisfied.
3.  **Check Pressure Setpoint Status:** The `PBKSSP` input is checked to ensure it is not equal to zero (`PBKSSP ~= 0`).
4.  **Extract and Check Bit Flag:** A specific bit is extracted from `CWKBKS2` using the `GET BIT` block with `bit_sel` and `num_dec` inputs. The extracted bit is then checked to ensure it is not equal to zero.
5.  **Combine Conditions:** The boolean results from step 2, step 3, step 4, and the input `B_bkssppa` are fed into an `AND` gate. This means all four conditions must be true for the `AND` gate's output to be true.
6.  **Invert for Output:** The output of the `AND` gate is then inverted by a `NOT` gate.
7.  **Generate Output `B_spwfbks`:** The inverted signal is assigned to `B_spwfbks`. Therefore, `B_spwfbks` becomes true if *any* of the conditions from steps 2, 3, 4, or `B_bkssppa` are false.

**Logic Flow for Figure 43.10.16 (DMKR_CONTR):**

**Path for `B_dmkrwb` (DMKR Wobble Status):**
1.  **Define Hysteresis Window:** `DMKRWBBMN` and `HDMKRWB` are combined (e.g., summed) to form a lower threshold, and `DMKRWBBMX` and `HDMKRWB` are used to define an upper threshold. These form the set and reset points for a hysteresis block.
2.  **Check Pressure Against Window:** The `dmkrhdev_w` (pressure deviation) is evaluated by a hysteresis block (`LSP/RSP`). This block outputs a boolean indicating if `dmkrhdev_w` is within or outside the defined pressure window with the specified hysteresis.
3.  **Invert for Output:** The boolean output of the hysteresis block is inverted by a `NOT` gate.
4.  **Generate Output `B_dmkrwb`:** The inverted signal is assigned to `B_dmkrwb`. This flag is true if `dmkrhdev_w` falls *outside* the established pressure window (considering the hysteresis band `HDMKRWB`).

**Path for `dmkrhdef_w` (Conditioned DMKR Deviation):**
1.  **Rate Limit/Filter Deviation:** The `dmkrhdev_w` input is processed by a rate limiter or filter block (V. 5.3) using an initial value of `0` and a time constant/threshold of `ZDMKRHDEV`. This produces `dmkrhdev_w_LT`, a smoothed or rate-limited version of the deviation.
2.  **Sum Deviations:** The current `dmkrhdev_w` is added to the rate-limited `dmkrhdev_w_LT` using a sum block (V. 7.2).
3.  **Generate Output `dmkrhdef_w`:** The result of this summation is assigned to `dmkrhdef_w`, providing a combined or compensated deviation value.

**Path for `B_dmkrhst` (DMKR Hysteresis Status - Time Delayed Fault):**
1.  **Check Deviation Threshold with Hysteresis:** `dmkrhdev_w` is fed into a hysteresis block (V. 5.3) using `ZDMKRHDEV` as a threshold. This block outputs a boolean signal (`y`) that is true if the absolute deviation exceeds `ZDMKRHDEV` (with hysteresis) and remains true.
2.  **Determine Time Delay:** The `n_mot_w` (engine speed) is used as an input (along with a constant `0`) to the `KLGDDDMKR` 2D lookup table. This table outputs a time value `T`, which varies with engine speed.
3.  **Apply Time-on Delay:** The boolean signal `y` from step 1 (indicating persistent deviation) is fed as the input to a Time-on Delay block (`B_dmkrhst_Ton`, V. 5.3). The delay duration `T` for this block is provided by the lookup table result from step 2.
4.  **Generate Output `B_dmkrhst`:** The output of the Time-on Delay block is assigned to `B_dmkrhst`. This flag becomes true if the deviation condition (from step 1) remains continuously active for the duration calculated from the engine speed. This filters out momentary deviations to prevent false fault triggers.


--- Page 126 ---

This page contains two Simulink-style diagrams, likely representing logic for an automotive control system.

## Function

The diagrams describe a "Fuel pump low pressure control" system, specifically focusing on the generation and control of a "wobble" signal. This "wobble" likely refers to an intentional, small-amplitude oscillation or dither applied to the fuel pump's pressure setpoint. This technique can be used in automotive systems to prevent static friction, improve control accuracy, or facilitate adaptive learning.

**Diagram 1 (Figure 43.10.17 - `BEDWOB/TWWOB`):** Determines when the "wobble" sequence (`B_wbksez`) should be active. It sets the wobble state based on specific operating conditions and resets it either by a direct command or if the wobble has been active for a predefined maximum duration.

**Diagram 2 (Figure 43.10.18 - `WOBBELN`):** Generates the actual periodic wobble signal (`dpbksoll_w`) with a specific amplitude and period. It then superimposes this wobble onto a base pressure setpoint (`pbksoll_w`) to produce a modified setpoint (`pbksollmod_w`). It also outputs a flag indicating if the wobble feature is active.

## Inputs

**Common/Overall Inputs:**
*   `B_kl15`: Boolean, typically representing "Ignition ON" (Terminal 15 status).

**Diagram 1 Specific Inputs:**
*   `B_dbwebks`: Boolean, "Demand for wobble BKS" (BKS likely refers to 'Kraftstoffpumpe' - fuel pump or a specific control state).
*   `B_tfstausw`: Boolean, "Fuel tank status switch".
*   `B_getankt`: Boolean, "Vehicle refueled" status.
*   `B_pbksprof`: Boolean, "Pump BKS profile" or "Pump BKS professional" (likely a special mode or direct reset trigger).
*   `TWBKSDZ`: Constant, "Time Wobble BKS time threshold" (maximum allowed wobble duration).

**Diagram 2 Specific Inputs:**
*   `twobpos_w`: Analog, "Current wobble position/phase" (an input to this subsystem, likely representing the current phase from a higher level, but also an internal variable).
*   `TPERWOB`: Constant, "Wobble period time".
*   `B_wbkse`: Boolean, "Wobble BKS enable" (likely derived from `B_wbksez` or a similar overall enable).
*   `AMPLWOB`: Constant, "Wobble amplitude".
*   `pbksoll_w`: Analog, "Pump BKS setpoint (wobble base)" (the nominal fuel pressure target).

## Outputs

**Diagram 1 Specific Outputs:**
*   `B_wbksez`: Boolean, "Wobble BKS enable/set" (the primary output indicating the wobble sequence is active).
*   `not_B_wbksez`: Boolean, the inverted state of `B_wbksez`.

**Diagram 2 Specific Outputs:**
*   `B_nfwobbks`: Boolean, "Negative feedback wobble BKS" or "Wobble feature enabled/active" (a state flag for the wobble feature).
*   `dpbksoll_w`: Analog, "Delta pump BKS setpoint wobble" (the pure wobble signal).
*   `pbksollmod_w`: Analog, "Pump BKS setpoint modified" (the final fuel pressure setpoint including the wobble).

## Logic Flow

### Diagram 1: Wobble Sequence Enable (B_wbksez)

1.  **Set Condition Evaluation:**
    *   A `NOT` gate inverts `B_getankt`.
    *   An `AND` gate checks if `B_tfstausw` is TRUE AND `NOT B_getankt` is TRUE (i.e., fuel tank status is active and the vehicle is NOT being refueled).
    *   An `OR` gate combines the result of the `AND` gate with `B_dbwebks`. The output of this `OR` gate is the `SET` input to the SR Flip-Flop (`BET_K`). So, `B_wbksez` is commanded to be set if `B_dbwebks` is TRUE OR (`B_tfstausw` is TRUE AND `B_getankt` is FALSE).
2.  **Reset Condition Evaluation:**
    *   A "Time-On" timer block (`B_wbksez_Ton`) measures the duration for which `B_wbksez` (the output of the Flip-Flop) is TRUE.
    *   A `>` comparator checks if the accumulated time from `B_wbksez_Ton` exceeds the constant threshold `TWBKSDZ`.
    *   An `OR` gate combines the result of this comparison (`B_wbksez_Ton` > `TWBKSDZ`) with the `B_pbksprof` input. The output of this `OR` gate is the `RESET` input to the SR Flip-Flop (`BET_K`). So, `B_wbksez` is commanded to be reset if `B_pbksprof` is TRUE OR if `B_wbksez` has been continuously active for longer than `TWBKSDZ`.
3.  **Flip-Flop Operation:** The `SR Flip-Flop` (`BET_K`) holds the state of `B_wbksez`. It becomes TRUE when the `SET` condition is met and FALSE when the `RESET` condition is met. The `Q` output is `B_wbksez`, and the `~Q` (inverted Q) output is `not_B_wbksez`.

### Diagram 2: Wobble Generation and Signal Modification

1.  **Phase Accumulation Reset/Control (twobpos_w_SW):**
    *   A `NOT` gate inverts `B_kl15`.
    *   The `twobpos_w` input (current wobble phase) is compared with `TPERWOB / 2` (half the wobble period).
    *   The result of `twobpos_w > (TPERWOB / 2)` is inverted by a `NOT` gate (meaning `twobpos_w <= TPERWOB / 2`).
    *   These two inverted signals (`NOT B_kl15` and `NOT (twobpos_w > TPERWOB / 2)`) are combined by an `OR` gate. This OR gate's output feeds the `RESET` input (`R`) of the `twobpos_w_SW` block (which likely represents the internal phase accumulator or timer). This means the phase accumulator resets if `B_kl15` is FALSE OR if `twobpos_w` is in the first half of its cycle.
2.  **Wobble Feature Enable (B_nfwobbks):**
    *   An `OR` gate determines the state of `B_nfwobbks`. It is set to TRUE if `B_wbkse` is TRUE OR if `NOT (twobpos_w > TPERWOB / 2)` is TRUE (i.e., `twobpos_w <= TPERWOB / 2`). This implies the wobble is active if commanded (`B_wbkse`) or under specific phase conditions.
3.  **Wobble Signal Generation (dpbksoll_w):**
    *   The input `twobpos_w` is normalized by dividing it by `(TPERWOB / 2)`. This scaled phase signal, along with `AMPLWOB` and a constant `0`, are fed into a "triangle wave generator" block (`Check ~= 0`, V.6.6).
    *   This block outputs `dpbksoll_w`, which is a periodic triangular waveform with an amplitude of `AMPLWOB` (or from `0` to `AMPLWOB`, or `-AMPLWOB` to `AMPLWOB` depending on specific block behavior) varying according to the normalized phase.
4.  **Modified Pressure Setpoint (pbksollmod_w):**
    *   A `+` (summer) block adds the generated wobble signal `dpbksoll_w` to the base pressure setpoint `pbksoll_w`.
    *   The sum is the final `pbksollmod_w`, the fuel pump pressure setpoint including the wobble.


--- Page 127 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, titled "FUSL, Fuel pump low pressure control," is a submodule responsible for adaptation and control logic related to certain parameters, likely for a fuel pump or an associated system. The path "OPM_20MS/WOBBEL_ADAP/ADAP/PBKSADWA" suggests it is part of a 20ms operational module, specifically handling "wobble adaptation" and "PBKSADWA" (potentially an acronym for a brake-related or fuel-pressure adaptation value). Its primary function is to process various input signals, perform calculations involving filtering, lookup tables, limiting, and conditional logic, and then output adapted values and status flags to influence the overall fuel pump low-pressure control.

## Inputs

The key inputs to this Simulink diagram are:

1.  **`pbksadw_w_in` (Numeric):** A primary input value, likely a raw or measured signal that undergoes adaptation and limiting.
2.  **`reset_vrhdrf_L_T` (Boolean):** A flag to reset or enable/disable the `vrhdrf` filter/integrator.
3.  **`vgeshdp_w` (Numeric):** A measured or calculated value, used in comparison.
4.  **`vhdpvrfil` (Numeric):** A filtered hydraulic pressure or similar value, used in comparison.
5.  **`B_dbewbks_RSFF_R` (Boolean):** The "Set" input for an SR flip-flop, likely related to a debounced brake status.
6.  **`B_dbewbks_RSFF_S` (Boolean):** The "Reset" input for an SR flip-flop.
7.  **`B_nfwobblks` (Boolean):** A flag related to "wobble" (oscillation) detection or status.
8.  **`B_wbkse` (Boolean):** A brake-related status flag.
9.  **`dmkrhdev_w` (Numeric):** An input to a 1-D lookup table for calibration.
10. **`LV_CLR_FMY_BKS_ACT_tmp` (Boolean):** A temporary flag indicating whether a "clear family brake active" condition is present.
11. **`not_pbksadw_w_Lim` (Boolean):** A condition used in a switch for limiting `pbksadw_w`.
12. **`pbksadw_w_Lim` (Numeric):** A limit value used in a conditional switch.
13. **`ADWMX` (Constant/Parameter):** Maximum limit for saturation of `pbksadw_w_Lim`.
14. **`ADWMN` (Constant/Parameter):** Minimum limit for saturation of `pbksadw_w_Lim`.
15. **`DPADBKSIO` (Constant/Parameter):** A constant value used in a conditional switch.
16. **`DPADBKSAW` (Constant/Parameter):** A constant value used in a conditional switch.

## Outputs

The main outputs generated by this Simulink diagram are:

1.  **`pbksadw_w_Lim` (Numeric):** The adapted and/or saturated value of `pbksadw_w`.
2.  **`ADBKSPBKSADW` (Numeric):** An adapted or corrected value, typically derived from multiple sums and a minimum selection.
3.  **`LV_CLR_FMY_BKS_ACT_tmp` (Boolean):** The input `LV_CLR_FMY_BKS_ACT_tmp` passed through to an output for monitoring or further use.
4.  **`LV_CLR_FMY_BKS_ACT` (Boolean):** The cleared or actual "clear family brake active" status flag.
5.  **`pbksadw_w_tmp` (Numeric):** A temporary or conditionally selected value for `pbksadw_w`.
6.  **`vrhdrf_w` (Numeric):** The output of an integrator/filter, likely representing a filtered or adapted "headroom" value.
7.  **`B_dbewbks` (Boolean):** A status flag, likely indicating a debounced or active brake state.
8.  **`B_hrdynaw` (Boolean):** A status flag, potentially indicating a "hard dynamic active wobble" condition or similar.

## Logic Flow

The diagram's logic can be broken down into several interconnected paths:

1.  **`vrhdrf_w` Calculation (Filtering/Integration):**
    *   The input `pbksadw_w_in` is processed through a `Gain` block and combined with other signals (`vgeshdp_w`, `vhdpvrfil`) in comparators and sum blocks.
    *   The `reset_vrhdrf_L_T` input acts as both a reset and an enable signal (via a `NOT` gate) for an `Integrator` block (`V.5.3`).
    *   This integrator calculates `vrhdrf_w` (Output 2), which is likely a filtered or accumulated value over time. It has an initial value of 0 and an upper limit `ZVRHDRFBKS`.

2.  **`pbksadw_w_Lim` and `ADBKSPBKSADW` Calculation (Adaptation and Limiting):**
    *   `pbksadw_w_in` is fed into a `Saturation` block (`V.6.8`), which limits it between `ADWMN` and `ADWMX`. The output of this block is labeled `pbksadw_w_Lim`.
    *   This saturated `pbksadw_w_Lim` is then merged (`V.6.0`) with the input `pbksadw_w_Lim` (Inport 9) before being output as `pbksadw_w_Lim` (Outport 1), implying conditional usage of the input or saturated value.
    *   Several `Sum` blocks (`V.7.2`) combine various signals, including `ADWMX`, `ADWMN`, `vrhdrf_w`, and `IP_val` (from the `KLDVHRDRF` lookup table).
    *   The `KLDVHRDRF` lookup table (`V.7.3`) takes `dmkrhdev_w` as input to produce `IP_val`.
    *   These summed values, along with outputs from `Check ~= 0` blocks (which act as switches controlled by `DPADBKSIO` and `DPADBKSAW`), feed into a `Min` block (`V.6.0`).
    *   The final output of this `Min` block is `ADBKSPBKSADW` (Outport 9), representing an adapted and possibly minimum-selected value.

3.  **`LV_CLR_FMY_BKS_ACT` and `pbksadw_w_tmp` (Conditional Clearing/Selection):**
    *   The input `LV_CLR_FMY_BKS_ACT_tmp` (Inport 8) is passed through to Outport 8.
    *   It also controls an `If` block (`V.6.0`).
        *   If `LV_CLR_FMY_BKS_ACT_tmp` is true, `LV_CLR_FMY_BKS_ACT` (Outport 4) is set to `0` (cleared), and `pbksadw_w_tmp` (Outport 5) is directly assigned `pbksadw_w_in`.
        *   If `LV_CLR_FMY_BKS_ACT_tmp` is false, `LV_CLR_FMY_BKS_ACT`'s value is determined by a switch based on "Check ~= 0" logic (related to DPADBKSIO/DPADBKSAW). `pbksadw_w_tmp` is determined by a switch (`V.6.0`) based on `not_pbksadw_w_Lim`, selecting either `pbksadw_w_in` or the merged `pbksadw_w_Lim`.

4.  **`B_dbewbks` and `B_hrdynaw` (Flag Generation):**
    *   An `SR Flip-Flop` (`V.5.5`) is controlled by `B_dbewbks_RSFF_R` (Set) and `B_dbewbks_RSFF_S` (Reset), producing `B_dbewbks_RSFF`.
    *   `B_nfwobblks` is processed by a `Rising Edge` detection block (`V.5.3`), giving `B_nfwobblks_EF`.
    *   `B_dbewbks` (Outport 1) is set if `B_dbewbks_RSFF` is false (inverted by a `NOT` gate) AND `B_nfwobblks_EF` is true (using an `AND` gate `V.6.6`).
    *   `B_wbkse` is inverted (`NOT` gate `V.6.3`) to produce `B_ffwobres`.
    *   `B_dbewbks_RSFF` is also passed through a `Falling Edge` detection block (`V.5.3`) to produce `B_dbewbks_ER`.
    *   `B_hrdynaw` (Outport 7) is determined by an `OR` gate (`V.6.5`) that combines `B_ffwobres` with the output of another `OR` gate (`V.6.3`), which itself combines `B_dbewbks_ER` and `B_nfwobblks_EF`.

In essence, the diagram meticulously calculates and manages critical values and flags for adaptive control of a fuel system, possibly compensating for variations (wobble) and integrating brake-related conditions to ensure optimal low-pressure fuel delivery.


--- Page 128 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "FUSL, Fuel pump low pressure control," implements a comprehensive diagnostic and control logic for a fuel pump system. Its primary function is to monitor various feedback signals and system states, process them through logical operations, hysteresis filters, and flip-flops, and then generate output flags or control signals. These outputs likely represent error conditions, operational states, or commands for the fuel pump and related components, such as triggering a reset for pre-pressure control or indicating specific diagnostic states for fuel pump anomaly detection ("pbksadw" and "pbksadwa"). The inclusion of hysteresis blocks and flip-flops suggests state management, debouncing of noisy inputs, and latching of critical conditions.

## Inputs
The diagram takes the following inputs:

1.  **B_ebks** (Boolean): General electronic brake system (EBS) or internal error status.
2.  **pbksadw_w_fb** (Value): Feedback signal related to fuel pump diagnostic value 'pbksadw_w'.
3.  **B_pbksprof** (Boolean): Status indicating a "pump profiling" or professional mode.
4.  **B_kl15** (Boolean): Ignition status (Terminal 15, indicating ignition ON).
5.  **ADBSINI** (Value): Initial value for an adaptive or diagnostic system.
6.  **pbksadwa_w_fb** (Value): Feedback signal related to fuel pump diagnostic value 'pbksadwa_w'.
7.  **B_tfstaust** (Boolean): Tank filling status (e.g., fuel flap open/closed).
8.  **B_getankt** (Boolean): Fueling status (e.g., fuel tank is filled).
9.  **B_kl15_1** (Boolean): Another ignition status signal (Terminal 15).
10. **pbksadwa_w_fb1** (Value): Another feedback signal for 'pbksadwa_w'.
11. **B_pbksprof1** (Boolean): Another pump profiling status.
12. **B_dbewbks** (Boolean): Debounced BKS (electronic brake system or similar internal) status.
13. **B_hrdynaw** (Boolean): Hydraulic dynamic active warning/status.
14. **B_ebks1** (Boolean): Another general EBS or internal error status.
15. **B_wobze** (Boolean): Control signal related to "Wobbel" (oscillation) operation.

## Outputs
The diagram produces the following outputs:

1.  **reset_vrhdrf_LT** (Boolean): A reset signal for the "Vordruckregelung" (pre-pressure control) long-term adaptation.
2.  **pbksadw_w** (Boolean/Value): Fuel pump blocking current monitoring/diagnostic value or status.
3.  **pbksadwa_w** (Boolean/Value): Another fuel pump diagnostic/monitoring value or status, potentially related to adaptive or detailed analysis.
4.  **B_wobokvd** (Boolean): A control signal, likely related to an oscillation mode or a specific operational state of the fuel pump or its control valve.

## Logic Flow

The logic flow can be traced through distinct paths that contribute to each output:

**1. `reset_vrhdrf_LT` Generation:**
    *   **Path A:**
        *   `B_ebks` is compared if less than 2.
        *   `pbksadw_w_fb` is compared if greater than 2.
        *   The results of these two comparisons are combined with an `AND` gate.
    *   **Path B:**
        *   `B_pbksprof` is compared if less than 2.
        *   `B_kl15` is compared if less than 2.
        *   The results of these two comparisons are combined with an `AND` gate.
    *   The outputs of Path A and Path B `AND` gates are combined with an `OR` gate. This intermediate `OR` output signifies a condition for a potential reset.
    *   **Path C (Error Detection):**
        *   `ADBSINI` and `pbksadwa_w_fb` are passed through a `MAX` block, taking the higher value.
        *   This result is then fed into a hysteresis block (`B_kl15_adw_ER`, V.5.3), which introduces a threshold and prevents rapid switching due to signal noise. The output `y` from this block indicates an error state.
    *   Finally, the output of the combined `OR` gate (from Path A & B) and the error signal `y` from Path C are connected to another `OR` gate. The output of this `OR` gate directly produces `reset_vrhdrf_LT`. This means `reset_vrhdrf_LT` is activated if specific error conditions (Path A/B) or the detected error from Path C are present.

**2. `pbksadw_w` and `pbksadwa_w` Generation:**
    *   **`pbksadw_w`:** The output of the top `OR` gate (which also contributes to `reset_vrhdrf_LT`) is fed into a hysteresis block labeled `pbksadw_tmp2` (with a "Check ~= 0" input). The output of this hysteresis block directly forms `pbksadw_w`. This implies `pbksadw_w` is a filtered and stabilized version of the conditions that trigger `reset_vrhdrf_LT`.
    *   **`pbksadwa_w`:**
        *   `B_tfstaust` is inverted by a `NOT` gate.
        *   `B_getankt` is inverted by a `NOT` gate.
        *   The outputs of these two `NOT` gates are combined by an `AND` gate. This creates a condition based on the tank not being full and the refueling flap not being open (or similar logic depending on the exact meaning of the inputs).
        *   The output of this `AND` gate is fed into a hysteresis block (`pbksadwa_w_tmp`, with a "Check ~= 0" input). The output of this hysteresis block produces `pbksadwa_w`. This suggests `pbksadwa_w` is a diagnostic status related to the fuel tank and refueling process.

**3. `B_wobokvd` Generation:**
    *   **Path D (Flip-Flop `B_tfstausw_RSFF`):**
        *   `B_kl15_1` is inverted by a `NOT` gate.
        *   The output of this `NOT` gate and `pbksadwa_w_fb1` are fed into a hysteresis block (`B_stend_ER`, V.5.3) to generate an error signal `y`.
        *   This error signal `y` sets the `B_tfstausw_RSFF` (Reset-Set Flip-Flop, V.5.5).
        *   `B_pbksprof1` acts as the reset for this flip-flop.
        *   The `Q` output of this flip-flop (latching the error state) is then combined with `pbksadwa_w_tmp` (from the `pbksadwa_w` path) using an `AND` gate.
    *   **Path E (Flip-Flop `B_dbewbks_RSFF2`):**
        *   `B_dbewbks` is fed into a hysteresis block (`B_dbewbks_ER2`, V.5.3) to produce an error signal `y`.
        *   This error signal `y` sets the `B_dbewbks_RSFF2` (V.5.5).
        *   `B_wobze` acts as the reset for this flip-flop.
        *   The `Q` output of this flip-flop is then inverted by a `NOT` gate.
    *   **Final `OR` Combination:**
        *   The output of the `AND` gate from Path D.
        *   The inverted `Q` output from Path E.
        *   `B_hrdynaw` (directly).
        *   `B_ebks1` (directly).
        *   All these four signals are fed into a final `OR` gate. The output of this `OR` gate generates `B_wobokvd`. This indicates `B_wobokvd` is asserted if any of these diverse conditions related to ignition, `pbksadwa_w` status, debounced BKS error, hydraulic dynamic warnings, or general `ebks` errors are present. This complex logic suggests `B_wobokvd` is a master control or diagnostic flag for an advanced operational state like an oscillation mode (Wobbelbetrieb).


--- Page 129 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, named `43.10.4 OPM_100MS` and contextualized as "FUSL, Fuel pump low pressure control," implements a control logic module, likely for an adaptive or diagnostic function related to a low-pressure fuel pump system. It operates on a 100-millisecond execution cycle. The core of the functionality resides within the `PI_ADAP_100MS` subsystem, suggesting a Proportional-Integral (PI) control algorithm with adaptive capabilities, adjusting or calculating a fuel pressure-related value (`pbksadr_w`) based on various system inputs and conditions. A conditional logic branch allows for switching between the calculated adaptive value and a default/deactivated state.

## Inputs

The key inputs to this subsystem are:

*   **fc**: A function-call trigger signal, initiating the execution of this module.
*   **<B_switchbks>**: A boolean signal, acting as a primary mode switch or condition selector.
*   **<B_ktaabks>**: An input signal, likely related to a fuel tank sensor or a system status.
*   **<pbksoll_w>**: Desired fuel pressure or setpoint (Sollwert).
*   **<B_nmot>**: Engine speed or engine operation status.
*   **<B_kl15>**: Ignition status (e.g., ignition terminal 15 active).
*   **pbksia_w**: Actual or measured fuel pressure (Istwert).
*   **B_irgfrbks**: A boolean signal, potentially indicating an internal release or enable for the BKS system.
*   **rst_pbksadr_w**: A reset signal specifically for the `pbksadr_w` adaptive value.
*   **nvmy_pbksadr_w**: Non-volatile memory input for the `pbksadr_w` adaptive value, possibly for persistent storage or initial loading.

## Outputs

The main output of the `OPM_100MS` subsystem, and other globally available signals, are:

*   **opm_100ms**: The primary output of the subsystem, likely a bus containing a selection of processed internal signals.
*   **pbksadr_w**: The adapted or controlled fuel pump pressure value, made available globally via a `Goto` block after conditional merging.
*   **pbksiao_w**: An output from the `PI_ADAP_100MS` block, made available globally.
*   **pbksiad_w**: An output from the `PI_ADAP_100MS` block, made available globally.
*   **B_adibks**: An output from the `PI_ADAP_100MS` block, made available globally.
*   **zaabks_w**: An output from the `PI_ADAP_100MS` block, made available globally.
*   **B_aabks**: An output from the `PI_ADAP_100MS` block, made available globally.
*   **pbksadg_w**: An output from the `PI_ADAP_100MS` block, made available globally.
*   **B_zadbks**: An output from the `PI_ADAP_100MS` block, made available globally.
*   **B_adpfbks**: An output from the `PI_ADAP_100MS` block, made available globally.
*   **pbksaw_w**: An output from the `PI_ADAP_100MS` block, made available globally.

## Logic Flow

1.  **Function Call and Input Reception**: The subsystem is triggered by the `fc` function call. It receives multiple inputs, including desired/actual pressure values, engine/ignition states, and control flags.

2.  **Adaptive Control Core (PI_ADAP_100MS)**:
    *   All identified inputs (except `fc` and `B_switchbks`) are fed into the `PI_ADAP_100MS` subsystem.
    *   This internal block, likely implementing a PI controller with adaptive elements, processes these inputs. It uses the desired pressure (`pbksoll_w`) and actual pressure (`pbksia_w`), along with engine conditions (`B_nmot`, `B_kl15`) and other status/reset signals (`B_irgfrbks`, `rst_pbksadr_w`, `nvmy_pbksadr_w`, `B_ktaabks`) to calculate various control outputs and status flags.
    *   Its key outputs include `pbksadr_w` (the adaptive pressure or control variable), and several diagnostic/status signals like `pbksiao_w`, `pbksiad_w`, `B_adibks`, `zaabks_w`, `B_aabks`, `pbksadg_w`, `B_zadbks`, `B_adpfbks`, and `pbksaw_w`.

3.  **Conditional Output Selection (If-Else Logic)**:
    *   The boolean input `<B_switchbks>` drives an 'If' block (`cond_if`).
    *   **If `<B_switchbks>` is true**: The output `pbksadr_w` from the `PI_ADAP_100MS` subsystem is passed through. This implies the adaptive control is active and its calculated value is used.
    *   **If `<B_switchbks>` is false**: A constant value `0` (zero) is output. This suggests that when `B_switchbks` is false, the adaptive control output is effectively deactivated or reset to a default state.

4.  **Output Merging and Global Availability**:
    *   The result of the 'If' block (either the adapted `pbksadr_w` or `0`) is fed into a `Merge` block. This merged signal, still named `pbksadr_w`, is then transmitted to a `Goto` block, making it available for other parts of the larger Simulink model via a corresponding `From` block.
    *   Other outputs from the `PI_ADAP_100MS` block (e.g., `pbksiao_w`, `pbksiad_w`, `B_adibks`, etc.) are also directed to separate `Goto` blocks, indicating their global availability.

5.  **Subsystem Output (`opm_100ms`)**:
    *   A subset of the outputs from the `PI_ADAP_100MS` block (specifically `B_adibks`, `zaabks_w`, `B_aabks`, `pbksadg_w`, `B_zadbks`, `B_adpfbks`, `pbksaw_w`) are collected and potentially formed into a bus (indicated by the triangular bus creator/selector block). This bus then forms the primary output `opm_100ms` of the `43.10.4 OPM_100MS` subsystem.


--- Page 130 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink subsystem, titled "43.10.4.1 OPM_100MS/PI_ADAP_100MS" and contextualized as "FUSL Fuel pump low pressure control", is to implement a specific logic or algorithm for controlling the low-pressure fuel pump within an automotive system. The central green block, "I_ADAP X.4.1.1", likely represents an "Interface Adapter" or an "Adaptive" control module. It takes various input signals related to system status, desired values, and actual feedback, processes them, and outputs a set of control, status, and diagnostic signals relevant to the fuel pump's operation. The `f()` block and `_100MS` in the path name suggest this subsystem is a function-call triggered block, executing periodically, likely every 100 milliseconds.

## Inputs
The subsystem receives the following input signals (variables entering the green "I_ADAP" block):

*   **B_ktaabks**: Likely a boolean flag indicating a specific system state, possibly related to throttle kick-down or active acceleration.
*   **pbksoll_w**: A desired or setpoint pressure value for the low-pressure fuel pump.
*   **B_irgfrbks**: A boolean flag, potentially indicating a status or feedback from a recirculation gate or valve.
*   **B_nmot**: Engine speed or motor status.
*   **pbksia_w**: The actual or measured low-pressure fuel pump pressure.
*   **rst_pbksadr_w**: A reset signal for pressure adjustment or adaptation parameters.
*   **B_kl15**: Status of ignition terminal 15 (power on/off).
*   **nvmy_pbksadr_w**: A non-volatile memory value related to pressure adjustment or adaptation, allowing persistence across power cycles.

## Outputs
The subsystem generates the following output signals (variables leaving the green "I_ADAP" block):

*   **pbksiao_w**: An output signal related to the actual pump pressure, possibly a filtered or processed version.
*   **pbksiad_w**: An output signal related to the desired pump pressure, potentially an adjusted or commanded value.
*   **B_adbks**: A boolean flag, likely indicating pump diagnostic status or availability.
*   **zaabks_w**: A count or value associated with pump activity or operating cycles.
*   **B_aabks**: Another boolean flag, possibly related to overall pump activation or status.
*   **pbksadr_w**: A calculated pressure adjustment or control value.
*   **pbksadg_w**: A pressure adjustment gain or gradient.
*   **B_zadbks**: A boolean flag, potentially indicating a zero-point adjustment status for the pump.
*   **B_adpfbks**: A boolean flag, indicating the status of adaptive pressure feedback.
*   **pbksaw_w**: A command or status signal for the pump's active state or actuation.

## Logic Flow
1.  **Triggering:** The `f()` block indicates that this subsystem is a function-call subsystem. It is likely triggered periodically, perhaps by an operating system task, given the "OPM_100MS" (Operation Manager, 100 milliseconds) notation in the path.
2.  **Input Acquisition:** Upon being triggered, the "I_ADAP" block reads all its defined input signals. These inputs provide the current state of the engine, the desired fuel pressure, the actual fuel pressure feedback, and other relevant control and status flags.
3.  **Internal Processing (I_ADAP):** The core logic for fuel pump low-pressure control resides within the "I_ADAP X.4.1.1" subsystem. Without delving into the block itself, we can infer the following types of processing based on the input and output names:
    *   **Control Algorithm:** It likely compares the desired pressure (`pbksoll_w`) with the actual pressure (`pbksia_w`) to calculate necessary adjustments. This could involve PID (Proportional-Integral-Derivative) control or other feedback control strategies.
    *   **Mode Management:** The `B_ktaabks`, `B_irgfrbks`, and `B_kl15` inputs suggest that the control logic adapts its behavior based on different operating conditions (e.g., ignition on, specific driving demands, or system states).
    *   **Adaptation/Calibration:** The `rst_pbksadr_w` and `nvmy_pbksadr_w` inputs indicate that the subsystem incorporates mechanisms for resetting adaptive parameters and utilizing non-volatile memory values for long-term corrections or calibrations, ensuring consistent pump performance over time and across different vehicles.
    *   **Diagnostics and Monitoring:** The subsystem likely performs internal checks and monitors conditions to generate diagnostic flags (`B_adbks`, `B_zadbks`, `B_adpfbks`) and activity counters (`zaabks_w`).
4.  **Output Generation:** Based on its internal calculations and state, the "I_ADAP" block produces its output signals. These outputs represent the processed pressure values, commands to adjust the pump, and various status and diagnostic flags that would be used by other parts of the fuel system or engine control unit (ECU). For example, `pbksaw_w` would likely be a command to control the pump's operation.

In essence, this Simulink diagram represents a well-defined functional unit responsible for dynamic and adaptive control of the low-pressure fuel pump, taking into account various real-time and persistent system parameters.


--- Page 131 ---

This image clearly displays a Simulink diagram, characteristic of automotive control system development.

## Function

This Simulink diagram, titled "FUSL, Fuel pump low pressure control," is primarily responsible for managing the adaptation logic for a fuel pump, specifically for low-pressure conditions. It calculates, limits, and stores various adaptation values related to the fuel pump's operational characteristics and lifetime. The system aims to ensure optimal fuel pump performance by dynamically adjusting control parameters based on operating conditions, including "fast adaptation during short trip requests" ("Schnelle Adaption bei Kurztripanfo") and "adaptation of the tolerance system and lifetime changes of the electric fuel pump" ("Adaption der Toleranzanlage und der Lifetime-Veränderung der EKP"). It determines when adaptation is enabled, when values are reset (e.g., due to ignition reset), and how long-term and short-term adaptation values are calculated and persisted.

## Inputs

Based on the signals flowing into the main logic or originating from left-side source blocks:

*   **B_ktaabks**: A boolean flag, likely indicating an enabling condition or status for short-trip adaptation.
*   **ZKTADBK_TON, ZKAADBK_TON**: Parameters for 'Time On Delay' or edge-triggered behavior related to adaptation conditions.
*   **pbksia_w**: A working adaptation value, likely representing an instantaneous or current adaptation offset.
*   **pbksoll_w**: A target or desired value for fuel pump pressure or a related variable.
*   **B_irgfbrks, B_nmot**: Boolean or numerical signals related to engine/motor operating state (e.g., engine running, motor speed).
*   **igk_rst**: Ignition reset signal, typically a pulse when the ignition is turned off and on.
*   **nvmy_pbksadr_w**: A value read from non-volatile memory (NVM), representing a previously stored adaptation value.
*   **B_kl15**: Status of ignition terminal 15, indicating ignition ON.
*   **ZADKTBKS, ZADBK_S, PBKSADMN, PBKSADMX, PBKSAIMX, PBKSAIMN, PBKSIAVS, ZTDEBKS**: Various constants, parameters, or limits used in the adaptation calculations and comparisons (e.g., minimum/maximum adaptation values, debouncing times).

## Outputs

Based on the signals exiting the main logic or terminating at right-side sink blocks:

*   **B_zadbk_s**: A boolean flag, likely indicating that the "Adaptation Cycle BKS" is active.
*   **B_adpfbks**: A boolean flag, indicating that "Adaptation has occurred since the last power-fail."
*   **zaabks_w**: A calculated adaptation-related working value.
*   **B_aabks**: A boolean adaptation flag.
*   **B_adpbks**: A boolean adaptation flag.
*   **pbksadr_w, pbksadg_w, pbksaw_w**: Adapted values that are written to non-volatile memory (NVMY), likely representing different facets of the stored adaptation.
*   **pbksia_w_ITLim**: The adaptation value for tolerance and lifetime changes of the fuel pump.
*   **pbksiad_w**: A calculated adaptation value.
*   **pbksiao_w**: A calculated adaptation output value.

## Logic Flow

The diagram can be broadly divided into several interconnected sections:

1.  **Adaptation Enablement and Condition Monitoring (Top Left):**
    *   Inputs `B_ktaabks`, `ZKTADBK_S`, `ZKAADBK_S`, and `ZKAADBK_TON` are processed through 'Time On Delay' (TON) blocks (symbolized by 'T' with 'u' and 'y') and logical gates (AND, OR). These generate enabling conditions, such as `B_ktaabks_ER` and other intermediate flags.
    *   Comparisons (`<`, `>`) are made with `pbksia_w`, `PBKS ADMN`, and `PBKS ADMX` to check if `pbksia_w` is within acceptable adaptation bounds.
    *   Further logic involving `B_irgfbrks`, `B_nmot`, and `B_zaabks_w_SW` combines these conditions.
    *   The results of this section determine key adaptation status flags like `B_zadbk_s` (Adaptation cycle flag) and `B_adpfbks` (Adaptation occurred since powerfail). A `Merge` block suggests conditional assignment of `B_adpfbks`.

2.  **Fast/Short-Term Adaptation and Reset Logic (Mid-Left & Center):**
    *   The `igk_rst` (ignition reset) signal is crucial here. It's OR-ed with other conditions to generate `rst_pbksadr_w`, which acts as a reset signal for NVM and other adaptation states.
    *   `nvmy_pbksadr_w` (NVM read) is conditionally processed with `igk_rst` and other signals via an `AND` gate and a `Switch` block (labeled "Check == 0"), implying logic for loading initial values or forcing resets from NVM.
    *   Another series of `Switch` blocks (V.6.6 "Check == 0") also uses `B_ktaabks`, `ZADKTBKS`, `ZADBK_S`, `PBKSADMX`, and `PBKSAIMN` to conditionally select input values for the adaptation calculations. These switches often set initial conditions or limit values based on various fault or operational states.

3.  **Long-Term/Tolerance Adaptation Calculation (Mid-Right):**
    *   `pbksia_w` and other parameters (`R`, `IV`, `T`, `MX`, `MN`) feed into a block (V.5.4) which acts as a saturated integrator or a limited accumulator. This block calculates `pbksia_w_ITLim`, representing the long-term adaptation for tolerance and lifetime changes.
    *   The output `pbksia_w_ITLim` is then fed into a `NVMY` block (V.6.1), which writes the adapted values (`pbksadr_w`, `pbksadg_w`, `pbksaw_w`) to non-volatile memory for persistence across power cycles. The `rst_pbksadr_w` signal controls the NVM write operation.

4.  **Final Adaptation Value Derivation and Output (Lower Section):**
    *   `B_kl15` (ignition status) is processed through a TON block (`B_kl15_ER`) and a `NOT` gate. This result, along with `ZTD_EBKS`, contributes to the conditions for "Adaption nur bei quasi-stationären Betriebsbedingungen" (Adaptation only under quasi-stationary operating conditions). This implies that adaptation updates are only valid when the fuel pump and engine are in stable, defined operating states.
    *   `pbksia_w` and results from `Check == 0` switches are summed (V.7.2) and fed into another TON-like block (V.5.3, `pbksia_w_LT`), which calculates `pbksiao_w`. This is likely a long-term adaptation or smoothing filter.
    *   `pbksiad_w` is derived from `pbksia_w` and the output of a `Check == 0` switch via a `Switch` block (V.7.5), suggesting a selection between an adapted value and a default/initial value.
    *   The diagram ultimately outputs several adaptation values (`pbksiad_w`, `pbksiao_w`) and flags (`B_aabks`, `B_adpbks`) for use by other parts of the fuel pump control system.

In essence, the system continuously monitors various operational states and adaptation conditions, calculates short-term and long-term adaptation values, applies limits and resets as necessary, and persistently stores these adapted values to optimize the low-pressure control of the fuel pump throughout its service life and across different operating scenarios.


--- Page 144 ---

This page contains a Simulink-like block diagram.

## Function
The primary function of this module, titled "FUSL, Fuel pressure setpoint calculation," is to determine the basic fuel pressure setpoint for an automotive engine. This calculation considers various factors including the current engine operating state, applies static and dynamic limitations, and incorporates specific setpoints for limphome (fail-safe) operation.

## Inputs
The system receives a wide array of inputs, primarily categorized into:

1.  **Operating Condition and Status Inputs (from the green input block):**
    *   `<FUP>`: Actual Fuel Pressure.
    *   `<FUP SP CRCV>`: Fuel Pressure Setpoint Correction Value.
    *   `<FUP SP EXT>`: External Fuel Pressure Setpoint.
    *   `<IDX CMB MOD CUR>`: Index for Current Combustion Mode.
    *   `<IDX CMB MOD ST>`: Index for Combustion Mode State.
    *   `<LF TI MIN>`: Limp Home Time Minimum (likely a timer for degraded operation).
    *   `<LV ES>`: Live Engine Speed.
    *   `<LV FUP LIH H PRS CTL REQ>`: Live Fuel Pressure Limp Home High Pressure Control Request.
    *   `<LV FUP LIH L PRS CTL REQ>`: Live Fuel Pressure Limp Home Low Pressure Control Request.
    *   `<LV FUP SP REQ CRCV>`: Live Fuel Pressure Setpoint Request Correction Value.
    *   `<LV IGK>`: Live Ignition Key/Status.
    *   `<LV PU>`: Live Pump Unit Status.
    *   `<LV STST STOP REQ>`: Live Start-Stop Request.
    *   `<LV VCV CLOSE SL AD WAIT>`: Live Valvetrain Control Valve Close Slide Adjust Wait.
    *   `<MAF>`: Mass Air Flow.
    *   `<MFF SP FUP SP>`: Likely a factor or value for Fuel Pressure Setpoint.
    *   `<NC IDX SUM L PRS ST MPL>`: Numeric Index Sum Low Pressure State Multiple.
    *   `<NC IDX SUM L PRS ST SNG>`: Numeric Index Sum Low Pressure State Single.
    *   `<NC IDX SUM MPI>`: Numeric Index Sum Multi-Point Injection.
    *   `<NC NR BYTE INJ>`: Numeric Number of Byte Injections.
    *   `<NC NR CMB MOD>`: Numeric Number of Combustion Modes.
    *   `<NC NR INJ CMB>`: Numeric Number of Injections per Combustion.
    *   `<NC NR IP FUP SP BAS>`: Numeric Number IP Fuel Pressure Setpoint Base.
    *   `<NC NR MAF FUP SP>`: Numeric Number MAF Fuel Pressure Setpoint.
    *   `<NC NR N FUP SP>`: Numeric Number Engine Speed Fuel Pressure Setpoint.
    *   `<N 32>`: Engine Speed (32-bit value).
    *   `<STATE VVL MNG>`: State of Variable Valve Lift Management.
    *   `<TCO>`: Coolant Temperature.
    *   `<TCO ST>`: Coolant Temperature State.
    *   `<TFU>`: Fuel Temperature.

2.  **Control and Timing Inputs (from `APP_CDN` block):**
    *   `fc_INI`: Initialization flag, active on Reset (`RST`).
    *   `fc_OPM_10MS`: Operation mode flag for 10ms recurrence.
    *   `fc_OPM_SEG`: Operation mode flag for segment recurrence.

3.  **Internal Feedback Inputs:**
    *   `<FUP SP>`: Previous fuel pressure setpoint, used as feedback for both `opm_10ms` and `opm_seg` functions to enable stateful calculations (e.g., filtering, dynamic response).

## Outputs
The module produces the following key outputs:

*   **`<FUP SP>`**: The calculated Fuel Pressure Setpoint. This is the primary output representing the desired fuel pressure.
*   **`<FUP SP GRD SEG>`**: Fuel Pressure Setpoint Graded Segment. This could be a smoothed or filtered version of the setpoint, potentially used for specific control strategies or transitions.

## Logic Flow

1.  **Application Conditions and Triggering:**
    *   The `APP_CDN` (Application Conditions) block acts as the control sequencer. It defines the module's execution characteristics:
        *   **Initialization:** Triggered by `RST`, it activates the `fc_INI` signal.
        *   **Activation:** The module is "always" active.
        *   **Deactivation:** The module is "never" deactivated.
        *   **Recurrence:** It specifies two operational modes based on time (`10MS`) and event/segment (`SEG`), generating `fc_OPM_10MS` and `fc_OPM_SEG` signals, respectively.

2.  **Input Acquisition:**
    *   A multitude of inputs representing various engine parameters, sensor readings, states, and control requests are fed into the system (the large green block on the left). These inputs provide the necessary context for calculating the fuel pressure setpoint.

3.  **Initialization Function (`f() ini`):**
    *   This function is activated by the `fc_INI` signal during system reset or startup.
    *   It receives the general system inputs and likely initializes internal states, variables, or set initial values for the subsequent operational functions. Its output `ini` is passed to the other two main `f()` blocks, implying it sets up their initial conditions or configuration.

4.  **10ms Operational Function (`f() opm_10ms`):**
    *   This is a core calculation function that executes every 10 milliseconds, triggered by `fc_OPM_10MS`.
    *   It takes the comprehensive set of inputs from the left, the `ini` output, and critically, feedback from its *previous* output (`<FUP SP>`). This feedback loop is essential for dynamic control, filtering, and incorporating historical values into the current setpoint calculation.
    *   This block is responsible for calculating a dynamic fuel pressure setpoint based on real-time engine conditions and limitations.

5.  **Segment Operational Function (`f() opm_seg`):**
    *   This function is triggered by `fc_OPM_SEG`, likely at specific engine operating segments or events, potentially less frequently or asynchronously compared to the 10ms function.
    *   Similar to the 10ms function, it receives all general inputs, the `ini` output, and feedback from its own previous output (`<FUP SP>`).
    *   This function likely computes a 'graded' or smoothed setpoint (`<FUP SP GRD SEG>`), possibly to manage transitions between operating points or for stability purposes.

6.  **Setpoint Aggregation and Output (`V.6.9` block):**
    *   The results from the `opm_10ms` and `opm_seg` functions, along with various derived values (e.g., `FUP_SP_MAX`, `FUP_SP_LIM_DEC`, `FUP_SP_TMP`, and their associated Quality Values (`_QV`)), are fed into the `V.6.9` block.
    *   This block likely implements the final logic for selecting, limiting, filtering, and blending the different setpoint candidates, taking into account their quality and validity. It applies static and dynamic limitations as described in the module's function.
    *   It synthesizes the final `<FUP SP>` and `<FUP SP GRD SEG>` based on all contributing factors, including limphome conditions.

7.  **Output Distribution:**
    *   The module then provides the final calculated **`<FUP SP>`** and **`<FUP SP GRD SEG>`** to other parts of the engine control system.


--- Page 145 ---

This page contains two Simulink diagrams that are part of an automotive fuel pressure setpoint calculation system.

## Function

The primary function of these diagrams is to manage and initialize parameters related to fuel pressure setpoint (FUP_SP) and to evaluate specific operational requests, specifically for "Low Pressure Stage" (L_PRS_ST) and "Multi-Point Injection" (MPI) modes, which influence the overall fuel pressure setpoint calculation.
The first diagram (43.12.1) handles the initialization of various fuel pressure setpoint parameters to default or predefined values. The second diagram (43.12.2) calculates logical flags indicating requests for specific fuel system operating conditions (low pressure stage or MPI) based on combustion mode and injection mode status. These flags are then used by an auxiliary fuel pressure setpoint calculation function.

## Inputs

The key inputs to these diagrams are:

*   **C_FUP_SP_L_PRS_ST**: A configurable constant or value representing the fuel pressure setpoint for the low-pressure stage.
*   **NC_NR_IP_FUP_SP_BAS**: A nominal constant or value representing the base fuel pressure setpoint.
*   **IDX_CMB_MOD_ST**: An index or status indicating the current combustion mode.
*   **NC_IDX_SUM_L_PRS_ST_SNG**: A nominal constant index representing the sum for a single low-pressure stage request.
*   **NC_IDX_SUM_L_PRS_ST_MPL**: A nominal constant index representing the sum for a multiple low-pressure stage request.
*   **IDX_CMB_MOD_INJ_MOD**: An index or status indicating the current combustion mode's injection mode.
*   **NC_IDX_SUM_MPI**: A nominal constant index representing the sum for Multi-Point Injection.
*   **Literal Constants**: `0` and `347776` used for initializing certain parameters.

## Outputs

The key outputs from these diagrams are:

*   **FUP_SP_TMP**: Initialized temporary fuel pressure setpoint.
*   **FUP_SP_LIM**: Initialized fuel pressure setpoint limit.
*   **FUP_SP**: Initialized main fuel pressure setpoint.
*   **IDX_FUP_SP_SEL_CMB_MOD**: Initialized index for selecting combustion mode for fuel pressure setpoint.
*   **ctr_fup_sp_vvl_lgrd**: Initialized counter for variable valve lift load grid related to fuel pressure setpoint.
*   **FUP_SP_MAX**: Initialized maximum fuel pressure setpoint.
*   **LV_FUP_SP_GRD_ACT**: Initialized logical value for fuel pressure setpoint grid active status.
*   **FUP_SP_GRD**: Initialized fuel pressure setpoint grid value.
*   **FUP_SP_GRD_SEG**: Initialized fuel pressure setpoint grid segment value.
*   **LV_FUP_SP_L_PRS_ST_REQ**: Calculated logical value indicating a request for low pressure stage operation.
*   **LV_FUP_SP_MPI_INJ_REQ**: Calculated logical value indicating a request for Multi-Point Injection (MPI).
*   **clc_fup_sp_aux**: A bundled output representing inputs to an auxiliary fuel pressure setpoint calculation function.

## Logic Flow

**1. 43.12.1 Initialization function:**
This diagram initializes various fuel pressure setpoint-related variables, typically at system startup or reset.

*   The input `C_FUP_SP_L_PRS_ST` (Low Pressure Stage Setpoint Constant) is used to initialize three output signals: `FUP_SP_TMP` (Temporary Setpoint), `FUP_SP_LIM` (Setpoint Limit), and `FUP_SP` (Main Setpoint). The `V.6.8` blocks likely represent data type conversions or simple assignments.
*   The input `NC_NR_IP_FUP_SP_BAS` (Base Fuel Pressure Setpoint) is used to initialize `IDX_FUP_SP_SEL_CMB_MOD` (Index to Select Combustion Mode). The `V.6.11` block performs a similar assignment/conversion.
*   A constant value `347776` is used to initialize `ctr_fup_sp_vvl_lgrd` (Counter for Variable Valve Lift Load Grid).
*   The constant value `0` is used to initialize several logical and numerical parameters: `FUP_SP_MAX` (Maximum Setpoint), `LV_FUP_SP_GRD_ACT` (Grid Active Flag), `FUP_SP_GRD` (Grid Value), `FUP_SP_GRD_SEG` (Grid Segment), `LV_FUP_SP_L_PRS_ST_REQ` (Low Pressure Stage Request Flag), and `LV_FUP_SP_MPI_INJ_REQ` (MPI Injection Request Flag).
*   All these initialized values are then connected to a vertical bus that feeds into an "ini" block, which represents the initialization routine for these parameters.

**2. 43.12.2 Function for calculation of fuel pressure setpoint - Evaluation of requests for exclusive MPI and low pressure start operation:**
This diagram evaluates conditions to generate logical request flags for specific fuel system operations.

*   **Low Pressure Stage Request (LV_FUP_SP_L_PRS_ST_REQ) Calculation:**
    *   The current combustion mode status (`IDX_CMB_MOD_ST`) is compared for equality (`==`, V.6.6 block) with `NC_IDX_SUM_L_PRS_ST_SNG` (Nominal Constant for Single Low Pressure Stage).
    *   Simultaneously, `IDX_CMB_MOD_ST` is also compared for equality (`==`, V.6.6 block) with `NC_IDX_SUM_L_PRS_ST_MPL` (Nominal Constant for Multiple Low Pressure Stage).
    *   The boolean results of these two comparisons are fed into an `OR` logic block (V.6.7).
    *   The output of the `OR` block sets `LV_FUP_SP_L_PRS_ST_REQ` to true if the combustion mode matches either the single or multiple low-pressure stage conditions.

*   **Multi-Point Injection Request (LV_FUP_SP_MPI_INJ_REQ) Calculation:**
    *   The combustion mode's injection mode (`IDX_CMB_MOD_INJ_MOD`) is compared for equality (`==`, V.6.6 block) with `NC_IDX_SUM_MPI` (Nominal Constant for MPI).
    *   The boolean result of this comparison directly sets `LV_FUP_SP_MPI_INJ_REQ`.

*   Finally, both calculated logical request flags (`LV_FUP_SP_L_PRS_ST_REQ` and `LV_FUP_SP_MPI_INJ_REQ`) are bundled together on a bus and passed as inputs to a block labeled `clc_fup_sp_aux`, which presumably performs further auxiliary calculations for the fuel pressure setpoint based on these requests.


--- Page 146 ---

This page contains a Simulink diagram illustrating the logic for calculating a basic fuel pressure setpoint within an automotive system.

## Function

The primary function of this Simulink diagram is to calculate the **basic fuel pressure setpoint (`FUP_SP_TMP`)** and a **fundamental basic fuel pressure setpoint (`fup_sp_bas`)** based on various engine operating conditions, specific requests, and vehicle states. It employs a prioritized conditional logic structure to select or calculate the appropriate setpoint from multiple possible sources, such as manual overrides, external requests, start-stop conditions, fuel pump control, and engine parameters.

## Inputs

The diagram utilizes several inputs, categorized as boolean flags (for conditions) and numeric values (for calculations or lookup table inputs):

**Boolean/Enable Inputs:**
*   `LC_FUP_SP_MAN_ACT`: Manual fuel pressure setpoint activation.
*   `LV_FUP_SP_EXT_REQ`: External fuel pressure setpoint request.
*   `LV_STST_STOP_REQ`: Start-stop system stop request.
*   `LV_FUP_SP_L_PRS_ST_REQ`: Low pressure fuel pump pressure request from a state machine.
*   `LV_PUC`: Fuel pump control active (Pump Unit Control).
*   `LV_FUP_SP_MPI_INJ_REQ`: Multi-port injection fuel pressure setpoint request.
*   `LC_FUP_SP_PU_ACT`: Fuel pump activation for pressure build-up.
*   `LV_PU`: Pressure unit active/request.
*   `LV_ST_END`: Start-stop system end condition.
*   `LF_STATE_IV_PREV`: Previous state of an IV (e.g., Ignition Voltage related) condition.
*   `LC_FUP_SP_ST_NO_INJ`: No injection fuel pressure setpoint activation.
*   `LV_FUP_SP_REQ_CRCV`: Fuel pressure setpoint request for CRCV (Combustion Ratio Control Valve or similar).
*   `LC_FUP_SP_SEL_MFL`: Selector for the mass flow fuel pressure lookup table.

**Numeric Inputs:**
*   `LC_FUP_ACT_FUP_SP_PUC`: Active fuel pump setpoint for PUC (value).
*   `FUP_SP_PUC`: Fuel pump setpoint for PUC (value).
*   `N_32`: Engine speed.
*   `MFF_SP_FUP_SP`: Mass flow fuel pressure setpoint (for lookup table).
*   `TCO_ST`: Coolant temperature status (for lookup table).
*   `input<fup_sp_bas_clc>`: Generic input for the basic setpoint calculation function.
*   `MAF`: Mass Air Flow (appears as an input but not directly connected to a specific lookup table axis visible, potentially a parameter or implicit to another block).

**Constants (Internal to the diagram logic):**
*   `C_FUP_SP_MAN`: Constant value for manual setpoint.
*   `C_FUP_SP_EXT`: Constant value for external setpoint.
*   `C_FUP_SP_STST`: Constant value for start-stop setpoint.
*   `C_FUP_SP_L_PRS_ST`: Constant value for low pressure setpoint.

## Outputs

The diagram generates two main outputs related to fuel pressure setpoints:

*   `FUP_SP_TMP`: The temporary or active fuel pressure setpoint (Numeric). This is the result of the prioritized conditional logic.
*   `fup_sp_bas`: The basic fuel pressure setpoint (Numeric). This is calculated by a separate function block.
*   `IDX_FUP_SP_SEL_CMB_MOD`: An index for selecting the combustion mode based on fuel pressure setpoint (Numeric). This is also an output of the basic setpoint calculation function.

## Logic Flow

The diagram primarily uses a cascade of `cond_if` blocks, which function as prioritized multiplexers or conditional selectors. The signal flows downwards through these blocks, with each `cond_if` evaluating a condition. If the condition is true, a specific setpoint is selected; otherwise, the logic proceeds to the next `cond_if` block's `else` path, effectively forming a "first-condition-met wins" prioritization.

Here's a step-by-step breakdown of the `FUP_SP_TMP` calculation path:

1.  **Manual Setpoint Override:**
    *   The topmost `cond_if` block checks the `LC_FUP_SP_MAN_ACT` condition.
    *   If `true`, the constant `C_FUP_SP_MAN` is selected as the current setpoint.
    *   If `false`, the logic proceeds to the next stage.

2.  **External Request Override:**
    *   The next `cond_if` block checks `LV_FUP_SP_EXT_REQ`.
    *   If `true`, the constant `C_FUP_SP_EXT` is selected.
    *   If `false`, the output from the previous stage is passed through.

3.  **Start-Stop Stop Request Override:**
    *   The next `cond_if` block checks `LV_STST_STOP_REQ`.
    *   If `true`, the constant `C_FUP_SP_STST` is selected.
    *   If `false`, the output from the previous stage is passed through.

4.  **Low Pressure Request Override:**
    *   The next `cond_if` block checks `LV_FUP_SP_L_PRS_ST_REQ`.
    *   If `true`, the constant `C_FUP_SP_L_PRS_ST` is selected.
    *   If `false`, the output from the previous stage is passed through.

5.  **PUC / MPI Injection Setpoint Calculation:**
    *   An `OR` gate combines `LV_PUC` and `LV_FUP_SP_MPI_INJ_REQ`.
    *   The result feeds the condition of the next `cond_if` block.
    *   If `true` (either PUC or MPI injection requested):
        *   The maximum of `LC_FUP_ACT_FUP_SP_PUC` and `FUP_SP_PUC` is determined.
        *   This maximum value is then divided by `N_32` (engine speed), with a check to prevent division by zero. This calculated value is selected.
    *   If `false`, the output from the previous stage is passed through.

6.  **Fuel Pump Pressure Build-up / Mass Flow Lookup:**
    *   The condition for the next `cond_if` block is an `AND` operation between `LC_FUP_SP_PU_ACT` and `LV_PU`.
    *   If `true`:
        *   A 2D lookup table (likely `LC_FUP_SP_SEL_MFL` refers to the table's selection or name) is used.
        *   `N_32` (engine speed) serves as the x-axis input, and `MFF_SP_FUP_SP` (mass flow fuel pressure setpoint) as the y-axis input.
        *   The output of this lookup table, `IP_FUP_SP_PU`, is selected.
    *   If `false`, the output from the previous stage is passed through.

7.  **Engine Stop / No Injection / Coolant Temperature Lookup:**
    *   The condition for the next `cond_if` block is derived from `NOT(LV_ST_END)` OR `LF_STATE_IV_PREV`, which is then `AND`ed with `LC_FUP_SP_ST_NO_INJ`.
    *   If `true`:
        *   A 1D lookup table is used, with `TCO_ST` (coolant temperature status) as its input.
        *   The output of this lookup table, `IP_FUP_SP_ST_NO_INJ`, is selected.
    *   If `false`, the output from the previous stage is passed through.

8.  **Final Setpoint Merging (`FUP_SP_TMP`):**
    *   The output of this entire cascaded `cond_if` structure (which represents the highest priority active setpoint) is fed into a `Merge` block.
    *   Separately, `LV_FUP_SP_REQ_CRCV` (possibly a boolean or a value) is processed (via a generic block denoted `-`, potentially a direct pass-through or a specific value for this condition) and also fed into the `Merge` block.
    *   The `Merge` block combines these paths to produce the final `FUP_SP_TMP` signal. In Simulink, a Merge block typically coalesces signals from mutually exclusive conditional execution paths into a single output.

9.  **Basic Setpoint Calculation (`fup_sp_bas` and `IDX_FUP_SP_SEL_CMB_MOD`):**
    *   A dedicated function block, `FUP_SP_BAS_CLC`, takes `input<fup_sp_bas_clc>` as an input.
    *   This function performs a separate calculation, independent of the cascaded overrides, to determine the `fup_sp_bas` (basic fuel pressure setpoint) and `IDX_FUP_SP_SEL_CMB_MOD` (index for combustion mode selection). This suggests a foundational setpoint calculation, which might then be modulated or overridden by the `FUP_SP_TMP` logic.


--- Page 147 ---

## Function
This Simulink diagram's primary function is to calculate and select the basic fuel pressure setpoint (`fup_sp_bas_clc`) for an automotive engine control unit. This selection is dynamically determined based on the current combustion mode, engine operating conditions (such as coolant temperature and engine speed), and air/fuel mass flow requirements. It uses a combination of lookup tables and selection logic to adapt the setpoint to various operational states.

## Inputs
1.  **`<NC_NR_IP_FUP_SP_BAS>`**: Nominal or reference fuel pressure setpoint (e.g., a base value in Bar). This serves as a primary input to the final lookup operation and also to a limiting block.
2.  **`<IDX_CMB_MOD_CUR>`**: Index representing the current combustion mode (e.g., an integer indicating different combustion strategies like homogeneous, stratified, etc.). This is a key input for mode-dependent calculations.
3.  **`<TCO>`**: Coolant temperature (e.g., in °C). Used as an axis for a lookup table.
4.  **`<N_32>`**: Engine speed (e.g., in RPM). Used as an axis for a lookup table (though it's visually connected to V.7.10 along with TCO which is typically 2D).
5.  **`<MFF_SP_FUP_SP>`**: Mass Fuel Flow Setpoint (e.g., desired fuel mass flow in mg/stroke). Used as an axis for a lookup table.
6.  **`<MAF>`**: Mass Air Flow (e.g., measured air mass flow in kg/h or g/s). Used as an axis for a lookup table.
7.  **`LC_FUP_SP_SEL_MFL`**: Logic/Control signal for fuel pressure setpoint selection based on Mass Fuel Flow (Boolean flag; e.g., `0` for combustion mode-based, `1` for mass flow-based). This controls a switch.
8.  **Constant `1` (V.6.11)**: A numerical constant used as an upper limit in a saturation/limiting block.

## Outputs
1.  **`fup_sp_bas_clc`**: The calculated basic fuel pressure setpoint (e.g., in Bar), which is the primary output of this subsystem.
2.  **`idx_x` (from V.7.12)**: Intermediate index or interpolation value from the final lookup table (likely for diagnostics/tuning of the x-axis).
3.  **`idx_y` (from V.7.12)**: Intermediate index or interpolation value from the final lookup table (likely for diagnostics/tuning of the y-axis).

## Logic Flow

The diagram calculates the basic fuel pressure setpoint `fup_sp_bas_clc` through a multi-stage lookup table and selection process:

1.  **Combustion Mode & Operating Conditions-based Intermediate Lookup:**
    *   The `IDX_CMB_MOD_CUR` (Combustion Mode Index) and `TCO` (Coolant Temperature) are used as inputs to a 2D lookup table (`IP_FUP_SP_BAS_SEL`, V.7.10). This table also receives `N_32` but it's unclear how it integrates into the 2D lookup, possibly implying the table is multidimensional or `N_32` is an axis for other tables. For a 2D table, `IDX_CMB_MOD_CUR` and `TCO` would typically be the X and Y axes.
    *   This table outputs an intermediate value, here labeled `ID_val` (let's call it `ID_val_CMB_TCO`). This value likely represents an adjustment factor or an index related to the specific combustion mode and engine temperature.

2.  **Mass Flow-based Intermediate Lookup:**
    *   In parallel, `MFF_SP_FUP_SP` (Mass Fuel Flow Setpoint) and `MAF` (Mass Air Flow) are used as inputs to another 2D lookup table (`IP_FUP_SP_BAS_SEL`, V.7.11).
    *   This table also outputs an intermediate `ID_val` (let's call it `ID_val_MFF_MAF`), likely an adjustment factor or an index derived from the desired and measured air/fuel mass flows.

3.  **Selection of Intermediate `ID_val`:**
    *   A switch block (`V.6.10`, labeled "Check ~= 0") selects between `ID_val_CMB_TCO` (from V.7.10) and `ID_val_MFF_MAF` (from V.7.11).
    *   The selection is controlled by the `LC_FUP_SP_SEL_MFL` signal. If `LC_FUP_SP_SEL_MFL` is true (non-zero), `ID_val_MFF_MAF` is chosen; otherwise (`LC_FUP_SP_SEL_MFL` is zero), `ID_val_CMB_TCO` is chosen.
    *   The chosen value becomes the `Selected_ID_val` which serves as the Y-axis input for the next stage.

4.  **Final Fuel Pressure Setpoint Calculation (Primary Path):**
    *   The `NC_NR_IP_FUP_SP_BAS` (Nominal Fuel Pressure Setpoint) serves as the X-axis input, and the `Selected_ID_val` (from step 3) serves as the Y-axis input to a third 2D lookup table (`IP_FUP_SP_BAS_SEL`, V.7.12, the rightmost lookup table).
    *   This lookup table performs the final mapping to calculate a primary candidate basic fuel pressure setpoint. It also outputs `idx_x` and `idx_y`, which likely indicate the interpolated indices used in the table for diagnostics or tuning. Let's call the output `FUP_SP_BAS_Candidate1`.

5.  **Alternative/Override Path (Ambiguous, but contributes to final output):**
    *   The `NC_NR_IP_FUP_SP_BAS` signal also feeds into the `MN` (minimum) input of a saturation/limiter block (`V.6.20`). A constant `1` (from `V.6.11`) feeds its `MX` (maximum) input. The explicit *input signal* to be saturated by `V.6.20` is not clearly depicted, which introduces some ambiguity. Assuming it operates on an implicit fuel pressure related signal, its output `y` is a limited value.
    *   This `y` from `V.6.20`, along with `ID_val_CMB_TCO` (from V.7.10), are inputs to a block labeled `IDX_FUP_SP_SEL_CMB_MOD_Fup_sp_bas_clc` (`V.6.8`). This block, given its comprehensive name, likely implements an alternative calculation, an override, or a final selection/modification logic for the fuel pressure setpoint, potentially based on specific combustion modes and the limited value from `V.6.20`. Let's call its output `FUP_SP_BAS_Candidate2`.

6.  **Final Output Selection/Merge:**
    *   Both `FUP_SP_BAS_Candidate1` (from V.7.12) and `FUP_SP_BAS_Candidate2` (from V.6.8) appear to feed into the final output signal `fup_sp_bas_clc`. Although not explicitly drawn as an additional block (e.g., a final multiplexer or sum), this implies a final decision or merge point. Given that `V.6.8`'s label includes "SEL_CMB_MOD", it is most probable that `V.6.8` is the ultimate selector or combiner, taking `FUP_SP_BAS_Candidate1` (implicitly) and `FUP_SP_BAS_Candidate2` (explicitly from its own logic) as inputs, and determining the final `fup_sp_bas_clc` based on overall system requirements or the active combustion mode.

The overall logic ensures that the basic fuel pressure setpoint is dynamically determined by adapting a nominal value using different lookup tables based on the active combustion mode and other key engine operating parameters, with a robust mechanism for selection or override.


--- Page 148 ---

This page contains a Simulink diagram titled "FUSL, Fuel pressure setpoint calculation".

## Function
The primary function of this Simulink diagram is to calculate and manage the target fuel pressure setpoint (`FUP_SP`) for an automotive system. It incorporates various system states, operational limits, safety conditions, and gradient limiting to ensure a smooth, stable, and safe fuel pressure control.

## Inputs
*   **`clc_fup_sp_aux`**: An auxiliary control input for fuel pressure setpoint.
*   **`STATE_VVL_MNG`**: Variable Valve Lift (VVL) management state.
*   **`LV_STST_STOP_REQ`**: Start-stop system stop request.
*   **`LV_PU`**: Power unit status/request (e.g., ignition on).
*   **`LV_PUC`**: Power unit control status.
*   **`N_32`**: Engine speed (likely in rpm/100 or similar scaled value).
*   **`LV_VCV_CLOSE_SL_AD_WAIT`**: Variable Camshaft Valve (VCV) close wait status.
*   **`MFF_SP_FUP_SP`**: Measured or current fuel pressure setpoint (for rate limiting).
*   **`ctr_fup_sp_vvl_lgrd`**: Feedback/lagged value of the VVL-related fuel pressure setpoint.
*   **`LV_FUP_SP_GRD_ACT`**: Flag indicating if fuel pressure setpoint gradient control is active.
*   **`LF_TI_MIN`**: Input related to a minimum time function.
*   **`FUP_SP_LIM`**: Current or initial fuel pressure limit (feedback loop for rate limiting).
*   **`TFU`**: Fuel temperature or other fuel-related characteristic, likely for a lookup table.
*   **`FUP_SP_TMP`**: A temporary or pre-calculated fuel pressure setpoint, possibly a raw demand.
*   **`LV_ES`**: Engine running status (e.g., engine running).
*   **`LV_IGK`**: Ignition key status (e.g., ignition on).
*   **`LV_FUP_LIH_L_PRS_CTL_REQ`**: Request for low pressure limitation/control.
*   **`LV_FUP_LIH_H_PRS_CTL_REQ`**: Request for high pressure limitation/control.
*   **Constants**: `LC_FUP_SP_LIM_TI_MIN`, `C_FUP_SP_MIN`, `C_FUP_SP_LIH_L_PRS_CTL`, `C_FUP_SP_LIH_H_PRS_CTL`, `C_CRLC_FUP_SP_GRD`. These are fixed parameters used in calculations.

## Outputs
*   **`FUP_SP_LIM_INC`**: Calculated increment value for the fuel pressure limit.
*   **`FUP_SP_LIM_DEC`**: Calculated decrement value for the fuel pressure limit.
*   **`FUP_SP_LIM`**: The current dynamic fuel pressure limit, considering increment/decrement rates.
*   **`FUP_SP_MAX`**: The maximum allowed fuel pressure setpoint from a lookup table.
*   **`FUP_SP_GRD_LIM`**: The gradient-limited fuel pressure value, which is an intermediate output used for selection.
*   **`FUP_SP_GRD`**: The final fuel pressure setpoint after gradient limitation. This is a key output.
*   **`FUP_SP`**: The ultimate, final fuel pressure setpoint that the system aims to achieve, after all selections and limitations. This is the primary output.

## Logic Flow

The logical flow can be broken down into several main pathways that converge to calculate the final fuel pressure setpoint.

1.  **Fuel Pressure Limit (FUP_SP_LIM) Calculation**:
    *   **Increment/Decrement Rates**: Inputs such as `clc_fup_sp_aux`, `STATE_VVL_MNG`, `LV_STST_STOP_REQ`, `LV_PU`, `LV_PUC`, `N_32`, `LV_VCV_CLOSE_SL_AD_WAIT`, `MFF_SP_FUP_SP`, `ctr_fup_sp_vvl_lgrd`, and `LV_FUP_SP_GRD_ACT` are processed (likely in the "FUP_SP_LIM_CLC" subsystem, though not fully expanded) to determine `FUP_SP_LIM_INC` and `FUP_SP_LIM_DEC`. These define how fast the fuel pressure limit can increase or decrease.
    *   **Rate Limiting**: `FUP_SP_LIM_INC`, `FUP_SP_LIM_DEC`, and the current `FUP_SP_LIM` (from a feedback loop) are fed into a rate limiter (V.7.4). This block prevents the fuel pressure limit from changing too rapidly.
    *   **Minimum Time Active Logic**: A boolean `lv_ti_min_act` is calculated. This involves `LV_FUP_SP_GRD_ACT` and a value `R0` obtained from a lookup table (V.6.16) based on `LV_TI_MIN`. An OR gate combines these. `lv_ti_min_act` then influences a conditional logic (V.6.4) and switch (V.6.7) that appears to select between `LC_FUP_SP_LIM_TI_MIN` and another value, potentially impacting the lower bound of `FUP_SP_LIM`.
    *   **Min/Max Constraints**: The output of the rate limiter is then subjected to minimum and maximum constraints.
        *   It is compared with `C_FUP_SP_MIN` (a constant minimum).
        *   It is also compared with `FUP_SP_MAX`, which is derived from a lookup table (V.7.11) using `TFU` (e.g., fuel temperature) as an input. The `FUP_SP_MAX` effectively defines the highest allowed fuel pressure based on operating conditions.
        *   A `min` block (V.6.11) then selects the smaller of the current limited value and `FUP_SP_MAX`, ensuring the limit doesn't exceed the maximum.
    *   **Overall `FUP_SP_LIM`**: The result of these operations is the dynamically adjusted `FUP_SP_LIM`.

2.  **Intermediate Setpoint Selection (FUP_SP)**:
    *   An `if/elseif/else` block (V.7.19) determines the primary fuel pressure setpoint before final limiting.
    *   **Low Pressure Control**: If `LV_FUP_LIH_L_PRS_CTL_REQ` (request for low pressure control) is active (condition `u1`), the constant `C_FUP_SP_LIH_L_PRS_CTL` is chosen.
    *   **High Pressure Control**: Else if `LV_FUP_LIH_H_PRS_CTL_REQ` (request for high pressure control) is active (condition `u2`), the constant `C_FUP_SP_LIH_H_PRS_CTL` is chosen.
    *   **Default/Gradient Limited**: Otherwise (`else`), the `FUP_SP_GRD_LIM` value is selected.

3.  **Gradient Limitation (FUP_SP_GRD)**:
    *   The `FUP_SP_GRD` (gradient limited fuel pressure) is calculated based on the output `FUP_SP` (from the final selection, discussed next) and a constant `C_CRLC_FUP_SP_GRD`. This part likely implements a rate limiter or low-pass filter to ensure the fuel pressure setpoint does not change too abruptly, providing a smooth transition. The output `FUP_SP_GRD` is then used to generate `FUP_SP_GRD_LIM` which feeds back into the setpoint selection.

4.  **Final Fuel Pressure Setpoint (FUP_SP) Determination**:
    *   The output of the `if/elseif/else` selection, along with `FUP_SP_LIM` (calculated in step 1), and `FUP_SP_GRD` (calculated in step 3), are fed into a final rate limiter block (V.7.19).
    *   This block ensures that the final setpoint `FUP_SP` respects the calculated `FUP_SP_LIM` (upper/lower bounds) and potentially the rate of change defined by the `FUP_SP_GRD` calculation.
    *   The `FUP_SP_TMP` is an initial value for this block, indicating it's the nominal fuel pressure target.
    *   The block `V.7.19` is a generic rate limiter or saturate with memory, taking an input `u`, an initial value `IV`, a lower limit `LU`, an upper limit `LD`, and a rate `R` (or a gradient value `delta`). Given the inputs, `FUP_SP_TMP` is likely `u` (input), `FUP_SP_LIM` is `LD` (upper limit), and the result of the `if/elseif/else` structure (likely `FUP_SP_GRD_LIM` or the constant value selected) could be the `LU` (lower limit), or the final `FUP_SP` is determined by saturating `FUP_SP_TMP` within the calculated `FUP_SP_LIM` and `FUP_SP_GRD_LIM`. The presence of a `min` block before `FUP_SP_LIM` and an `OR` gate `V.6.7` with `NOT LV_IGK` and `LV_ES` indicates logic to potentially disable or set a default limit when the engine is off or ignition is off.

In summary, the diagram orchestrates a complex logic to determine the fuel pressure setpoint, prioritizing safety limits, operational requests, and smooth transitions, with engine status and VVL management playing crucial roles.


--- Page 149 ---

This page contains a Simulink-like block diagram.

## Function

The primary function of this Simulink diagram is to **calculate the increase and decrease gradient limitations for the fuel pressure setpoint**. This system dynamically determines the maximum allowed rate at which the fuel pressure setpoint can change (both positively and negatively) based on various engine operating conditions and control states. The goal is to prevent sudden or excessive changes in fuel pressure, ensuring smooth engine operation and protecting fuel system components.

## Inputs

*   **`STATE_VVL_MNG`**: Current state of the Variable Valve Lift management system (e.g., active, inactive, specific modes).
*   **`lv_ctr_fup_sp_vvl_lgrd_act`**: A boolean flag indicating if the low voltage control for Variable Valve Lift (VVL) gradient is active.
*   **`ctr_fup_sp_vvl_lgrd`**: A control value for the fuel pressure setpoint VVL gradient, likely a target or reference for the rate limiter.
*   **`LV_STST_STOP_REQ`**: A boolean flag indicating a low voltage Start/Stop system stop request.
*   **`LV_PU`**: A boolean flag indicating the activity status of the Fuel Pump Unit.
*   **`clc_fup_sp_aux`**: An auxiliary fuel pressure setpoint calculation value, likely a condition or state.
*   **`LV_PUG`**: A boolean flag related to the Fuel Pump Unit gradient.
*   **`LV_FUP_SP_MPI_INJ_REQ`**: A boolean flag indicating a Multi-Point Injection (MPI) fuel pressure setpoint request.
*   **`LV_VCV_CLOSE_SL_AD_WAIT`**: A boolean flag indicating if the Volume Control Valve (VCV) is in a "close slide adjust wait" state.
*   **`LV_FUP_SP_GRD_ACT`**: A boolean flag indicating if the fuel pressure setpoint gradient limitation function is generally active.
*   **`MFF_SP_FUP_SP`**: The main (or desired) fuel pressure setpoint. This acts as a scaling factor in the final calculation.
*   **`N_32`**: An unidentified input, possibly a numeric constant or a condition flag.

## Outputs

*   **`FUP_SP_LIM_INC`**: The calculated maximum allowed rate (gradient) at which the fuel pressure setpoint can *increase*.
*   **`FUP_SP_LIM_DEC`**: The calculated maximum allowed rate (gradient) at which the fuel pressure setpoint can *decrease*.

## Logic Flow

The logical flow involves evaluating multiple system conditions in parallel to select appropriate base limits, which are then merged and finally scaled to produce the ultimate gradient limits.

1.  **VVL Condition-Based Limit Selection:**
    *   The `STATE_VVL_MNG` input is processed by `VVL_H` and `VVL_L` blocks (likely extracting high/low state flags).
    *   These VVL states are negated and logically ANDed together, then ANDed with `lv_ctr_fup_sp_vvl_lgrd_act`. This determines a specific VVL operating condition.
    *   If this condition is true, either a constant `C_FUP_SP_VVL_LGRD` or a rate-limited `ctr_fup_sp_vvl_lgrd` (from block `V.7.12`) is selected as a potential pair of increase/decrease limits. This selection is fed into a `V.6.7` (likely a Multiport Switch or Selector) block.

2.  **Pump Unit Activity (`LC_FUP_SP_PU_ACT`) Calculation:**
    *   A sub-logic branch calculates `LC_FUP_SP_PU_ACT` (active fuel pump unit) by combining `LV_PU` AND `clc_fup_sp_aux` with `LV_PUG` AND `LV_FUP_SP_MPI_INJ_REQ` using an `OR` gate. This boolean flag is used in subsequent conditional limit selections.

3.  **Conditional Limit Branching and Selection:**
    *   Multiple `cond_if` blocks (`V.6.4`) are used, each checking a specific system condition:
        *   **Start/Stop Limit:** If `LV_STST_STOP_REQ` AND `LC_FUP_SP_PU_ACT` is true, a constant `C_FUP_SP_STST_LGRD` (for both increase and decrease) is selected.
        *   **Pump Unit Limit:** If `LC_FUP_SP_PU_ACT` is true, specific constants `C_FUP_SP_PU_LIM_INC` and `C_FUP_SP_PU_LIM_DEC` are selected.
        *   **VCV Limit:** If `LV_VCV_CLOSE_SL_AD_WAIT` is true, a constant `C_FUP_SP_VCV_SL_LGRD` (for both increase and decrease) is selected.
        *   **General Gradient Active Limits:** If `LV_FUP_SP_GRD_ACT` is true, the system uses lookup tables `IP_FUP_SP_LIM_INC` and `IP_FUP_SP_LIM_DEC`. These tables take an intermediate value, `fup_sp_lim_clc_bas` (explained below), as their input (`x_val`) to derive the limits.
        *   **Main Setpoint Related Limits:** Based on an implied condition (possibly related to `N_32`), the system uses lookup tables `IP_FUP_SP_ST_LGRD_INC` and `IP_FUP_SP_ST_LGRD_DEC`, also taking `fup_sp_lim_clc_bas` as their input.
    *   Each of these conditional branches outputs a pair of (increase, decrease) limits, which are routed to a `V.6.7` (Switch/Selector) block.

4.  **Base Limit Merging (`fup_sp_lim_clc_bas`):**
    *   The outputs from all the `V.6.7` (Switch/Selector) blocks, representing different conditionally selected limit pairs, feed into a `Merge` block.
    *   The `Merge` block combines these inputs, typically by applying a priority or selecting the most restrictive limit pair if multiple conditions are met, to produce an intermediate pair of base limits: `fup_sp_lim_clc_bas` (likely a vector containing [base_INC_limit, base_DEC_limit]). This `fup_sp_lim_clc_bas` value is then fed back as an input to some of the lookup tables in the conditional limit selection stage, suggesting an iterative or refined calculation.

5.  **Final Scaling and Output:**
    *   The `fup_sp_lim_clc_bas` (the merged base limits) is used as the `x_val` input for the `IP_FAC_FUP_SP_LIM` lookup table. This table outputs a final scaling factor.
    *   This scaling factor is then multiplied (`X` block) by the `MFF_SP_FUP_SP` (main fuel pressure setpoint). This multiplication likely applies the scaling to both the increase and decrease components of the base limit.
    *   The result of the multiplication is then split by the `V.6.8` block into the two final outputs: `FUP_SP_LIM_INC` and `FUP_SP_LIM_DEC`.


--- Page 150 ---

This page contains a Simulink-like diagram, which is a common representation for automotive control logic.

## Function
This Simulink diagram's primary function is to control the activation of a "fuel pressure setpoint gradient limitation" (`<LV_FUP_SP_GRD_ACT>`). This limitation is only activated after the engine start sequence has completed and when the fuel pressure system has stabilized at its target setpoint. Once activated, it remains active until a new engine start event occurs. This mechanism prevents aggressive fuel pressure changes during critical engine phases like starting and ensures smooth operation once initial conditions are met.

## Inputs
*   **`<FUP_SP_TMP>`**: Temporary or target fuel pressure setpoint (e.g., in bar). Its value is used for an equality comparison.
*   **`<FUP_SP>`**: Current or actual fuel pressure setpoint (e.g., in bar). Its value is used for an equality comparison.
*   **`<LV_ST_END>`**: A boolean flag indicating whether the engine start sequence has ended. `TRUE` when the start sequence is complete, `FALSE` otherwise.
*   The `Q_in` input of the FF block is connected to its own output `<LV_FUP_SP_GRD_ACT>`, implying the previous state of the output is used as the current state variable or for initialization.

## Outputs
*   **`<LV_FUP_SP_GRD_ACT>`**: A boolean flag indicating whether the fuel pressure setpoint gradient limitation is active (`TRUE`) or inactive (`FALSE`).

## Logic Flow
The logical flow determines the state of the `<LV_FUP_SP_GRD_ACT>` flag based on the input conditions:

1.  **Fuel Pressure Setpoint Comparison (V.6.6):**
    *   The equality comparator (`=`) checks if the temporary fuel pressure setpoint (`<FUP_SP_TMP>`) is equal to the current fuel pressure setpoint (`<FUP_SP>`).
    *   Its output is `TRUE` if `FUP_SP_TMP == FUP_SP`, and `FALSE` otherwise. This condition signifies that the fuel pressure has reached its desired stable value.

2.  **Reset Condition for Gradient Limitation (V.6.8):**
    *   The `NOT` gate inverts the `LV_ST_END` signal.
    *   If `LV_ST_END` is `TRUE` (engine start has finished), the `NOT` gate output is `FALSE`.
    *   If `LV_ST_END` is `FALSE` (engine is still starting), the `NOT` gate output is `TRUE`.
    *   This inverted signal acts as the `R` (Reset) input to the SR Flip-Flop. This ensures that the gradient limitation is forced to be `FALSE` (inactive) whenever the engine is in its starting phase.

3.  **Set Condition for Gradient Limitation (V.6.10):**
    *   The `AND` gate takes two inputs: the output of the equality comparator (Step 1) and the `LV_ST_END` signal.
    *   The `AND` gate's output becomes `TRUE` only if both `(FUP_SP_TMP == FUP_SP)` is `TRUE` *AND* `LV_ST_END` is `TRUE`.
    *   Otherwise, its output is `FALSE`.
    *   This output acts as the `S` (Set) input to the SR Flip-Flop. This condition allows the gradient limitation to be `TRUE` (active) only when the fuel pressure is stable *and* the engine start sequence has completed.

4.  **SR Flip-Flop Operation (V.6.12):**
    *   The `FF` block is a Set-Reset Flip-Flop, which is a stateful element. Its `Q` output is `<LV_FUP_SP_GRD_ACT>`.
    *   **During Engine Start (`LV_ST_END` is `FALSE`):**
        *   The `R` input (from `NOT LV_ST_END`) will be `TRUE`.
        *   The `S` input (from `(FUP_SP_TMP == FUP_SP) AND LV_ST_END`) will be `FALSE` because `LV_ST_END` is `FALSE`.
        *   With `S=FALSE` and `R=TRUE`, the flip-flop is reset, forcing `Q` (`<LV_FUP_SP_GRD_ACT>`) to `FALSE`. The gradient limitation is inactive.
    *   **After Engine Start (`LV_ST_END` is `TRUE`):**
        *   The `R` input will be `FALSE`.
        *   The `S` input will depend on the fuel pressure comparison: `S = (FUP_SP_TMP == FUP_SP)`.
        *   If `(FUP_SP_TMP == FUP_SP)` becomes `TRUE` while `LV_ST_END` is `TRUE` (i.e., `S=TRUE` and `R=FALSE`), the flip-flop is set, and `Q` (`<LV_FUP_SP_GRD_ACT>`) becomes `TRUE`. The gradient limitation is activated.
        *   Once `Q` is set to `TRUE`, it will remain `TRUE` as long as `R` is `FALSE` (i.e., `LV_ST_END` is `TRUE`), even if `S` subsequently becomes `FALSE` (if fuel pressure setpoints diverge). The flip-flop holds its state (`<LV_FUP_SP_GRD_ACT>`).
    *   The `Q_in` port, fed by `<LV_FUP_SP_GRD_ACT>`, indicates that the current state of the variable is used for initialization or as a feedback for the sequential logic, making it persistent.

In essence, the gradient limitation is *only* allowed to become active *after* engine start and *once* fuel pressure setpoints match, and it then *stays active* until the next engine start event initiates a reset.


--- Page 157 ---

This page contains a Simulink diagram.

## Function

The primary function of this Simulink diagram, as indicated by the title "FUSL, Fuel pressure control," is to manage and control the fuel pressure and associated fuel mass flow within an automotive system. It calculates required fuel mass adaptations, control requests (likely for fuel injectors and pumps), and monitors fuel pressure differences, operating in a scheduled, multi-rate environment.

## Inputs

The system takes a variety of inputs, categorized as follows:

*   **Sensor/System State Inputs (Green Blocks on Left):**
    *   `<FUP>`: Actual Fuel Pressure.
    *   `<FUP SP>`: Fuel Pressure Setpoint (desired pressure).
    *   `<LV_ES>`: Engine Status or Load Variable.
    *   `<LV_FUEL_MASS_AD_ENA>`: Enable signal for fuel mass adaptation.
    *   `<LV_FUP_LIH_H_PRS_CTL_REQ>`: High-pressure fuel control request.
    *   `<LV_FUP_LIH_L_PRS_CTL_REQ>`: Low-pressure fuel control request.
    *   `<LV_ST_END>`: System state end flag, used for scheduling.
    *   `<MFF_SP_FUP_CTL>`: Setpoint for multi-function fuel pump control.
    *   `<MFP>`: Main Fuel Pump related signal.
    *   `<N_32>`: Engine speed or another 32-bit numerical input.
    *   `<PUMP_VOL_VCV>`: Volumetric Control Valve position or command for the pump.
    *   `<PV_AV_GRD>`: Ground reference for a sensor (e.g., Pressure/Voltage).
    *   `<PV_AV_H>`: High reference for a sensor (e.g., Pressure/Voltage).
    *   `<STATE_VCV>`: State of the Volumetric Control Valve.
    *   `<TFU_HPP>`: High-Pressure Pump Temperature or related thermal input.
*   **Scheduling/Trigger Inputs (from APP_CDN):**
    *   `fc_INI`: Initialization trigger.
    *   `fc_OPM_SEG`: Trigger for segment-specific operations.
    *   `fc_OPM_10MS`: Trigger for 10-millisecond periodic operations.
    *   `fc_OPM_100MS`: Trigger for 100-millisecond periodic operations.
*   **Feedback Inputs:**
    *   `[feedback]`: Signals fed back from previous calculations or other modules for closed-loop control or state updates.

## Outputs

The system produces several key outputs (Blue Blocks on Right):

*   `<FUEL_MASS_AD>`: Calculated adapted fuel mass, potentially compensated for various factors.
*   `<FUEL_MASS_AD_DIF>`: Difference or error in the fuel mass adaptation.
*   `<FUEL_MASS_REQ_CTL>`: The total requested fuel mass for control purposes (e.g., for injector pulse width calculation).
*   `<FUEL_MASS_REQ_I_CTL>`: Integral component of the requested fuel mass control.
*   `<FUEL_MASS_REQ_P_CTL>`: Proportional component of the requested fuel mass control.
*   `<FUP_DIF>`: Difference between the actual and desired fuel pressure.
*   `[feedback]`: Output signals intended for internal use in subsequent cycles or feedback to other systems.

## Logic Flow

The logical flow of the diagram is structured around a central scheduler and several functional sub-modules, processing inputs to generate control outputs:

1.  **Input Gathering:** All external sensor data and control signals (like `<FUP>`, `<FUP SP>`, `<LV_ES>`, etc.) are gathered and presented to the system. These inputs are likely bundled into a bus.

2.  **Scheduling and Execution Control (APP_CDN):** The `APP_CDN` block acts as a central orchestrator. It defines the recurrence rates (SEG, 10MS, 100MS) and activation/deactivation conditions for internal functional blocks:
    *   **Initialization (INI X.1):** When the `fc_INI` trigger is asserted, the `INI` block (X.1) executes. This block performs initial setup, variable resets (`RST`, `ERU2ES`, `NVMRES`, `NVMSTO`), and likely loads non-volatile memory (NVM) parameters. The inputs `fc_INI` and `[feedback]` are processed here.
    *   **Segment-Specific Logic (OPM_SEG X.2):** The `OPM_SEG` block (X.2) executes when the `fc_OPM_SEG` trigger is asserted, specifically when `LV_ST_END == 1`. This block handles calculations pertinent to a particular segment or state of operation. It receives relevant inputs from the main input bus and `[feedback]`.
    *   **10ms Periodic Logic (OPM_10MS):** The `OPM_10MS` block executes when `fc_OPM_10MS` is asserted, with the condition `LV_ST_END == 0`. This signifies a fast control loop, operating at a 10-millisecond interval, likely for real-time adjustments. It processes inputs from the main input bus and `[feedback]`.
    *   **100ms Periodic Logic (OPM_100MS X.3):** The `OPM_100MS` block (X.3) executes when `fc_OPM_100MS` is asserted, generally running "always" or if a specific activation condition is not met for other tasks. This handles slower-rate calculations, such as adaptations or less critical monitoring, at a 100-millisecond interval. It also receives inputs from the main input bus and `[feedback]`.

3.  **Core Fuel Control Calculations (Unnamed Central Block V.6.9):** The outputs of the `INI`, `OPM_SEG`, and `OPM_100MS` blocks, along with the main input bus, feed into the large central computation block (version V.6.9). This block performs the core fuel pressure and mass control logic:
    *   It uses signals like `FUEL_MASS_AD_Q_YS`, `FUEL_MASS_AD_SEG`, `FUEL_MASS_REQ_CTL_O_V`, `LV_FUEL_ADD_ACT`, `LV_FUEL_MASS_AD_STOP`, `LV_FUEL_MASS_CTL_STOP`, and `T_CTR_FUEL_MASS_AD` (internal signals derived from inputs and sub-modules) to perform its calculations.
    *   This logic likely implements algorithms for fuel mass adaptation, fuel pressure error calculation, and proportional-integral (PI) control strategies to determine the required fuel mass and pressure adjustments.

4.  **Output Generation:** Based on these calculations, the central block generates the final output signals, such as adapted fuel mass, fuel mass control requests (P and I components), and the fuel pressure difference.

5.  **Feedback Loop:** Some of the calculated outputs are looped back into the system via `[feedback]` lines. This enables continuous adjustment and allows the system to maintain internal states or provide inputs for the next processing cycle, characteristic of a closed-loop control system.


--- Page 158 ---

This page contains a Simulink-like diagram, likely representing a functional model for an automotive control system's initialization sequence.

## Function
The primary function of this diagram is to initialize various parameters related to fuel mass and requests for a "Fuel pressure control" system, specifically during system startup or a reset event. It manages the initial states by either applying reset values, loading values from Non-Volatile Memory (NVM), or passing through feedback values, and then merges these into a consolidated initialization bus.

## Inputs
*   **`<fc_INI>`**: A function call trigger for general system initialization.
*   **`<fc_RST>`**: A function call trigger specifically for a reset operation. This also seems to be triggered by `<fc_INI>`.
*   **`<fc_NVMINI>`**: A function call trigger for Non-Volatile Memory (NVM) initialization.
*   **`<fc_NVMRESTORE>`**: A function call trigger for restoring values from NVM.
*   **`<feedback>`**: An input signal or trigger providing a `FUEL_MASS_AD` value, likely representing a current or previous adaptive fuel mass.
*   **`<FUEL_MASS_AD>` (from feedback)**: A specific fuel mass adaptive value passed through the feedback path.

## Outputs
*   **`ini`**: A bus containing all the initialized parameters:
    *   `<FUEL_MASS_REQ_I_CTL>`: Initialized fuel mass request integral control value.
    *   `<FUEL_MASS_REQ_I_CTL_MMV>`: Initialized fuel mass request integral control minimum/maximum value.
    *   `<FUEL_MASS_AD>`: Initialized adaptive fuel mass value.

## Logic Flow

The logical flow describes how the initialization parameters are determined and combined:

1.  **General Initialization and Reset Trigger**: The process begins with the `<fc_INI>` trigger. This trigger activates the `RST` block (X.1.1). The `<fc_RST>` trigger appears to be an alternative or parallel trigger for the `RST` block.
2.  **Reset Operations**:
    *   The `RST` block (X.1.1) performs general reset operations and outputs a `rst` signal.
    *   This `rst` signal is then used to trigger two other blocks: `ERU2ES` (X.1.4) and `INI_RES_NVM` (X.1.2).
3.  **Engine Run-Up/Control Initialization (ERU2ES)**:
    *   The `ERU2ES` block (X.1.4), triggered by `rst`, calculates or sets initial values for `<FUEL_MASS_REQ_I_CTL>` and `<FUEL_MASS_REQ_I_CTL_MMV>`. These two values are then fed into the `BusMerge` block.
4.  **Non-Volatile Memory (NVM) Initialization/Reset (INI_RES_NVM)**:
    *   The `INI_RES_NVM` block (X.1.2), also triggered by `rst`, calculates or retrieves an initial `<FUEL_MASS_AD>` value. This value is directed to two places:
        *   It is fed into the `BusMerge` block as part of the `ini` output.
        *   It is also passed to the `STO_NVM` block (X.1.3).
5.  **NVM Storage Operations (STO_NVM)**:
    *   The `STO_NVM` block (X.1.3) is responsible for handling the storage of `FUEL_MASS_AD` values to NVM. It receives input `<FUEL_MASS_AD>` from two sources:
        *   The output of the `INI_RES_NVM` block.
        *   The `<FUEL_MASS_AD>` value provided via the `<feedback>` input.
    *   The `<fc_NVMINI>` and `<fc_NVMRESTORE>` triggers are likely associated with the control or execution of NVM operations within or around this block, although their direct connection to `STO_NVM` isn't fully explicit in the diagram, they imply NVM-related actions.
    *   The output of the `STO_NVM` block, which is also `<FUEL_MASS_AD>`, is then routed to the `BusMerge` block. This suggests that the *stored* or *current valid* `FUEL_MASS_AD` value from the NVM context is what gets merged.
6.  **Bus Merging**: All the individual initialized parameters (`<FUEL_MASS_REQ_I_CTL>`, `<FUEL_MASS_REQ_I_CTL_MMV>`, and the two instances of `<FUEL_MASS_AD>` from `INI_RES_NVM` and `STO_NVM`) are collected and combined by the `BusMerge` block (V.6.6).
7.  **Final Output**: The `BusMerge` block outputs a single bus named `ini`, which represents the complete set of initialized parameters for the "Fuel pressure control" system.


--- Page 159 ---

This is a Simulink-like diagram, likely representing a part of an automotive control system.

## Function
The primary function of this diagram is to perform the initialization of a set of critical fuel pressure control variables when a system reset event occurs. The explicit goal, as stated by "43.14.1.1 Initialization at reset" and "All outputs Reset to '0'", is to set the initial value of these specific fuel-related parameters to '0' to ensure a defined and safe starting state for the "FUSL, Fuel pressure control" system. The `f()` block suggests this is part of a larger function or a dedicated initialization routine.

## Inputs
The diagram explicitly shows the following 10 signals being routed into the `rst` processing block, which are the variables targeted for initialization:

1.  `<FUEL_MASS_REQ_I_CTL_MMV>`
2.  `<FUEL_MASS_REQ_P_CTL>`
3.  `<FUEL_MASS_REQ_CTL>`
4.  `<FUEL_MASS_AD_DIF>`
5.  `<FUP_DIF>` (likely Fuel Pressure Difference)
6.  `<T_CTR_FUEL_MASS_AD>` (likely a counter or timer related to fuel mass)
7.  `<LV_FUEL_MASS_AD_STOP>` (likely a Boolean/logic variable for fuel mass add stop)
8.  `<LV_FUEL_ADD_ACT>` (likely a Boolean/logic variable for fuel add activation)
9.  `<FUEL_MASS_REQ_I_CTL_H>`
10. `<FUEL_MASS_AD_SEG>`

An implicit input is the system-wide reset signal or event that triggers the execution of this initialization function.

## Outputs
The diagram shows one explicit output signal from the `rst` block:

1.  `rst` (This output likely serves as an acknowledgment that the reset operation has completed, or provides a status indication of the initialization process.)

Functionally, the "outputs" of this initialization process are the modified values (set to '0') of the input variables themselves, which are now in their defined reset state.

## Logic Flow
1.  **Reset Event Detection**: The process is implicitly triggered by a system reset event (indicated by the title "Initialization at reset"). The `f()` block likely represents the entry point or context for this reset function.
2.  **Variable Identification**: A specific set of 10 fuel pressure control variables (identified by their names like `FUEL_MASS_REQ_I_CTL_MMV`, etc.) are designated for initialization. These are passed into a collective entity (possibly a bus or a grouped signal connection).
3.  **Reset Function Call**: The collected variables are then directed as inputs to a specialized reset function or subsystem, represented by the blue rounded block labeled `rst`. This block is responsible for performing the actual value assignments.
4.  **Value Assignment**: Inside the `rst` block, the logic dictates that each of the 10 input variables' values is set to '0'. This directly implements the requirement "All outputs Reset to '0'".
5.  **Status/Completion Indication**: After successfully setting the variables to '0', the `rst` block generates an output signal, also named `rst`, to signify the completion of the reset operation.


--- Page 160 ---

This page contains a block diagram that represents an initialization routine, likely from a Simulink model or a similar model-based development tool (e.g., TargetLink, ASCET).

## Function

The primary function of this diagram is to initialize several key variables and control signals related to fuel mass and pressure control to a constant value of zero. This initialization typically occurs under specific conditions, such as when the Engine Control Unit (ECU) is new, its EEPROM has an error, or the system parameters have been reset by a service tool. It ensures a known, safe starting state for these critical fuel system parameters.

## Inputs

The diagram effectively has one conceptual input:
*   **Constant Value '0'**: Multiple instances of a constant value of zero are used as the source for the initialization. The 'V.6.11' associated with each '0' likely refers to a specific version or parameter identifier within the system configuration, rather than a dynamic input signal.

## Outputs

The diagram outputs, which are the variables being initialized, are:
*   `<FUEL_MASS_REQ_I_CTL_MMV>`: Fuel mass request for inner control (MMV probably stands for Minimum Metered Value or similar context).
*   `<FUEL_MASS_REQ_P_CTL>`: Fuel mass request for pressure control.
*   `<FUEL_MASS_REQ_CTL>`: General fuel mass request control.
*   `<FUEL_MASS_REQ_I_CTL_H>`: Fuel mass request for inner control (High or Hydraulic).
*   `<FUEL_MASS_AD_DIF>`: Fuel mass adaptation difference.
*   `<FUEL_MASS_AD_SEG>`: Fuel mass adaptation segment.
*   `<FUP_DIF>`: Fuel pressure difference (likely Fuel UPstream).
*   `<T_CTR_FUEL_MASS_AD>`: Counter for fuel mass adaptation (time or cycles).
*   `<LV_FUEL_MASS_AD_STOP>`: Flag or signal to stop fuel mass adaptation.
*   `<LV_FUEL_ADD_ACT>`: Flag or signal for fuel additive activity.

These outputs represent important state variables or control flags within the fuel pressure control system.

## Logic Flow

The logical flow is straightforward:
1.  **Constant Source**: Multiple constant blocks, each outputting the value '0', serve as the initial data source. These blocks effectively provide hardcoded default values.
2.  **Direct Assignment**: Each '0' value is directed via a signal line to a specific named output variable or data store (represented by the blue rounded rectangles). This indicates a direct assignment operation.
3.  **Initialization Event**: The textual description below the diagram ("If EEPROM error or ECU brand new or cleared by service tool then the outputs are initialised with constants.") clarifies that this direct assignment logic is executed conditionally. It implies that a higher-level control logic (not shown in this specific diagram) triggers this initialization routine when one of the specified conditions for system reset or initial startup is met.
4.  **System State Reset**: Upon execution, all the listed fuel-related control and adaptation variables are set to '0', establishing a baseline or safe operating state for the fuel pressure control system.


--- Page 161 ---

This page contains a set of diagrams that are characteristic of Simulink or similar model-based design environments used in automotive embedded software development. They represent logical blocks and data flows for Non-Volatile Memory (NVM) operations and signal initialization.

## Function

The primary function of these diagrams, within the context of "FUSL, Fuel pressure control," is to manage the persistent storage and retrieval of a fuel mass adaptation value (`FUEL_MASS_AD`) using Non-Volatile Memory (NVM), and to initialize specific fuel mass request control signals (`FUEL_MASS_REQ_I_CTL` and `FUEL_MASS_REQ_I_CTL_MMV`) during critical operational phases, such as engine shutdown. This ensures data persistence across power cycles and safe initialization of control parameters.

## Inputs

*   **For NVMY[store] (Figure 43.14.6):** The current, possibly updated, runtime value of `<FUEL_MASS_AD>`.
*   **Implicit Triggers:** System events that trigger these operations, such as system startup/initialization for NVM read, system shutdown for NVM store, and a specific "Engine run to engine stop" event for the request signal initialization.

## Outputs

*   **From NVMY[read/init] (Figure 43.14.5):** The retrieved or default-initialized value of `<FUEL_MASS_AD>`, which is then used by the fuel pressure control logic.
*   **From NVMY[store] (Figure 43.14.6):** The stored value of `<FUEL_MASS_AD>` (potentially an echo of the input, indicating a successful write operation).
*   **From Initialization (Figure 43.14.7):**
    *   `<FUEL_MASS_REQ_I_CTL>` (initialized to 0)
    *   `<FUEL_MASS_REQ_I_CTL_MMV>` (initialized to 0)

## Logic Flow

The logical flow can be broken down into three distinct operations based on the figures provided:

**1. Data Initialization/Read from NVM (Figure 43.14.5):**
    *   This block, labeled `NVMY[read/init]`, is likely executed during system startup or when the `FUEL_MASS_AD` value is first required.
    *   It attempts to read a previously stored value for `FUEL_MASS_AD` from the Non-Volatile Memory (e.g., EEPROM or Flash).
    *   If a valid value is successfully read from NVM, that value is output.
    *   If no valid value is found (e.g., first power-up, NVM corruption), the block uses its configured initial value of `-694.51059` as the output.
    *   This output value is then assigned to the internal system variable or data store `<FUEL_MASS_AD>`, making it available for the fuel pressure control algorithms.

**2. Output Save to NVM (Figure 43.14.6):**
    *   This block, labeled `NVMY[store]`, is triggered when the system needs to save the current `FUEL_MASS_AD` value persistently, typically during engine shutdown or periodically during operation.
    *   It receives the current runtime value of `<FUEL_MASS_AD>` as its input.
    *   The `NVMY[store]` block then writes this input value to the designated location in Non-Volatile Memory.
    *   The `out` port likely confirms the value that was stored or signals the completion of the store operation. The output connection to `<FUEL_MASS_AD>` suggests an update to an internal representation of the persistently stored value.

**3. Request Signal Initialization (Figure 43.14.7):**
    *   This logic is specifically activated "during Engine run to engine stop," implying it's part of the shutdown sequence or a safety measure.
    *   Two constant blocks, both outputting a value of `0`, are used.
    *   The first `0` is assigned to the fuel mass request control signal `<FUEL_MASS_REQ_I_CTL>`.
    *   The second `0` is assigned to another fuel mass request control signal, `<FUEL_MASS_REQ_I_CTL_MMV>`.
    *   This action ensures that these critical control request signals are reset to a defined, likely safe, zero state as the engine transitions from running to stopped, preventing unintended fuel requests or carrying over stale values.


--- Page 162 ---

This page contains Simulink-like block diagrams that represent control logic for an automotive system.

## Function
The primary function of the depicted Simulink diagram (specifically, Figure 43.14.9, as described by the accompanying text) is to calculate the **fuel pressure control authorization and adaptation function** for a high-pressure control pump. It generates specific control signals related to fuel mass authorization, calculated fuel mass control, and a final fuel mass request, which collectively determine an operating point or segment for the fuel pressure system.

## Inputs
The diagram utilizes generic input and feedback signals, which would typically be physical measurements or control demands in an automotive context:
*   **<input>**: Multiple instances, representing various raw sensor data (e.g., engine speed, engine load, desired fuel pressure, actual fuel pressure) or control setpoints from other modules.
*   **<feedback>**: Multiple instances, representing closed-loop feedback signals from the fuel system (e.g., actual fuel mass flow, actual fuel pressure, pump status).

## Outputs
The main explicit output of this subsystem is:
*   **opm_seg**: This is the final aggregated output, likely representing the "output pressure module segment" or "operating point segment" for the high-pressure fuel pump, which would be used to drive the pump or determine its operational mode.

Intermediate outputs, essential for the logical flow, include:
*   **fuel_mass_ctl_auth**: Fuel mass control authorization signal (output from CLC_FUP_CTL_AD).
*   **clc_fuel_mass_ctl**: Calculated fuel mass control signal (output from CLC_FUP_CTL).
*   **<FUEL_MASS_REQ_CTL>**: Controlled fuel mass request signal (output from CLC_FUEL_MASS_REQ).

## Logic Flow
The logical flow within the diagram (Figure 43.14.9) progresses through a series of interconnected functional blocks:

1.  **Fuel Pressure Control Authorization and Adaptation (CLC_FUP_CTL_AD, X.2.1.1):**
    *   This block is the initial stage, receiving a generic `<input>` signal.
    *   Its purpose is to process this input, likely evaluating conditions or limits, to determine the necessary **`fuel_mass_ctl_auth`**. This signal indicates the authorization level for fuel mass control, potentially including adaptation aspects to optimize performance or ensure safe operation.

2.  **Fuel Pressure Control (CLC_FUP_CTL, X.2.1.2):**
    *   This block receives the `fuel_mass_ctl_auth` signal from the previous stage, ensuring that subsequent control actions are within authorized limits.
    *   It also takes an additional generic `<input>` (likely actual system state or target) and a `<feedback>` signal.
    *   Based on these inputs, it calculates **`clc_fuel_mass_ctl`**. This block typically embodies the core control algorithm (e.g., a PID controller) to regulate fuel mass based on authorized levels and feedback from the system, aiming to achieve the desired fuel pressure.

3.  **Fuel Mass Request (CLC_FUEL_MASS_REQ, X.2.1.3):**
    *   This block receives the `clc_fuel_mass_ctl` signal as its primary input.
    *   It incorporates another generic `<input>` and a `<feedback>` signal.
    *   It then processes these to generate **`<FUEL_MASS_REQ_CTL>`**. This final stage likely refines the calculated fuel mass control into a precise request signal for the high-pressure pump, potentially incorporating actuator-specific dynamics, limits, or further fine-tuning based on additional system states.

4.  **Output Aggregation and Final `opm_seg` Generation:**
    *   The key output signals from the three main functional blocks (`fuel_mass_ctl_auth`, `clc_fuel_mass_ctl`, and `<FUEL_MASS_REQ_CTL>`) are routed towards a common vertical bus.
    *   Each signal passes through a block labeled `V.6.8` (represented by an arrow-like symbol connected to the bus). These `V.6.8` blocks likely act as interface elements, multiplexers, or signal conditioning units, preparing the individual control values for integration.
    *   Finally, the combined information on the vertical bus leads to the generation of the `opm_seg` signal, which is the ultimate output of this subsystem, representing the commanded operating point or segment for the fuel pressure module of the high-pressure pump.


--- Page 163 ---

This page contains a Simulink diagram, specifically a subsystem block representing "Fuel pressure control authorization."

## Function

The primary function of this Simulink subsystem, `FUEL_MASS_CTL_AUTH`, is to determine and authorize the control variables for the high-pressure fuel control system and its adaptation. It provides various control flags related to stopping, resetting, and enabling/disabling integral action and adaptation within the fuel pressure control logic, particularly focusing on the "I part" (integral part of a controller) and anti-windup mechanisms based on engine operating conditions and specific control requests.

## Inputs

The subsystem receives the following key inputs:

*   **`<LV_FUEL_MASS_AD_ENA>`**: A signal likely indicating whether fuel mass adaptation is enabled.
*   **`<FUP_SP>`**: Fuel Pressure Setpoint (the desired fuel pressure).
*   **`<FUP>`**: Actual Fuel Pressure (the measured fuel pressure).
*   **`<PUMP_VOL_VCV>`**: A signal related to the volume control valve of the fuel pump.
*   **`<STATE_VCV>`**: The state of the volume control valve.
*   **`<MFF_SP_FUP_CTL>`**: Mass Fuel Flow Setpoint for Fuel Pressure Control.
*   **`<LV_ES>`**: Engine State or Engine Speed (critical for determining operating conditions like "stopped engine").
*   **`<LV_ST_END>`**: Likely a signal indicating the end of a start sequence.
*   **`<LV_FUP_LIH_L_PRS_CTL_REQ>`**: Low Pressure Fuel Control Request (Low Pressure Hydraulic Control Request).
*   **`<LV_FUP_LIH_H_PRS_CTL_REQ>`**: High Pressure Fuel Control Request (High Pressure Hydraulic Control Request).

## Outputs

The subsystem produces the following key outputs:

*   **`<LV_FUEL_MASS_AD_STOP>`**: A flag indicating whether fuel mass adaptation should be stopped.
*   **`<LV_FUEL_MASS_CTL_RST>`**: A flag requesting a reset of the fuel mass control (specifically, the integral part).
*   **`<LV_FUEL_MASS_CTL_STOP>`**: A flag indicating that fuel mass control should be stopped (specifically, the integral part of the controller).
*   **`fuel_mass_ctl_auth`**: The main authorization signal, likely a boolean value (true/false) indicating whether fuel mass control is currently authorized to operate.

## Logic Flow

While the internal logic diagram of the `FUEL_MASS_CTL_AUTH` block is not visible, the logical flow can be inferred from the inputs, outputs, and the accompanying descriptive text:

1.  **Receive Operating Parameters**: The subsystem continuously receives various inputs representing the current state of the engine, fuel system (actual and desired pressures, pump states), and specific control requests.
2.  **Evaluate Control Mode**: It determines the active fuel pressure control mode (e.g., high pressure control mode) based on inputs like `<LV_FUP_LIH_H_PRS_CTL_REQ>` and potentially `<LV_FUP_LIH_L_PRS_CTL_REQ>`.
3.  **Determine "I Part" Stop Condition**:
    *   The subsystem calculates if the "I part" (integral component) of the fuel pressure controller should be stopped.
    *   According to the text, the "I part" is stopped if the system is *not* in high-pressure control mode. This logic influences the `LV_FUEL_MASS_CTL_STOP` output.
4.  **Determine "I Part" Reset Conditions**:
    *   The subsystem checks for a "stopped engine" condition (likely based on `<LV_ES>`). If the engine is stopped, a reset of the "I part" is requested. This drives the `LV_FUEL_MASS_CTL_RST` output.
    *   Additionally, it evaluates if injectors are closed and if a defined debounce time has passed. If both conditions are met, an additional reset of the "I part" is requested, also driving `LV_FUEL_MASS_CTL_RST`.
5.  **Implement Anti-Windup Logic**:
    *   An anti-windup strategy for the "I part" is determined. This strategy depends on the "effective HPP output" (High Pressure Pump output). This internal logic prevents the integral term from accumulating excessively when the controller's output is saturated.
6.  **Evaluate Fuel Mass Adaptation Stop**: Based on various conditions, potentially including the overall control authorization and specific stop requests, the `LV_FUEL_MASS_AD_STOP` flag is determined.
7.  **Generate Overall Authorization**: Based on the evaluation of all stop, reset, and operational mode conditions, the subsystem computes the final `fuel_mass_ctl_auth` signal, indicating whether fuel mass control is authorized to proceed. This signal serves as a master enable/disable for the overall fuel mass control functionality.


--- Page 164 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram implements the control logic for various stop and reset conditions within a fuel mass control system, likely for an automotive application (e.g., engine management unit). It monitors critical parameters such as the Volume Control Valve (VCV) state, fuel pump pressure/flow, and system requests to determine when to:
1.  Stop the overall fuel mass control.
2.  Reset the fuel mass control.
3.  Stop the fuel mass *adjustment* process.

The overall purpose is to ensure safe, stable, and protective operation of the fuel pressure/mass regulation system by identifying abnormal states or conditions that require intervention.

## Inputs
1.  **<STATE_VCV>**: Current operational state of the Volume Control Valve.
2.  **MFP_START**: Boolean, specific state indicating start of fuel pump operation.
3.  **VCV_TEST**: Boolean, specific state indicating VCV self-test.
4.  **VCV_OPEN**: Boolean, specific state indicating VCV is open.
5.  **MFP_MAX**: Boolean, specific state indicating maximum fuel pump operation.
6.  **LV_FUP_LIH_L_PRS_CTL_REQ**: Boolean, request for low-pressure fuel pump control due to limits.
7.  **LV_FUP_LIH_H_PRS_CTL_REQ**: Boolean, request for high-pressure fuel pump control due to limits.
8.  **CLF_FUEL_MASS_CTL_STOP**: Signal related to persistent fuel mass control stop (partially visible, likely a control flag).
9.  **<LV_ST_END>**: Boolean, end of a system state or test.
10. **<FUP_SP>**: Fuel pressure/flow set point.
11. **<FUP>**: Actual measured fuel pressure/flow value.
12. **<PUMP_VOL_VCV>**: Current volume controlled by the VCV or pump.
13. **C_PUMP_VOL_VCV_MAX**: Constant, maximum allowed VCV/pump volume.
14. **C_PUMP_VOL_VCV_MIN**: Constant, minimum allowed VCV/pump volume.
15. **<LV_ES>**: Boolean, Engine Stop status.
16. **C_CTR_MASS_FUEL_CTL_RST**: Constant/Boolean, a trigger or threshold for fuel mass control reset.
17. **<MFF_SP_FUP_CTL>**: Fuel pump control set point for mass flow.
18. **LV_FUEL_MASS_AD_ENA**: Boolean, enable flag for fuel mass adjustment.
19. **C_FUP_DIF_MIN_FUEL_MASS_AD_STOP**: Constant, minimum fuel pressure difference threshold to stop adjustment.

## Outputs
1.  **<LV_FUEL_MASS_CTL_STOP>**: Boolean, indicates fuel mass control should be stopped.
2.  **<LV_FUEL_MASS_CTL_RST>**: Boolean, indicates fuel mass control should be reset.
3.  **<LV_FUEL_MASS_AD_STOP>**: Boolean, indicates fuel mass adjustment should be stopped.

## Logic Flow

The diagram can be analyzed in two main parts: Fuel Mass Control Stop/Reset logic and Fuel Mass Adjustment Stop logic.

### Part 1: Fuel Mass Control Stop and Reset Logic

**A. Generating <LV_FUEL_MASS_CTL_STOP>:**
1.  **VCV State Evaluation**: The current `<STATE_VCV>` is compared for equality (`==`) with four specific VCV states: `MFP_START`, `VCV_TEST`, `VCV_OPEN`, and `MFP_MAX`. Each comparison yields a boolean result.
2.  **State Encoding**: These four boolean results are combined into a bus. This bus feeds a "WRITE BIT" block (with `bit_sel=0`, `num_dec=0`, and `[0:7]` indicating an 8-bit output possibility). This block likely encodes the active VCV states into an 8-bit word `y`. The output `y` is then used as a boolean input for an `AND` gate, implying that if any of the specified VCV states are active (or a specific combination encoded in `y`), this condition is met.
3.  **Pressure Limit Request Aggregation**: `LV_FUP_LIH_L_PRS_CTL_REQ` (low pressure request) and `LV_FUP_LIH_H_PRS_CTL_REQ` (high pressure request) are combined using an `OR` gate. If either a low or high fuel pressure limit request is active, the output of this `OR` gate is true.
4.  **Combined Stop Condition**: The output `y` from the "WRITE BIT" block AND the output from the pressure limit `OR` gate are combined by an `AND` gate. This means that both a specific VCV state condition (from step 2) AND a fuel pressure limit request (from step 3) must be true to activate this part of the stop logic.
5.  **Persistent Stop Logic**: A separate path involving a `NOT` gate for an input `LV_FUEL_MASS_CTL_STOP` (likely a feedback from the output or a related signal), a "Check ~= 0" block (checking for non-zero/true), and a `1/z` (unit delay) block with `Init = 0` (for initial value) and `CLF_FUEL_MASS_CTL_STOP` suggests a latching or persistent stop mechanism. This delayed signal combines with the output from step 4 (implicitly via an `OR` gate, or other combination not fully explicit by the line merging, common for boolean flags). The final outcome is the `<LV_FUEL_MASS_CTL_STOP>` signal.

**B. Generating <LV_FUEL_MASS_CTL_RST>:**
This output is triggered by a large `OR` gate, meaning any of the following conditions will cause a fuel mass control reset:
1.  **End of State/Test**: If `<LV_ST_END>` is `TRUE` (its `NOT` is `FALSE`, and `FALSE == 0` evaluates to `TRUE`).
2.  **Fuel Pressure/Flow Mismatch**: If `<FUP_SP>` is not equal (`!=`) to `<FUP>`, indicating a deviation from the set point.
3.  **VCV Volume Out of Range**:
    *   If `<PUMP_VOL_VCV>` is greater than (`>`) `C_PUMP_VOL_VCV_MAX`.
    *   If `<PUMP_VOL_VCV>` is less than (`<`) `C_PUMP_VOL_VCV_MIN`.
4.  **Engine Stop Condition**: If `<LV_ES>` is `FALSE` (or `0`, `0 == 0` evaluates to `TRUE`).
5.  **Zero Fuel Pump Control Set Point**: If `<MFF_SP_FUP_CTL>` is `0` (`0 == 0` evaluates to `TRUE`).
6.  **Direct Reset Constant**: If `C_CTR_MASS_FUEL_CTL_RST` is `TRUE` (assuming it's a boolean constant or its value implicitly triggers a true condition).

### Part 2: Fuel Mass Adjustment Stop Logic

**C. Generating <LV_FUEL_MASS_AD_STOP>:**
This output is also triggered by an `OR` gate, meaning any of these two conditions will stop the fuel mass adjustment:
1.  **Adjustment Not Enabled**: If `<LV_FUEL_MASS_AD_ENA>` (enable adjustment) is `FALSE` (via a `NOT` gate).
2.  **Excessive Fuel Pressure Difference**:
    *   The absolute difference between `<FUP_SP>` (set point) and `<FUP>` (actual) is calculated (`-` block followed by `abs` block).
    *   If this absolute difference is greater than (`>`) `C_FUP_DIF_MIN_FUEL_MASS_AD_STOP`, meaning the deviation is larger than a defined threshold, the adjustment is stopped. This might indicate a fault or an inability to achieve the set point.


--- Page 165 ---

This page contains a Simulink-like block diagram.

## Function

This Simulink diagram represents a module for **Fuel Pressure Control (FUSL)**, specifically focusing on the calculation of the required fuel mass using Proportional (P) and Integral (I) control strategies. Its primary function is to determine the necessary fuel mass adjustment to maintain the desired fuel pressure in an automotive system, accounting for real-time pressure deviations, engine conditions, and dynamic load changes. The goal is to provide a robust and responsive fuel mass request for optimal engine operation and fuel system stability.

## Inputs

The system receives several inputs, categorized by their source or function:

**Fuel Pressure and Engine State:**
*   `<PV_AV_H>`: High-pressure actual value (likely fuel pressure).
*   `<PV_AV_GRD>`: Ground pressure actual value (potentially another pressure reference).
*   `<FUP_SP>`: Fuel pressure setpoint (desired fuel pressure).
*   `<FUP>`: Fuel pressure (actual measured value).
*   `<N_32>`: Engine speed (used by both P and I controller parts).
*   `<TFU_HPP>`: High-pressure pump temperature (or related status).

**Controller Status and Feedback:**
*   `<fuel_mass_ctl_auth>`: Authorization or enable signal for the fuel mass control.
*   `<LV_FUEL_MASS_CTL_RST>`: Reset signal for the fuel mass controller.
*   `<LV_FUEL_MASS_CTL_STOP>`: Stop signal for the fuel mass controller.
*   `<FUEL_MASS_AD>`: Fuel mass adaptation value (possibly from another module or learned values).
*   `<FUEL_MASS_AD_SEG>`: Fuel mass adaptation segment (feedback to the integral controller).
*   `<FUEL_MASS_REQ_I_CTL_H>`: High-pressure integral control fuel mass request (feedback to the integral controller, indicating a closed-loop or accumulated value).

## Outputs

The system produces the following key outputs:

*   `clc_fuel_mass_ctl`: The main calculated fuel mass control value, representing the combined output of the P and I controllers, which will be used to command the fuel system.
*   `clc_fuel_mass_p_ctl`: The calculated fuel mass component from the proportional controller part.
*   `clc_fuel_mass_i_ctl`: The calculated fuel mass component from the integral controller part.
*   `<FUP_DIF>`: Fuel pressure difference (error signal: actual pressure - setpoint pressure), an important intermediate output.
*   `<LV_FUEL_ADD_ACT>`: Fuel Add Active status, indicating if an additional fuel request is currently active (e.g., for fast load changes).

## Logic Flow

The control logic primarily involves parallel processing by a Proportional (P) controller and an Integral (I) controller, whose outputs are then combined:

1.  **Proportional Control (FUEL_MASS_P_CTL, X.2.1.2.1):**
    *   This block takes inputs such as actual fuel pressures (`PV_AV_H`, `PV_AV_GRD`, `FUP`), the setpoint (`FUP_SP`), engine speed (`N_32`), and high-pressure pump temperature (`TFU_HPP`).
    *   It first calculates the **fuel pressure difference (`FUP_DIF`)**, which is the error between the desired and actual fuel pressure. This `FUP_DIF` is a crucial signal for the controller.
    *   Based on `FUP_DIF` and likely internal mapping/logic (as described in the accompanying text, involving a weighting factor and maps), it computes `FUEL_MASS_REQ_P_CTL`, which is the immediate, proportional fuel mass adjustment required to correct the current pressure error.
    *   It also determines and outputs `LV_FUEL_ADD_ACT`, indicating if additional fuel is needed, particularly during rapid load changes as described in the text.
    *   The output `clc_fuel_mass_p_ctl` is then made available.

2.  **Integral Control (FUEL_MASS_I_CTL, X.2.1.2.2):**
    *   This block receives inputs such as control authorization (`fuel_mass_ctl_auth`), reset (`LV_FUEL_MASS_CTL_RST`), and stop (`LV_FUEL_MASS_CTL_STOP`) signals.
    *   It also takes engine speed (`N_32`) and various feedback/adaptation signals: `FUEL_MASS_AD`, `FUEL_MASS_AD_SEG`, and `FUEL_MASS_REQ_I_CTL_H`. These feedback loops are characteristic of integral control, where past errors are accumulated to eliminate steady-state errors and provide adaptive capabilities.
    *   Based on these inputs, the integral controller calculates its contribution to the fuel mass request. The specific output signal from this block used for the final sum appears to be part of the `clc_fuel_mass_i_ctl` line.
    *   The output `clc_fuel_mass_i_ctl` is generated by this controller.

3.  **Combination of P and I Control:**
    *   The contributions from both the `FUEL_MASS_P_CTL` (as `clc_fuel_mass_p_ctl`) and `FUEL_MASS_I_CTL` (as `clc_fuel_mass_i_ctl`) are combined. This combination, typically a summation, yields the total `clc_fuel_mass_ctl`.
    *   The vertical black bars likely represent signal bus aggregation and distribution, making the individual `p_ctl` and `i_ctl` components available, as well as the final combined `ctl` value.

In summary, the diagram depicts a P-I controller architecture for fuel pressure. The proportional part provides immediate correction based on the current pressure error, while the integral part addresses accumulated errors and provides long-term stability and adaptation, ensuring that the desired fuel pressure is maintained under various operating conditions and dynamic events.


--- Page 166 ---

This page contains two Simulink-like diagrams (Figure 43.14.13 and Figure 43.14.14), which are logically connected.

## Function

This system's primary function is to calculate the required fuel mass for pressure control in an automotive engine. It combines a proportional control component, which responds to deviations in fuel pressure, with an additive fuel mass component. This additive component is conditionally activated for a specific duration when high pedal activity (high pedal value and high pedal gradient) is detected, providing a "pre-controller" boost. The additive fuel mass can be further modified by engine speed and a Test Function Unit (TFU) factor. Additionally, the system outputs the raw fuel pressure difference.

## Inputs

*   `<PV_AV_H>`: Pedal Value Average High (input to both diagrams).
*   `<PV_AV_GRD>`: Pedal Value Average Gradient (input to both diagrams).
*   `<N_32>`: Engine Speed (input to Figure 43.14.13).
*   `<FUP_SP>`: Fuel Pressure Setpoint (input to Figure 43.14.13).
*   `<FUP>`: Actual Fuel Pressure (input to Figure 43.14.13).
*   `<TFU_HPP>`: TFU High Pressure Pump value (likely a flag or magnitude for a test/special mode, input to Figure 43.14.13).
*   `C_PV_THD_FUEL_ADD`: Constant/Threshold for Pedal Value (High) for Fuel Addition (input to Figure 43.14.14).
*   `C_PV_GRD_THD_FUEL_ADD`: Constant/Threshold for Pedal Gradient for Fuel Addition (input to Figure 43.14.14).
*   `C_CTR_CYC_FUEL_ADD`: Counter Cycle/Duration for Fuel Addition (threshold for duration, input to Figure 43.14.14).

## Outputs

*   `<LV_FUEL_ADD_ACT>`: Boolean flag indicating the activation of additional fuel mass (output of Figure 43.14.14, and an input to Figure 43.14.13).
*   `<FUP_DIF>`: Fuel Pressure Difference (output of Figure 43.14.13).
*   `<FUEL_MASS_REQ_P_CTL>`: Final Fuel Mass Request from the Proportional Controller, incorporating all calculated components (output of Figure 43.14.13).

## Logic Flow

The logical flow can be broken down into two main parts, corresponding to the two diagrams, with `<LV_FUEL_ADD_ACT>` acting as a connecting signal.

**Part 1: Detecting Additional Fuel Mass Activation (Figure 43.14.14)**

1.  **Pedal High Value Check:** The `Pedal Value Average High` (`<PV_AV_H>`) is compared against the `C_PV_THD_FUEL_ADD` threshold using a "greater than or equal to" block (`V.6.6`). This yields a boolean result.
2.  **Pedal Gradient High Check:** The `Pedal Value Average Gradient` (`<PV_AV_GRD>`) is compared against the `C_PV_GRD_THD_FUEL_ADD` threshold using another "greater than or equal to" block (`V.6.6`). This also yields a boolean result.
3.  **Combined Condition:** The boolean outputs from the pedal high value and pedal gradient checks are fed into an "AND" gate (`V.6.10`). This means both conditions must be true simultaneously for the "AND" gate to output a true signal.
4.  **Duration Counter Activation:** The "AND" gate's output (true when both conditions are met) serves as the "Reset" (R) input to a duration counter block (`V.7.12`, which includes a unit delay `1/z` feedback and `Init=0`). When the 'R' input is active, the counter is initialized (or triggered to start counting). The `C_CTR_CYC_FUEL_ADD` input likely defines the duration or threshold for this counter. The output `y` of this block, `<LV_FUEL_ADD_ACT>`, becomes true for a specific amount of time (segments/cycles) after the combined pedal conditions are met, and then resets to false.

**Part 2: Calculating Fuel Mass Request (Figure 43.14.13)**

1.  **Fuel Pressure Difference (`<FUP_DIF>`) Calculation:** The `Actual Fuel Pressure` (`<FUP>`) is subtracted from the `Fuel Pressure Setpoint` (`<FUP_SP>`) at a summing junction (`V.7.7`). The result is the `Fuel Pressure Difference` (`<FUP_DIF>`).
2.  **Base Proportional Fuel Mass Request Calculation:**
    *   `Engine Speed` (`<N_32>`) is used as input `x_val` to two lookup tables: "IP_FAC_FUEL_MASS_P_CTL" and "IP_FAC_FUEL_MASS_P_CTL_N". These tables provide engine speed-dependent scaling factors (`Factor_1` and `Factor_2`, respectively).
    *   The `<FUP_DIF>` is first multiplied by `Factor_1` (using a gain block `V.7.8`), and then that result is multiplied by `Factor_2` (using another gain block `V.7.8`). This chained multiplication yields an intermediate proportional fuel mass request, `Base_P_Fuel_Mass_Req`.
3.  **Additive Fuel Mass Component Calculations (Conditional):**
    *   **Pedal-Based Additive Request (`Pedal_Add_Req`):** A subsystem "FUEL_MASS_ADD_CLC" calculates `Raw_Pedal_Add` based on `<PV_AV_H>` and `<PV_AV_GRD>`. This `Raw_Pedal_Add` is then fed into a switch block (`V.6.10`, "Check ~= 0"). If the `<LV_FUEL_ADD_ACT>` flag (from Part 1) is true, `Raw_Pedal_Add` is passed through as `Pedal_Add_Req`; otherwise, `0` is output.
    *   **Engine Speed-Based Additive Request (`N_Add_Req`):** A lookup table "IP_FUEL_MASS_REQ_ADD" takes `<N_32>` as input to yield `Raw_N_Add`. This `Raw_N_Add` is then multiplied by the `<LV_FUEL_ADD_ACT>` flag. This ensures the engine speed-based additive component is only active when `LV_FUEL_ADD_ACT` is true. The result is `N_Add_Req`.
    *   **TFU Factor Application:** A lookup table "IP_FAC_FUEL_MASS_P_CTL_TFU" takes `<TFU_HPP>` as input to produce `TFU_Factor`. This `TFU_Factor` then multiplies the `Pedal_Add_Req` (from the switch `V.6.10`) to produce `TFU_Modified_Pedal_Add`.
4.  **Combining All Fuel Mass Request Components:**
    *   A summing junction combines `Pedal_Add_Req`, `N_Add_Req`, and `TFU_Modified_Pedal_Add`. The output of this summing junction is the `Total_Additive_Req`.
    *   Finally, the `Base_P_Fuel_Mass_Req` (from step 3) and the `Total_Additive_Req` are summed at the rightmost summing junction (`V.7.7`). The output of this final summation is the overall `Final Fuel Mass Request` (`<FUEL_MASS_REQ_P_CTL>`).


--- Page 167 ---

This page contains Simulink diagrams.

## Function
The primary function of these Simulink diagrams, under the general heading "FUSL, Fuel pressure control," is to calculate the **Fuel Mass Request Control (FUEL_MASS_REQ_CTL)**. This involves deriving an integral component of the fuel mass request (`FUEL_MASS_REQ_I_CTL`) and a segmented fuel mass adjustment (`FUEL_MASS_AD_SEG`) based on various engine operating parameters, control signals, and feedback. These components are then combined with proportional and other adjustment terms to generate the final requested fuel mass for the pump, indicative of a Proportional-Integral (PI) control strategy applied to fuel system management.

## Inputs
**Figure 43.14.15 (Top Diagram):**
*   `C_FUEL_MASS_REQ_I_CTL_MAX`: A constant representing the maximum allowable value for the integral fuel mass request.
*   `C_FUEL_MASS_REQ_I_CTL_MIN`: A constant representing the minimum allowable value for the integral fuel mass request.
*   `LV_FUEL_MASS_CTL_RST`: A boolean or event signal used to reset the integral accumulator for `FUEL_MASS_REQ_I_CTL`.
*   `LV_FUEL_MASS_CTL_STOP`: A boolean or event signal used to stop the accumulation/integration for `FUEL_MASS_AD_SEG`.
*   `FUEL_MASS_REQ_I_CTL_H`: A high-priority or historical fuel mass request, serving as a base for calculations.
*   `FUP_DIF`: Fuel pressure difference, likely an error signal (e.g., actual pressure - target pressure).
*   `N_32`: An engine speed signal or similar operating point parameter.
*   `FUEL_MASS_AD`: A general fuel mass adjustment value, possibly from another control loop or calibration.

**Figure 43.14.16 (Bottom Diagram):**
*   `clc_fuel_mass_ctl`: A calculated base or desired fuel mass control value.
*   `feedback`: A feedback signal, likely representing actual fuel pressure or flow for closed-loop control.
*   `FUEL_MASS_REQ_P_CTL`: The proportional component of the fuel mass request control.
*   `FUEL_MASS_REQ_I_CTL`: The integral component of the fuel mass request control, output from Figure 43.14.15.
*   `FUEL_MASS_AD`: The general fuel mass adjustment value (same as input to Figure 43.14.15, implying it's an external input to the overall system).

## Outputs
**Figure 43.14.15 (Top Diagram):**
*   `FUEL_MASS_REQ_I_CTL`: The calculated integral component of the fuel mass request, which is then used as an input to the next stage.
*   `FUEL_MASS_AD_SEG`: The calculated segmented fuel mass adjustment, which also appears to be a feedback input to itself, indicating an internal state variable.

**Figure 43.14.16 (Bottom Diagram):**
*   `FUEL_MASS_REQ_CTL`: The final, combined fuel mass request control value for the pump.

## Logic Flow

The overall logic flow is split into two distinct, but interconnected, calculation stages:

**Stage 1: Calculation of Integral Fuel Mass Request and Adjustment Segment (Figure 43.14.15)**

1.  **Integral Fuel Mass Request (`FUEL_MASS_REQ_I_CTL`) Path:**
    *   The `FUEL_MASS_REQ_I_CTL_H` input is fed into an accumulator-like block (indicated by the "Check ~= 0" label and the "0" reset input). This block integrates or accumulates the input value.
    *   If the `LV_FUEL_MASS_CTL_RST` signal is active (non-zero), the accumulator's output is reset to 0.
    *   The accumulated value is then passed through a saturation block (limiter, "MX MN u y") to ensure it stays within the specified minimum (`C_FUEL_MASS_REQ_I_CTL_MIN`) and maximum (`C_FUEL_MASS_REQ_I_CTL_MAX`) limits.
    *   The output of the saturation block is the `FUEL_MASS_REQ_I_CTL`.

2.  **Fuel Mass Adjustment Segment (`FUEL_MASS_AD_SEG`) Path:**
    *   `FUP_DIF` is processed by a 1-D lookup table (indicated by "IP_val" and "x_val" ports). This table likely maps fuel pressure deviation to a proportional factor (`IP_FUEL_MASS_REQ_I_CTL`).
    *   `N_32` (engine speed) is similarly processed by another 1-D lookup table to yield a factor (`IP_FAC_FUEL_MASS_I_CTL_N`).
    *   Both lookup table outputs are multiplied by `FUEL_MASS_REQ_I_CTL_H`.
    *   The results of these two multiplications are summed together.
    *   This sum is then fed into a second accumulator-like block (also "Check ~= 0"). This accumulator's operation (integration) is stopped or held if `LV_FUEL_MASS_CTL_STOP` is active.
    *   The accumulated value is then added to the external `FUEL_MASS_AD` input using a sum block.
    *   The final result of this sum is the `FUEL_MASS_AD_SEG` output. Notably, `FUEL_MASS_AD_SEG` also appears as an input to this block, suggesting it's a state variable updated iteratively or is part of an internal feedback loop.

**Stage 2: Final Fuel Mass Request Control Calculation (Figure 43.14.16)**

1.  **Proportional Term Processing:**
    *   `clc_fuel_mass_ctl` passes through a 1-D lookup table or a functional block (indicated by "IP_val" block), which likely processes it to derive a specific proportional contribution (`IP_FUEL_MASS_REQ_P_CTL`).
    *   This processed value is then added to the base proportional control `FUEL_MASS_REQ_P_CTL`.

2.  **Integral Term Processing:**
    *   `feedback` passes through another 1-D lookup table or functional block (similar "IP_val" block), deriving a processed integral contribution (`IP_FUEL_MASS_REQ_I_CTL`).
    *   This processed value is then added to the `FUEL_MASS_REQ_I_CTL` (the output from Stage 1).

3.  **Final Summation:**
    *   The result from the proportional term processing (sum of `IP_FUEL_MASS_REQ_P_CTL` and `FUEL_MASS_REQ_P_CTL`) and the result from the integral term processing (sum of `IP_FUEL_MASS_REQ_I_CTL` and `FUEL_MASS_REQ_I_CTL`) are summed together.
    *   Finally, the external `FUEL_MASS_AD` signal is added to this total.
    *   The grand sum of all these components yields the final `FUEL_MASS_REQ_CTL`, which is the overall command for the fuel pump.


--- Page 168 ---

This page contains two Simulink-style block diagrams, Figure 43.14.17 and Figure 43.14.18, both part of a "Fuel pressure control" (FUSL) system.

## Function
The primary function of these diagrams is to describe components of a fuel mass request control system, specifically focusing on the calculation and management of the integral part (I-part) of the fuel mass request and its mean value, potentially for adaptive control.

*   **Figure 43.14.17** depicts a high-level subsystem (`f()`) that integrates different control blocks (`CLC_FUEL_MASS_REQ_I_CTL_MMV`, `CLC_FUP_CTL_AD`) involved in calculating requested fuel mass and adaptive fuel pressure. It serves as an overview of the interaction between these modules.
*   **Figure 43.14.18** details the specific calculation of the "Mean value of the I-part" for the fuel mass request (`<FUEL_MASS_REQ_I_CTL_MMV>`), which is explicitly stated to occur every 100ms. This mean value is a crucial state variable for the overall fuel control strategy.

## Inputs

**Inputs common to both diagrams/overall system context:**
*   `<LV_ES>`: A logical or enumerated signal representing an engine status or enablement state (e.g., "engine running", "engine stopped"). Its inverted state is used as a control signal for the mean value calculation.
*   `<FUEL_MASS_REQ_I_CTL>`: The instantaneous requested fuel mass, specifically the I-part component. This is the primary value being processed.
*   `<FUEL_MASS_REQ_I_CTL_MMV>`: The current or previous "Mean value of the Fuel Mass Request I-part". This acts as a feedback or initial condition for the ongoing mean value calculation.

**Inputs specific to Figure 43.14.17 (high-level `f()` subsystem):**
*   `<input>`: A generic input signal to the `f()` subsystem, which branches internally to become `<LV_ES>` and `<FUEL_MASS_REQ_I_CTL>`.
*   `<feedback>`: A generic feedback signal to the `f()` subsystem, which internally represents `<FUEL_MASS_REQ_I_CTL_MMV>`.

## Outputs

**Output common to both diagrams/overall system context:**
*   `<FUEL_MASS_REQ_I_CTL_MMV>`: The newly calculated and updated "Mean value of the Fuel Mass Request I-part". This value is produced by Figure 43.14.18 and consumed/processed by Figure 43.14.17.

**Output specific to Figure 43.14.17 (high-level `f()` subsystem):**
*   `opm_100ms`: A timing or event signal indicating that certain operations within the `f()` subsystem (such as the mean value calculation in Figure 43.14.18) are executed with a period of 100 milliseconds.

## Logic Flow

The logical flow is described separately for each diagram:

**Figure 43.14.17: High-level Calculation Section**
1.  **Subsystem Entry:** The `f()` subsystem receives two external inputs, `<input>` and `<feedback>`.
2.  **Internal Signal Distribution:**
    *   The `<input>` signal is distributed to drive internal signals `<LV_ES>` and `<FUEL_MASS_REQ_I_CTL>`.
    *   The `<feedback>` signal is distributed to drive the internal signal `<FUEL_MASS_REQ_I_CTL_MMV>`.
3.  **Fuel Mass Request I-part MMV Control Block (`CLC_FUEL_MASS_REQ_I_CTL_MMV`):** This block takes `<LV_ES>`, `<FUEL_MASS_REQ_I_CTL>`, and `<FUEL_MASS_REQ_I_CTL_MMV>` as inputs. It performs specific control logic, likely related to the overall management of the mean value of the I-part, and its output feeds into the adaptive fuel pressure control block.
4.  **Adaptive Fuel Pressure Control Block (`CLC_FUP_CTL_AD`):** This block receives the original `<input>` and `<feedback>` signals, along with the output from `CLC_FUEL_MASS_REQ_I_CTL_MMV`. It implements adaptive control algorithms for fuel pressure, producing an internal signal `clc_fup_ctl_ad`.
5.  **Timing Output:** The `f()` subsystem generates `opm_100ms` as an output, indicating a periodic operation frequency for parts of this control section.

**Figure 43.14.18: Calculation of Mean value of the I-part (occurring every 100ms)**
1.  **Input Conditioning (`C_FUEL_MASS_REQ_I_CTL_MMV_CRLC`):** The instantaneous `<FUEL_MASS_REQ_I_CTL>` (I-part fuel mass request) is fed into the `C_FUEL_MASS_REQ_I_CTL_MMV_CRLC` block. This block likely performs signal conditioning, such as rate limiting or range checking, before the mean value calculation. Its output (`m`) is then passed to the main mean value block.
2.  **Enable/Reset Logic:** The `<LV_ES>` signal (e.g., engine state) is passed through a `NOT` gate. The inverted signal (`NOT <LV_ES>`) serves as an enable or reset input (`E`) for the subsequent mean value calculation block. This implies that the calculation might be enabled, disabled, or reset based on the specific engine operating condition indicated by `<LV_ES>`.
3.  **Mean Value Calculation (`m x_out` block):** This central block performs the actual calculation of the mean value. It receives:
    *   `m`: The conditioned `FUEL_MASS_REQ_I_CTL` value.
    *   `E`: The enable/reset signal from the `NOT` gate.
    *   `x_in`: The previous or current `<FUEL_MASS_REQ_I_CTL_MMV>` value, which acts as the initial state or integrated feedback for the calculation.
    The block integrates or averages `m` over time, potentially with specific characteristics suggested by the internal graph (e.g., non-linear mapping, saturation, or filtering), while being controlled by `E` and initialized by `x_in`.
4.  **Output:** The result of this calculation, `x_out`, represents the updated "Mean value of the Fuel Mass Request I-part," which is then outputted as `<FUEL_MASS_REQ_I_CTL_MMV>`. This updated mean value is then available for other parts of the control system and for the next 100ms iteration of this calculation.


--- Page 169 ---

This page contains two Simulink-like diagrams, both related to fuel pressure control in an automotive context. The second diagram (Figure 43.14.20) specifically details the "Calculation of Adaptive fuel mass difference," which appears to be a core component of the higher-level control shown in the first diagram (Figure 43.14.19).

## Function

The primary function of these diagrams, specifically focusing on "Calculation of Adaptive fuel mass difference" (Figure 43.14.20), is to **calculate and update adaptive fuel mass values and their differences** based on engine operating conditions and calibrated limits. This adaptive mechanism is crucial for modern engine control units (ECUs) to compensate for variations in fuel quality, injector characteristics, engine wear, and environmental factors, ensuring precise fuel delivery for optimal combustion, emissions, and fuel economy. The outputs of this calculation (`FUEL_MASS_AD_DIF`, `FUEL_MASS_AD`, `T_CTR_FUEL_MASS_AD`) are then integrated into a broader "Fuel pressure control" system, as suggested by Figure 43.14.19, to generate a composite adaptive fuel pressure control signal (`clc_fup_ctl_ad`).

## Inputs

The following are the key inputs to the system, derived from both diagrams:

*   **Dynamic System Parameters:**
    *   `MFP`: Mass Flow Primary (likely measured air mass or a primary fuel mass request).
    *   `N_32`: Engine speed (an integer value representing RPM or similar).
    *   `LV_FUEL_MASS_AD_STOP`: A boolean or logical flag to enable/disable fuel mass adaptation (e.g., during specific engine modes).
    *   `FUEL_MASS_REQ_I_CTL_MMV`: Internally requested fuel mass, potentially a base value from a mapping.
    *   `T_CTR_FUEL_MASS_AD_OLD`: Previous iteration's temperature compensation for fuel mass adaptation, used for recursive calculations.
    *   `T_CTR_FUEL_MASS_AD`: Current temperature compensation for fuel mass adaptation, potentially an initial value that gets updated.
    *   `FUEL_MASS_AD`: Current adaptive fuel mass value, an initial input that gets updated by the system.

*   **Calibration Constants (V.6.11):**
    *   `C_N_FUEL_MASS_AD_MIN`: Minimum engine speed threshold for fuel mass adaptation.
    *   `C_N_FUEL_MASS_AD_MAX`: Maximum engine speed threshold for fuel mass adaptation.
    *   `C_MFP_FUEL_MASS_AD_MIN`: Minimum Mass Flow Primary threshold for fuel mass adaptation.
    *   `C_MFP_FUEL_MASS_AD_MAX`: Maximum Mass Flow Primary threshold for fuel mass adaptation.
    *   `C_T_CTR_FUEL_MASS_AD_MAX`: Maximum allowable temperature compensation value for adaptation.
    *   `C_FUEL_MASS_AD_COR_CRLC`: A correction factor or calibration constant for the fuel mass adaptation calculation.

## Outputs

The key outputs generated by the system are:

*   `T_CTR_FUEL_MASS_AD`: The updated or calculated temperature compensation for fuel mass adaptation. This value is likely constrained or modified based on internal logic.
*   `FUEL_MASS_AD_DIF`: The calculated adaptive fuel mass difference. This represents the instantaneous deviation or correction required for fuel mass.
*   `FUEL_MASS_AD`: The updated adaptive fuel mass value. This is typically a long-term, filtered adaptation value that provides a stable correction.
*   `clc_fup_ctl_ad`: (From Figure 43.14.19) A composite bus signal representing the calculated fuel pressure control adaptation. This bus bundles `T_CTR_FUEL_MASS_AD` (updated value) and a processed version of `FUEL_MASS_AD_DIF` (output of block `V.6.8`).

## Logic Flow

The logical flow can be described by examining Figure 43.14.20 (the detailed calculation) and then its integration into Figure 43.14.19 (the higher-level control).

**1. Input Collection (Figure 43.14.20 - "Chart" Block Inputs):**
    *   The system continuously receives real-time operational parameters (`LV_FUEL_MASS_AD_STOP`, `T_CTR_FUEL_MASS_AD_OLD`, `N_32`, `MFP`, `FUEL_MASS_REQ_I_CTL_MMV`, `T_CTR_FUEL_MASS_AD`, `FUEL_MASS_AD`) from sensors or other control modules within the ECU.
    *   Simultaneously, it accesses a set of pre-defined calibration constants (`C_N_FUEL_MASS_AD_MIN`, `C_N_FUEL_MASS_AD_MAX`, `C_MFP_FUEL_MASS_AD_MIN`, `C_MFP_FUEL_MASS_AD_MAX`, `C_T_CTR_FUEL_MASS_AD_MAX`, `C_FUEL_MASS_AD_COR_CRLC`) which define the operational envelopes and tuning parameters for the adaptation algorithm.

**2. Adaptive Logic Execution (Within the "Chart" Block of Figure 43.14.20):**
    *   The "Chart" block typically represents a Stateflow chart or a complex embedded MATLAB function. This block contains the core adaptive logic.
    *   **Adaptation Enablement/Conditions:** The chart first evaluates if adaptation is allowed. This likely involves checking `LV_FUEL_MASS_AD_STOP` (to ensure adaptation isn't explicitly disabled) and verifying that `N_32` (engine speed) and `MFP` (mass flow) fall within their respective minimum and maximum thresholds defined by `C_N_FUEL_MASS_AD_MIN/MAX` and `C_MFP_FUEL_MASS_AD_MIN/MAX`. This ensures adaptation only occurs under stable and relevant operating conditions.
    *   **Difference Calculation:** If adaptation conditions are met, the chart calculates `FUEL_MASS_AD_DIF`. This calculation uses current sensor inputs (`MFP`, `N_32`, `FUEL_MASS_REQ_I_CTL_MMV`) and potentially the `T_CTR_FUEL_MASS_AD` to determine the immediate deviation of the actual fuel mass from the target.
    *   **Temperature Compensation Update:** The `T_CTR_FUEL_MASS_AD` input is processed. The chart likely updates this compensation value based on current operating temperatures and other factors, potentially limiting it to `C_T_CTR_FUEL_MASS_AD_MAX`. The `T_CTR_FUEL_MASS_AD_OLD` serves as a feedback loop for filtering or integrating the temperature compensation over time.
    *   **Adaptive Fuel Mass Update:** The `FUEL_MASS_AD` input is updated to become the output `FUEL_MASS_AD`. This update is typically an integration or a filtered sum of `FUEL_MASS_AD_DIF` over time, using `C_FUEL_MASS_AD_COR_CRLC` as a scaling or correction factor to ensure stable long-term adaptation. This creates a continuous, self-learning adjustment to the baseline fuel mass.

**3. Integration and Output Generation (Figure 43.14.19 - System Level):**
    *   The calculated outputs from the detailed adaptive logic (`T_CTR_FUEL_MASS_AD`, `FUEL_MASS_AD_DIF`, and `FUEL_MASS_AD`) are propagated.
    *   **`FUEL_MASS_AD_DIF` Processing:** The `FUEL_MASS_AD_DIF` signal undergoes further processing by block `V.6.8` (e.g., filtering, limiting, or scaling) before being combined with other signals.
    *   **Feedback for `FUEL_MASS_AD`:** The updated `FUEL_MASS_AD` (long-term adaptive value) is fed back into the `FUEL_MASS_AD_CLC` block (X.3.2.2 in Figure 43.14.19), which suggests it's continuously refined based on the `FUEL_MASS_AD_DIF`.
    *   **Final Control Signal Bus Creation:** The updated `T_CTR_FUEL_MASS_AD` and the output of the `V.6.8` block (derived from `FUEL_MASS_AD_DIF`) are combined into a single bus signal named `clc_fup_ctl_ad`. This bus represents the aggregated adaptive correction to be applied to the fuel pressure control system.

In summary, the system iteratively calculates an immediate adaptive fuel mass difference and a long-term adaptive fuel mass correction, taking into account various engine parameters and calibrated limits. These adaptive values are then bundled into a control signal to finely adjust fuel pressure or injection duration for optimal engine performance.


--- Page 170 ---

This page contains two interconnected diagrams: a Stateflow chart (Figure 43.14.21) and a Simulink block diagram (Figure 43.14.22), which are both components of a Simulink model.

## Function

The primary function of this system is to manage and limit a "Fuel Mass Adaptation" value (`<FUEL_MASS_AD>`) in an automotive fuel pressure control system.
The Stateflow chart determines *when* and *how much* to adjust the fuel mass adaptation based on engine operating conditions (like speed and mass flow) and an internal counter. The Simulink diagram then takes this calculated adjustment, applies it to the current adaptation value, and ensures the final adaptation value remains within specified minimum and maximum limits, with an option to reset it.

## Inputs

**From Stateflow Chart (Figure 43.14.21):**
*   `T_CTR_FUEL_MASS_AD_OLD`: Previous value of the fuel mass adaptation counter.
*   `LV_FUEL_MASS_AD_STOP`: A boolean flag; if non-zero, it stops the adaptation process and resets related values.
*   `N_32`: Engine speed or similar rotational speed.
*   `C_N_FUEL_MASS_AD_MAX`: Maximum threshold for engine speed condition.
*   `C_N_FUEL_MASS_AD_MIN`: Minimum threshold for engine speed condition.
*   `MFP`: Mass flow (e.g., Mass Air Flow).
*   `C_MFP_FUEL_MASS_AD_MAX`: Maximum threshold for mass flow condition.
*   `C_MFP_FUEL_MASS_AD_MIN`: Minimum threshold for mass flow condition.
*   `C_T_CTR_FUEL_MASS_AD_MAX`: Maximum threshold for the adaptation counter, triggering `FUEL_MASS_AD_DIF` calculation.
*   `C_T_CTR_FUEL_MASS_AD_MIN`: Minimum threshold for the adaptation counter, possibly to keep `FUEL_MASS_AD_DIF` at 0 if below this.
*   `FUEL_MASS_REQ_I_CTL_MMV`: A requested fuel mass value, likely from an instantaneous or model-based calculation.
*   `C_FUEL_MASS_AD_COR_CRLC`: A correlation or correction factor for the fuel mass adaptation difference.

**From Simulink Diagram (Figure 43.14.22):**
*   `LC_AD_CLR_FUEL_MASS_AD`: A clear/reset signal for the entire fuel mass adaptation value.
*   `C_FUEL_MASS_AD_MAX`: Global maximum limit for the `FUEL_MASS_AD` value.
*   `C_FUEL_MASS_AD_MIN`: Global minimum limit for the `FUEL_MASS_AD` value.
*   `<FUEL_MASS_AD>`: The current fuel mass adaptation value, likely an input/output port for feedback.
*   `<FUEL_MASS_AD_DIF>`: The fuel mass adaptation difference calculated by the Stateflow chart.

## Outputs

**From Stateflow Chart (Figure 43.14.21):**
*   `T_CTR_FUEL_MASS_AD`: The current value of the fuel mass adaptation counter.
*   `FUEL_MASS_AD_DIF`: The calculated fuel mass adaptation difference value.

**From Simulink Diagram (Figure 43.14.22):**
*   `<FUEL_MASS_AD>`: The updated, limited, and potentially reset fuel mass adaptation value.

## Logic Flow

The system operates in two main stages:
1.  **Fuel Mass Adaptation Difference Calculation (Stateflow Chart - Figure 43.14.21):** This chart controls the timing and calculation of a difference value (`FUEL_MASS_AD_DIF`) that will be applied to the main fuel mass adaptation.

    *   **Initialization:** The counter `T_CTR_FUEL_MASS_AD` is initialized or updated with its previous value `T_CTR_FUEL_MASS_AD_OLD`.
    *   **Adaptation Stop Condition:**
        *   If `LV_FUEL_MASS_AD_STOP` is **not equal to 0** (i.e., adaptation is commanded to stop), then `T_CTR_FUEL_MASS_AD` and `FUEL_MASS_AD_DIF` are both immediately reset to 0.
        *   If `LV_FUEL_MASS_AD_STOP` **is 0** (i.e., adaptation is allowed), the flow proceeds to operational checks.
    *   **Operational Conditions Check:**
        *   **Engine Speed Check:** It verifies if the engine speed `N_32` is within the defined range (`C_N_FUEL_MASS_AD_MIN` to `C_N_FUEL_MASS_AD_MAX`). If `N_32` is outside this range, `T_CTR_FUEL_MASS_AD` is reset to 0.
        *   **Mass Flow Check:** If `N_32` is in range, it then checks if `MFP` is within its defined range (`C_MFP_FUEL_MASS_AD_MIN` to `C_MFP_FUEL_MASS_AD_MAX`). If `MFP` is outside this range, `T_CTR_FUEL_MASS_AD` is reset to 0.
        *   **Counter Increment:** If both `N_32` and `MFP` are within their respective ranges, `T_CTR_FUEL_MASS_AD` is incremented by 1.
    *   **Adaptation Difference Calculation Trigger:**
        *   **If `T_CTR_FUEL_MASS_AD` reaches or exceeds `C_T_CTR_FUEL_MASS_AD_MAX`:**
            *   `T_CTR_FUEL_MASS_AD` is reset to 0.
            *   `FUEL_MASS_AD_DIF` is calculated by multiplying `FUEL_MASS_REQ_I_CTL_MMV` with `C_FUEL_MASS_AD_COR_CRLC`. This calculates the actual adaptation step.
        *   **If `T_CTR_FUEL_MASS_AD` is less than `C_T_CTR_FUEL_MASS_AD_MAX` AND `T_CTR_FUEL_MASS_AD` is less than or equal to `C_T_CTR_FUEL_MASS_AD_MIN`:**
            *   `FUEL_MASS_AD_DIF` is set to 0. This prevents adaptation calculation if the counter has not accumulated enough or is below a minimum active threshold.

2.  **Limiting Fuel Mass Adaptation Value (Simulink Diagram - Figure 43.14.22):** This diagram takes the current adaptation value and the calculated difference, applies the difference, and ensures the result stays within limits.

    *   **Add Adaptation Difference:** The current `FUEL_MASS_AD` value is added to the `FUEL_MASS_AD_DIF` (calculated by the Stateflow chart). This sum represents the new, unconstrained adaptation value.
    *   **Limit Adaptation Value:** This summed value then passes through a saturation block.
        *   The upper limit (MX) of the saturation is `C_FUEL_MASS_AD_MAX`.
        *   The lower limit (MN) of the saturation is `C_FUEL_MASS_AD_MIN`.
        *   This ensures the adaptation value never exceeds its permissible range.
    *   **Clear Adaptation (Switch):** A switch block (labeled `Check ~= 0`) takes the output of the saturation block as its data input.
        *   If the `LC_AD_CLR_FUEL_MASS_AD` signal (control input) is **non-zero** (true), the switch outputs `0`. This effectively resets the fuel mass adaptation to zero.
        *   If `LC_AD_CLR_FUEL_MASS_AD` is **zero** (false), the switch outputs the limited value from the saturation block.
    *   **Output:** The final output of the switch is the updated and limited `<FUEL_MASS_AD>` value, which is then typically fed back as an input for the next time step.


--- Page 192 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "FUSL, Fuel pressure actuator control," describes the control logic for a fuel pressure actuator, likely a Volume Control Valve (VCV) in a high-pressure fuel pump system. Its primary function is to manage the operational states, execute initialization procedures, and compute the necessary commands and status outputs for controlling fuel pressure based on various engine and system parameters. The "Initialization" section below the diagram specifically highlights the handling of output variable initialization triggered by ECU reset, engine run to engine stop, and NVMY reset.

## Inputs
The diagram receives a comprehensive set of inputs, mostly categorized into a large bus labeled "input" on the left, and specific control signals.

**Primary Control/State Inputs:**
*   `<LV ES>`: Engine Stop/Run signal, influencing activation of 1S task.
*   `fc_INI`: Initialization flag from the scheduler.
*   `fc_OPM_10MS`: 10ms task activation flag from the scheduler.
*   `fc_OPM_SEG`: Segment-based task activation flag from the scheduler.
*   `fc_OPM_1S`: 1-second task activation flag from the scheduler.
*   `[feedback]`: A feedback signal from the OPM block, indicating current system state or previous calculations.

**Detailed System/Sensor/Request Inputs (feeding into the "input" bus):**
*   `<ACTION INFR MfiDisable T3>`
*   `<ACTION INFR MfiEnable T3>`
*   `<ACTION INFR MfiReset T3>`
*   `<ACTION INFR SetCurMfiModeVcv T3>`
*   `<ACTION INFR MfiSetVcvCtlPls T3>`
*   `<ACTION INFR MfiSetVcvDeaccPls T3>`
*   `<ACTION INFR MfiUpdate T3>`
*   `<ACTION INFR SetCurCtlModeVcv T3>`
*   `<CAM FUEL PUMP>`: Camshaft fuel pump related signal.
*   `<ECU STATE>`: Current state of the Engine Control Unit.
*   `<FUEL MASS REQ CTL>`: Requested fuel mass for control.
*   `<FUP>`: Fuel Pressure.
*   `<FUP DIF>`: Fuel Pressure Differential.
*   `<FUP SP>`: Fuel Pressure Setpoint.
*   `<FUP SP GRD SEG>`
*   `<LV ACR VCV TEST REQ>`: Request for VCV test.
*   `<LV FIRST VLD TOOTH>`: First valid tooth signal (crankshaft/camshaft related).
*   `<LV FUP LH LPS CTL REQ>`
*   `<LV FUP LIH DPS DI>`
*   `<LV IGK>`: Ignition key status.
*   `<LV IS>`: Ignition status.
*   `<LV ST END>`: Engine Stop End status.
*   `<LV ST H PRS>`
*   `<LV VAR HPP>`: Variable High-Pressure Pump.
*   `<LV VCV OPEN EXT REQ>`: External request to open VCV.
*   `<LV VCV SL ENA>`: VCV Slave Enable.
*   `<MFF SP FUP CTL>`
*   `<N 32>`: Engine speed or similar rotational speed.
*   `<R VCV>`: VCV resistance or feedback.
*   `<RST>`: Reset signal.
*   `<TCO>`: Coolant Temperature.
*   `<TFPA>`: Fuel Pressure Actuator Temperature.
*   `<TFU HPP>`: High-Pressure Pump Fuel Temperature.
*   `<T AST>`
*   `<T SEG AV>`
*   `<VB>`: Battery Voltage.

## Outputs
The system generates numerous outputs related to VCV control, fuel mass flow, and operational states, which are then routed through a "Signal Manager".

*   `<ANG CUR OFF VCV>`: Angle for current VCV off.
*   `<ANG CUR ON VCV>`: Angle for current VCV on.
*   `<ANG REF VCV>`: Reference angle for VCV.
*   `<LV INH VCV>`: Inhibit VCV signal.
*   `<LV MFP REQ LOW>`: Low fuel mass flow request.
*   `<LV VCV CLOSE SL AD END>`: VCV close slave end signal.
*   `<LV VCV CLOSE SL AD WAIT>`: VCV close slave wait signal.
*   `<MFP>`: Measured Fuel Mass Flow.
*   `<MFP MAX>`: Maximum Fuel Mass Flow.
*   `<MFP REQ CTL>`: Requested Fuel Mass Flow for control.
*   `<PUMP VOL VCV>`: Pump volume for VCV.
*   `<STATE VCV>`: Current state of the VCV.
*   `<STATE VCV CLOSE SL>`: State of VCV in close slave mode.
*   `<VCV CLOSE RNG>`: VCV close range signal.
*   `[feedback]`: A feedback signal provided to internal blocks.

## Logic Flow

The diagram outlines a structured control logic, beginning with scheduling and initialization, leading to core operational control, and incorporating feedback.

1.  **Scheduling and Mode Management (Orange Block - "LV_ES"):**
    *   This block functions as a central scheduler or state machine, dictating the execution of different operational tasks.
    *   It defines "Recurrence" rates (10MS, SEG, 1S) for its internal tasks.
    *   It specifies "Init" conditions (RST, ERU2ES, NVMINI, NVMRES, NVMSTO) that trigger initialization routines upon system reset or non-volatile memory operations.
    *   "Activation" rules govern when specific tasks run: the 10ms and SEG tasks are always active, while the 1s task activates when `<LV ES>` is 0 (likely indicating engine stop or a pre-start phase).
    *   "Deactivation" occurs if activation conditions are no longer met.
    *   This block generates scheduling flags (`fc_INI`, `fc_OPM_10MS`, `fc_OPM_SEG`, `fc_OPM_1S`) that control the execution of downstream modules.

2.  **Initialization Phase (Block "INI" - X.1):**
    *   Triggered by the `fc_INI` signal from the "LV_ES" block, this module is responsible for setting the initial values of all output variables.
    *   It also receives a bundle of "input" signals (likely including system status or default values) and a `feedback` signal.
    *   As described in the accompanying text, this initialization is critical at ECU reset, during the transition from engine run to engine stop, and upon NVMY (Non-Volatile Memory) reset to ensure a consistent and safe starting state for the fuel pressure control system.

3.  **Operational Management (Block "OPM" - X.2):**
    *   This block is the core functional unit responsible for real-time fuel pressure actuator control.
    *   It receives the scheduled activation flags (`fc_OPM_SEG`, `fc_OPM_10MS`, `fc_OPM_1S`) from the "LV_ES" block, which synchronize its internal operations with the system's execution rates.
    *   All the detailed system inputs (sensor readings, control requests, diagnostic flags, etc.) are fed into this block via the "input" bus.
    *   Using these inputs, the "OPM" block calculates the required output values for the fuel pressure actuator. This likely involves complex control algorithms (e.g., PID controllers for pressure regulation), state-based logic for VCV operation, and safety/diagnostic functions.
    *   It generates all the blue output signals related to VCV angles, fuel mass flow, and various operational states.
    *   Crucially, it also produces a `feedback` signal, which is fed back to both the "INI" and "OPM" blocks, indicating that outputs from the operational logic can influence subsequent initializations or further operational calculations (e.g., current state informing next control action).

4.  **Signal Manager:**
    *   This block appears to be an interface or aggregation point for the calculated outputs from the "OPM" block. It likely serves to pass these signals to other parts of the overall system, perhaps for logging, monitoring, or acting as an interface to the hardware. Its internal logic is not detailed in this view, suggesting it primarily acts as a signal routing and management component.


--- Page 193 ---

This page contains a Simulink diagram, specifically illustrating aspects of fuel pressure actuator control and initialization within an automotive system.

## Function
This Simulink diagram outlines the initialization logic for a Fuel Pressure Actuator Control system (FUSL), likely involving a Valve Controlled Pump (VCV). Its primary function is to establish and manage the initial states, operating parameters, and persistent data (from Non-Volatile Memory - NVM) for the fuel pressure regulation system during various system events, such as ECU reset, engine run-up, and NVM operations. It prepares the VCV and related components for their operational phase by setting critical control values and retrieving/storing calibration or adaptation data.

## Inputs
The diagram receives various functional call triggers, system states, and feedback signals:

*   **`<fc_INI>`**: Functional Call for Initialization. A general trigger for initialization routines.
*   **`<fc_RST>`**: Functional Call for Reset. Specifically triggers the ECU Reset Initialization block.
*   **`<fc_ERU2ES>`**: Functional Call for Engine Run-Up (ERU) to Engine Stop (ES) or similar state transition.
*   **`<fc_NVMRES>`**: Functional Call for Non-Volatile Memory Reset.
*   **`<fc_NVMINI>`**: Functional Call for Non-Volatile Memory Initialization.
*   **`<fc_NVMSTO>`**: Functional Call for Non-Volatile Memory Store.
*   **`<CAM_FUEL_PUMP>`**: Input signal likely indicating the status or operation of the camshaft-driven fuel pump.
*   **`<ACTION_INFR_MfiDisable_T3>`**: An action or flag indicating an infrastructure disablement, possibly related to fuel injection (MFi).
*   **`<CTR_VCV_CLOSE_SL_AD>`**: Control signal for VCV (Valve Controlled Pump) closed-loop slip adaptation.
*   **`<R_VCV_CLOSE_SL_AD_ST>`**: NVM stored value for VCV close-loop slip adaptation start resistance.
*   **`<VB_VCV_CLOSE_SL_AD_ST>`**: NVM stored value for VCV close-loop slip adaptation start voltage.
*   **`<PWM_VCV_CLOSE_SL_AD_END>`**: NVM stored value for VCV close-loop slip adaptation end PWM.
*   **`<T_DUR_VCV_CLOSE_SL_AD_END>`**: NVM stored value for VCV close-loop slip adaptation end duration time.
*   **`<PWM_VCV_CTL_0_MIN>`**: NVM stored value for minimum PWM control for VCV.
*   **`<T_VCV_CLOSE_SL_AD_VLD>`**: NVM stored value for VCV close-loop slip adaptation validity time.

## Outputs
The system outputs a consolidated bus of initialized parameters and control values, named `ini`, which contains the following individual signals:

*   **`<T_VCV_MFP_START>`**: Time duration for VCV start phase, limited by calibration.
*   **`<ANG_REF_VCV>`**: Reference angle for the VCV.
*   **`<MFP_MAX>`**: Maximum mass flow rate achievable by the pump.
*   **`<MFP_REQ>`**: Required mass flow rate.
*   **`<MFP_OFS>`**: Mass flow rate offset.
*   **`<FAC_FUEL_PUMP_EFF_COR>`**: Correction factor for fuel pump efficiency.
*   **`<MFP_REG_CTL>`**: Mass flow rate regulation control.
*   **`<ANG_CUR_ON_VCV>`**: Current angle for VCV "on" state.
*   **`<PUMP_VOL_VCV>`**: Pump volume for VCV.
*   **`<MFP>`**: Mass flow rate.
*   **`<LV_INH_VCV>`**: Inhibit flag for VCV.
*   **`<VCV_CLOSE_RNG>`**: Close range for VCV.
*   **`<T_DLY_VCV_CLOSE_ADD>`**: Additional delay time for VCV closing.
*   **`<T_DUR_VCV_CTL_PEAK>`**: Duration time for VCV control peak.
*   **`<PWM_VCV_CTL_0>`**: PWM control value 0 for VCV.
*   **`<PWM_VCV_CTL_1>`**: PWM control value 1 for VCV.
*   **`<VCV_OPEN_ADD>`**: Additional opening for VCV.
*   **`<MFP_REQ_CTL>`**: Mass flow rate request control.
*   **`<LV_MFP_REQ_LOW>`**: Flag for low mass flow rate request.
*   **`<LV_TEMP>`**: Level for temperature.
*   **`<PUMP_NR>`**: Number of pumps in a multi-pump configuration.
*   **`<ANG_CUR_OFF_VCV>`**: Current angle for VCV "off" state.
*   **`<T_FUP_MIN_VCV_LOCK>`**: Minimum fuel pump lock time for VCV.
*   **`<T_VCV_ACR_ACT>`**: Time for VCV activation.
*   **`<LV_VCV_ACR_ACT>`**: Level for VCV activation.
*   **`<T_DUR_VCV_CTL_FW>`**: Duration time for VCV control forward.
*   **`<T_DUR_VCV_CTL_HOLD_0>`**: Duration time for VCV control hold 0.
*   **`<LV_VCV_STOP_REQ>`**: Level for VCV stop request.
*   **`clc_vcv_sl_ini`**: Close-loop control VCV slip initialization.
*   **`<STATE_VCV>`**: Current state of the VCV.
*   **`<CTR_FUP_DIF_VCV_CLOSE_SL_AUTH>`**: Control authorization for fuel pump differential VCV close slip.
*   **`<CTR_FUP_DIF_HYS_MAX_AUTH>`**: Control authorization for fuel pump differential hysteresis maximum.
*   **`<R_VCV_CLOSE_SL_AD_ST>`**: NVM stored value for VCV close-loop slip adaptation start resistance (output, possibly updated).
*   **`<VB_VCV_CLOSE_SL_AD_ST>`**: NVM stored value for VCV close-loop slip adaptation start voltage (output, possibly updated).
*   **`<PWM_VCV_CLOSE_SL_AD_END>`**: NVM stored value for VCV close-loop slip adaptation end PWM (output, possibly updated).
*   **`<T_DUR_VCV_CLOSE_SL_AD_END>`**: NVM stored value for VCV close-loop slip adaptation end duration time (output, possibly updated).
*   **`<PWM_VCV_CTL_0_MIN>`**: NVM stored value for minimum PWM control for VCV (output, possibly updated).
*   **`<CTR_VCV_CLOSE_SL_AD>`**: Control signal for VCV closed-loop slip adaptation (output, possibly updated).
*   **`<T_VCV_CLOSE_SL_AD_VLD>`**: NVM stored value for VCV close-loop slip adaptation validity time (output, possibly updated).

## Logic Flow
The diagram illustrates four primary functional blocks, each representing a specific stage or type of initialization, interconnected by control signals and data flow. All outputs converge into a `BusMerge` block, consolidating them into a single `ini` bus.

1.  **RST (X.1.1) - ECU Reset Initialization:**
    *   This block is activated by a general initialization call (`<fc_INI>`) and specifically a reset call (`<fc_RST>`).
    *   It takes inputs such as the fuel pump status (`<CAM_FUEL_PUMP>`) and a disable action flag (`<ACTION_INFR_MfiDisable_T3>`).
    *   Its core function, as indicated by the accompanying text, is to initialize all calculated variables at an ECU reset. This includes setting default or calibrated values for numerous VCV and fuel pump control parameters, such as start-up timings, reference angles, mass flow limits, pump volume, and initial PWM control values.

2.  **ERU2ES (X.1.2) - Engine Run-Up / Specific ECU State Initialization:**
    *   This block is triggered by `<fc_INI>` and a specific event call `<fc_ERU2ES>`, likely pertaining to engine run-up or transitions between engine states (e.g., Engine Run-Up to Engine Stop).
    *   It also takes `<CAM_FUEL_PUMP>` and VCV closed-loop adaptation control signals (`<CTR_VCV_CLOSE_SL_AD>`, `<CTR_FUP_DIF_VCV_CLOSE_SL_AUTH>`) as inputs.
    *   It calculates and outputs a subset of initialization parameters crucial for specific engine operating conditions, such as VCV state, pump volume, current mass flow, and authorization flags for fuel pump differential VCV control.

3.  **INI_RES_NVMY (X.1.3) - Non-Volatile Memory Initialization / Restoration:**
    *   This block is activated by `<fc_INI>`, `<fc_NVMRES>` (NVM Reset), and `<fc_NVMINI>` (NVM Initialization).
    *   It receives input signals representing previously stored VCV closed-loop adaptation and control values from NVM.
    *   Its purpose is to read, validate, and restore these persistent data points from non-volatile memory into active system memory upon initialization or an NVM reset event.

4.  **STO_NVMY (X.1.4) - Non-Volatile Memory Storage:**
    *   This block is triggered by `<fc_INI>` and specifically by `<fc_NVMSTO>` (NVM Store).
    *   It takes the current VCV closed-loop adaptation and control values as inputs, which are derived from the system's operational phase or updated during initialization.
    *   Its function is to prepare these critical values for persistent storage into non-volatile memory, ensuring they are retained across power cycles for future use (e.g., next engine start).

Finally, all the individual outputs from these four functional blocks are consolidated by the **BusMerge (V.6.6)** block into a single output bus named `ini`. This `ini` bus encapsulates the comprehensive set of initialization parameters, states, and NVM-related data for the fuel pressure actuator control, making them available to other parts of the automotive control system.


--- Page 194 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram represents a module for the "Fuel pressure actuator control" (FUSL), specifically focusing on the Volume Control Valve (VCV) of a fuel pump. Its primary function is to process various inputs (calibrations, sensor data, control signals) related to the VCV, perform calculations and state logic updates, and generate output signals that govern the VCV's operation, timing, and diagnostic status. The model likely plays a role in regulating fuel pressure by controlling the VCV's opening and closing states, including aspects like initialization, free-wheeling phase control, and diagnostic mode handling.

## Inputs
The key inputs to this system, identified by 'From' blocks (angled brackets `< >`) or direct source blocks, are:

*   **Calibration Parameters:**
    *   `C_T_VCV_MFP_START`: Calibration for VCV Mass Flow Parameter start time.
    *   `C_VCV_CLOSE_BAS`: Calibration for the base closing position/timing of the VCV.
    *   `C_T_MAX_FUP_MIN`: Calibration for maximum fuel pump minimum time.
    *   `C_T_DUR_VCV_CTL_FW`: Calibration for the duration of VCV control during the free-wheeling phase.
    *   `C_PUMP_NR`: Calibration for the pump number.
*   **Sensor/System Signals:**
    *   `<CAM_FUEL_PUMP>`: Signal related to the camshaft position for fuel pump synchronization.
    *   `<ANG_REF_VCV>`: Reference angle for VCV operation.
    *   `<MFP_MAX>`: Maximum Mass Fuel Parameter (e.g., maximum fuel flow).
    *   `<MFP_REQ>`: Requested Mass Fuel Parameter (e.g., requested fuel flow).
    *   `<MFP_OFS>`: Offset for the Mass Fuel Parameter.
    *   `<PWM_VCV_CTL_0>`: Pulse Width Modulation control signal for VCV, possibly for one phase.
    *   `<PWM_VCV_CTL_1>`: Pulse Width Modulation control signal for VCV, possibly for another phase.
    *   `<VCV_OPEN_ADD>`: Additional value for VCV opening.
    *   `<ANG_CUR_ON_VCV>`: Angle at which VCV current turns ON.
    *   `<ANG_CUR_OFF_VCV>`: Angle at which VCV current turns OFF.
    *   `<T_VCV_ACR_ACT>`: Actual time of VCV actuator.
    *   `<LV_VCV_ACR_ACT>`: Actual level/status of VCV actuator.
*   **Control/Diagnostic Signals:**
    *   `<ACTION_INFR_MflDisable_T3>`: Action infrastructure disable signal for a specific diagnostic (T3).
    *   `LC_VCV_DI_MOD`: Local VCV Diagnostic Mode selection.
*   **Internal Signals/Constants:**
    *   Various constant blocks with values `0`, `1`, `60` are used as direct inputs or flags within the logic.

## Outputs
The primary outputs of this module, typically represented by 'Goto' blocks (angled brackets `< >`) or direct connections leaving the main scope, are:

*   **VCV States and Parameters:**
    *   `<FAC_FUEL_PUMP_EFF_COR>`: Correction factor for fuel pump efficiency.
    *   `<STATE_VCV>`: Current operating state of the VCV.
    *   `<PUMP_VOL_VCV>`: Calculated volume for the pump controlled by VCV.
    *   `<MFP>`: Calculated Mass Fuel Parameter.
    *   `<LV_INH_VCV>`: Inhibition level/flag for VCV operation.
    *   `<VCV_CLOSE_RNG>`: Range for VCV closing.
    *   `<T_DLY_VCV_CLOSE_ADD>`: Additional delay time for VCV closing.
    *   `<T_DUR_VCV_CTL_PEAK>`: Duration of VCV control at peak.
    *   `<T_DUR_VCV_CTL_HOLD_0>`: Duration of VCV control during hold phase 0.
    *   `<MFP_REQ_CTL>`: Controlled requested Mass Fuel Parameter.
    *   `<LV_MFP_REQ_LOW>`: Low level for the requested Mass Fuel Parameter.
    *   `<LV_TEMP>`: Temperature level (likely internal to VCV control).
    *   `<PUMP_NR>`: Output pump number.
    *   `<LV_VCV_STOP_REQ>`: Level/flag for VCV stop request.
*   **VCV State Logic Signals (from `clc_vcv_sl_ini` block):**
    *   `<CTR_VCV_CLOSE_SL_AD>`: Counter for VCV Close State Logic Active/Deactive.
    *   `<CTR_FUP_DIF_VCV_CLOSE>`: Counter for fuel pump difference during VCV close.
    *   `<LV_VCV_CLOSE_AUTH>`: Authorization level for VCV closing.
    *   `<LV_VCV_SL_AD_AUTH>`: Authorization for VCV State Logic Active/Deactive.
    *   `<LV_VCV_SL_AD_RST>`: Reset signal for VCV State Logic Active/Deactive.
    *   `<LV_VCV_SL_AUTH>`: General authorization for VCV State Logic.
    *   `<VCV_OPEN_SL_AD>`: VCV open signal for State Logic Active/Deactive.
    *   `<LV_VCV_CLOSE_SL_AD>`: VCV close signal for State Logic Active/Deactive.
    *   `<LV_VCV_SL_AD_TMP>`: Temporary signal for VCV State Logic Active/Deactive.
    *   `<VCV_CLOSE_SL_AD>`: VCV close signal for State Logic Active/Deactive (potentially a different instance or derived).
    *   `<LV_VCV_CLOSE_SL>`: VCV close State Logic level.
    *   `<LV_VCV_DEACC_FW>`: Deactivation level for VCV during free-wheeling.
    *   `<LV_VCV_SL_AD_REQ>`: Request for VCV State Logic Active/Deactive.
    *   `<CTR_FUP_DIF_HYST>`: Counter for fuel pump difference hysteresis.
    *   `<LV_VCV_SL_AD_MAX_AUTH>`: Maximum authorization for VCV State Logic Active/Deactive.
    *   `<LV_VCV_SL_AD_WAIT>`: Wait signal for VCV State Logic Active/Deactive.
    *   `<LV_VCV_SL_AD_END>`: End signal for VCV State Logic Active/Deactive.
    *   `CLC_VCV_SL_CLOSE_INI`: A specific output from the state logic block.

## Logic Flow

1.  **Input Acquisition**: The diagram begins by receiving numerous input signals, which include calibration values (e.g., `C_T_VCV_MFP_START`, `C_VCV_CLOSE_BAS`), dynamic system parameters (e.g., `<CAM_FUEL_PUMP>`, `<MFP_REQ>`), and control/diagnostic flags (e.g., `LC_VCV_DI_MOD`). These are either directly connected or sourced from 'From' blocks, indicating they come from other parts of the larger system.

2.  **Initial Calculations & Signal Routing**:
    *   Several inputs are directly routed through to 'Goto' blocks on the right side, implying direct signal pass-through or a simple transformation (e.g., scaling, offset) not explicitly shown within the scope of these direct connections. For instance, `C_T_VCV_MFP_START` is assigned to `<FAC_FUEL_PUMP_EFF_COR>`.
    *   `C_VCV_CLOSE_BAS` and `<CAM_FUEL_PUMP>` are summed (V.7.7 block) to influence the `VCV_OPEN` signal.
    *   Constants (`0`, `1`, `60`) are introduced at various points to define default values or specific thresholds/states for subsequent processing.

3.  **Pump Control and Diagnostic Mode Handling**:
    *   A "fcn_call()" block (a subsystem or a defined function) processes `ACTION_INFR_MflDisable_T3`, `C_PUMP_NR`, and `LC_VCV_DI_MOD`. This block is responsible for generating `PRM_PUMP_NR`, `PRM_DIAGNOSIS_DISABLE_MODE`, and `ACTION_INFR_MflDisable`. This suggests it handles pump-specific configurations and controls diagnostic modes.

4.  **Conditional Execution (Implicit)**: An `if` block is present, fed by a constant `1` through a `cond_if` block. This setup suggests an unconditional execution of the 'if' branch, meaning the logic within that branch is always active under normal operating conditions. The output of this (unseen) `if` block, along with `VCV_OPEN` and `STATE_VCV` (and others), feeds into the main state logic block.

5.  **VCV State Logic and Initialization (`clc_vcv_sl_ini`)**:
    *   The core of the control logic is encapsulated within the large `clc_vcv_sl_ini` block. This block receives a comprehensive set of inputs:
        *   The processed pump parameters and diagnostic modes from the "fcn_call()" block.
        *   Key VCV parameters like `VCV_OPEN`, `STATE_VCV`, `MFP_REQ`, and free-wheeling duration `C_T_DUR_VCV_CTL_FW`.
        *   Various constant inputs.
    *   Given its name (`_sl_ini`), this block likely implements a state machine or complex logic to initialize, manage, and update the VCV's operational states, including control of its closing and opening sequences, authorization checks, and timing parameters. It generates numerous output signals detailing these internal states and control commands.

6.  **Output Generation**: All processed and calculated values, including the detailed VCV state logic outputs from `clc_vcv_sl_ini`, are then made available to other parts of the automotive control system through 'Goto' blocks. These outputs serve as inputs for further control actions, diagnostics, or monitoring of the fuel pressure actuation system.


--- Page 195 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink diagram is the **initialization of variables** associated with the "VCV soft landing" feature in a fuel pressure actuator control system (FUSL). Additionally, it computes and outputs a flag indicating the **completion status of the adaptation process** for this VCV soft landing feature based on a counter's value relative to calibrated thresholds at initialization.

## Inputs
The diagram's primary role is initialization, so many outputs are directly assigned constant values. However, for the adaptation completion logic, there are specific inputs:

*   **`CTR_VCV_CLOSE_SL_AD`**: This is a counter related to the VCV soft landing adaptation process.
*   **`C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR`**: A calibrated maximum counter value threshold for the Time Duration (T_DUR) adaptation of VCV soft landing.
*   **`C_CTR_MAX_VCV_CLOSE_SL_AD_PWM`**: A calibrated maximum counter value threshold for the Pulse Width Modulation (PWM) adaptation of VCV soft landing.

## Outputs
The outputs are the initialized values of various VCV soft landing related variables, and a boolean flag indicating adaptation completion:

*   **`<T_DEACC_ON_VCV>`**: Initialized to 0.
*   **`<T_DEACC_OFF_VCV>`**: Initialized to 0.
*   **`<PWM_VCV_CTL_DEACC>`**: Initialized to 0.
*   **`<LV_VCV_CLOSE_SL_AD_AUTH>`**: Initialized to 0.
*   **`<LV_VCV_CLOSE_SL_AD_RST>`**: Initialized to 0.
*   **`<LV_VCV_CLOSE_SL_AD_REQ>`**: Initialized to 0.
*   **`<LV_VCV_CLOSE_SL_AUTH>`**: Initialized to 0.
*   **`<LV_VCV_OPEN_SL_AUTH>`**: Initialized to 0.
*   **`<PWM_VCV_CLOSE_SL_AD>`**: Initialized to 0.
*   **`<PWM_VCV_CLOSE_SL_AD_TMP>`**: Initialized to 0.
*   **`<T_DUR_VCV_CLOSE_SL_AD>`**: Initialized to 0.
*   **`<STATE_VCV_CLOSE_SL>`**: Initialized to "OFF" (likely an enumeration or state value).
*   **`<T_DUR_VCV_DEACC_FW>`**: Initialized to 0.
*   **`<CTR_FUP_DIF_VCV_CLOSE_SL_AUTH>`**: Initialized to 0.
*   **`<CTR_FUP_DIF_HYS_MAX_AUTH>`**: Initialized to 0.
*   **`<LV_VCV_CLOSE_SL_AD_WAIT>`**: Initialized to 0.
*   **`<LV_VCV_CLOSE_SL_AD_END>`**: A boolean flag indicating if the VCV soft landing adaptation is considered complete.

## Logic Flow

The logical flow can be described in two main parts:

1.  **Direct Variable Initialization (Top Section):**
    *   A series of "Data Store Write" blocks (the blue blocks with `<>`) are used to initialize various variables related to the VCV soft landing feature.
    *   Most of these variables are initialized to a constant value of `0`.
    *   One specific variable, `<STATE_VCV_CLOSE_SL>`, is initialized to the string literal `OFF`.
    *   This part of the diagram simply sets these variables to their default or reset values upon system initialization.

2.  **Adaptation Completion Flag Calculation (Bottom Section):**
    *   The `CTR_VCV_CLOSE_SL_AD` (VCV Close Soft Landing Adaptation Counter) is taken as an input.
    *   Two calibrated maximum counter thresholds, `C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR` (for Time Duration adaptation) and `C_CTR_MAX_VCV_CLOSE_SL_AD_PWM` (for PWM adaptation), are also provided as inputs.
    *   These two thresholds are fed into a 'max' block. This block outputs the numerically larger of the two input thresholds.
    *   The output from the 'max' block (which represents the higher of the two adaptation thresholds) is then compared against the `CTR_VCV_CLOSE_SL_AD` using a "greater than or equal to" (`>=`) relational operator.
    *   The boolean result of this comparison (`true` if `CTR_VCV_CLOSE_SL_AD` is greater than or equal to the maximum threshold, `false` otherwise) is then written to the output variable `<LV_VCV_CLOSE_SL_AD_END>`. This flag signals whether the VCV soft landing adaptation has met its completion criteria at this point in the system's execution.


--- Page 196 ---

This page contains a Simulink-style block diagram.

---

## Function
This Simulink diagram's primary function is to initialize specific control parameters and states related to the Fuel Pressure Actuator Control (FUSL) system during the transition phase from an "Engine Run" state to an "Engine Stop" state. It sets default or predefined values for various components, particularly the Volume Control Valve (VCV) and fuel pump related counters, to ensure a controlled shutdown or prepare for the next engine start cycle.

## Inputs
1.  **<CAM_FUEL_PUMP>**: A signal indicating the status or command of the camshaft-driven fuel pump.
2.  **C_VCV_CLOSE_BAS**: A constant or parameter representing the base value for closing the VCV.
3.  **VCV_OPEN**: A signal indicating whether the VCV is commanded to be open.
4.  **STATE_VCV**: An input signal representing the current state of the VCV (before initialization takes effect on the output).
5.  **C_T_VCV_MFP_START**: A constant or parameter defining the starting point for the VCV's mass flow rate.
6.  **Internal Constants**: Explicit constant values `0` and `1` are used within the diagram as inputs to certain outputs.

## Outputs
1.  **<ANG_REF_VCV>**: The initialized angle reference for the Volume Control Valve (VCV).
2.  **<STATE_VCV>**: The initialized state of the VCV.
3.  **<PUMP_VOL_VCV>**: The initialized pump volume value associated with the VCV.
4.  **<MFP>**: The initialized Mass Flow Parameter.
5.  **<LV_INH_VCV>**: The initialized Low Voltage Inhibit status for the VCV.
6.  **<VCV_CLOSE_RNG>**: The initialized close range value for the VCV.
7.  **<T_VCV_MFP_START>**: The initialized starting point for the VCV's mass flow rate.
8.  **<CTR_FUP_DIF_VCV_CLOSE_SL_AUTH>**: The initialized counter for Fuel Pump Differential VCV Close Slide Authority.
9.  **<CTR_FUP_DIF_HYS_MAX_AUTH>**: The initialized counter for Fuel Pump Differential Hysteresis Maximum Authority.

## Logic Flow

The diagram processes several input signals and constants to produce initialized output values:

1.  **<ANG_REF_VCV> Calculation**:
    *   An unnamed function block `f()` outputs a value.
    *   The signal `<CAM_FUEL_PUMP>` and the constant `C_VCV_CLOSE_BAS` are fed into an adder block (`+`).
    *   The output of the `f()` block and the output of the adder block are then combined (likely another sum, though only one "+" block is explicitly shown, implying an aggregation of inputs) to determine the value for `<ANG_REF_VCV>`. This suggests the angle reference is a function of a baseline, fuel pump status, and a calculated component.

2.  **<STATE_VCV> Initialization**:
    *   The input signal `VCV_OPEN` is directly assigned as the output value for `<STATE_VCV>`. This means the VCV's state is set to its open command during initialization.

3.  **<PUMP_VOL_VCV> Initialization**:
    *   A constant value of `0` is assigned directly to `<PUMP_VOL_VCV>`. This resets the VCV pump volume.

4.  **<MFP> Initialization**:
    *   A constant value of `0` is assigned directly to `<MFP>`. This resets the Mass Flow Parameter.

5.  **<LV_INH_VCV> Initialization**:
    *   A constant value of `1` is assigned directly to `<LV_INH_VCV>`. This likely enables or activates a low voltage inhibit function for the VCV.

6.  **<VCV_CLOSE_RNG> Initialization**:
    *   A constant value of `0` is assigned directly to `<VCV_CLOSE_RNG>`. This resets the VCV close range.

7.  **<T_VCV_MFP_START> Initialization**:
    *   The input constant/parameter `C_T_VCV_MFP_START` is directly assigned as the output value for `<T_VCV_MFP_START>`. This initializes the VCV's mass flow start point to a predefined constant.

8.  **<CTR_FUP_DIF_VCV_CLOSE_SL_AUTH> Initialization**:
    *   A constant value of `0` is assigned directly to `<CTR_FUP_DIF_VCV_CLOSE_SL_AUTH>`. This resets a specific counter related to VCV authority.

9.  **<CTR_FUP_DIF_HYS_MAX_AUTH> Initialization**:
    *   A constant value of `0` is assigned directly to `<CTR_FUP_DIF_HYS_MAX_AUTH>`. This resets another counter related to hysteresis authority.

In essence, the diagram shows a series of direct assignments and a simple calculation to establish the initial conditions for several fuel pressure control variables when the engine transitions from running to stopped. Most counters and certain state variables are reset to zero or a default "inactive/enabled" state (like 1 for inhibit).


--- Page 197 ---

This page contains a Simulink-like diagram, likely representing a functional block within an automotive control system, specifically for fuel pressure actuator control.

## Function

The primary function of this diagram is to **initialize and/or read Non-Volatile Memory (NVM) variables** that are critical for the "Fuel pressure actuator control" (FUSL) system. It ensures that these persistent variables, which retain their values across power cycles, are correctly loaded when the system starts up or are reset/initialized to a default state if no valid NVM data exists. This process is crucial for maintaining system state and calibration parameters.

## Inputs

There are no explicit external input ports shown in this specific diagram. The "inputs" are implicitly the data stored in the Non-Volatile Memory (NVM) for each of the listed variables. The `NVMY[read/init]` blocks are responsible for accessing and retrieving this data.

## Outputs

The diagram outputs the values of seven NVM variables after they have been read or initialized. These outputs are:

*   `<R_VCV_CLOSE_SL_AD_ST>` (R_VCV_CLOSE_SL_AD_ST)
*   `<VB_VCV_CLOSE_SL_AD_ST>` (VB_VCV_CLOSE_SL_AD_ST)
*   `<PWM_VCV_CLOSE_SL_AD_END>` (PWM_VCV_CLOSE_SL_AD_END)
*   `<T_DUR_VCV_CLOSE_SL_AD_END>` (T_DUR_VCV_CLOSE_SL_AD_END)
*   `<PWM_VCV_CTL_0_MIN>` (PWM_VCV_CTL_0_MIN)
*   `<CTR_VCV_CLOSE_SL_AD>` (CTR_VCV_CLOSE_SL_AD)
*   `<T_VCV_CLOSE_SL_AD_VLD>` (T_VCV_CLOSE_SL_AD_VLD)

## Logic Flow

The logical flow within this functional block `f()` is straightforward and consists of parallel operations for each NVM variable:

1.  **Function Call / Execution Trigger:** The entire process is initiated when the `f()` function block is executed, likely during system startup or a specific reset event.

2.  **NVM Variable Access (Read/Initialize):** For each persistent variable listed (e.g., `R_VCV_CLOSE_SL_AD_ST`, `VB_VCV_CLOSE_SL_AD_ST`, etc.), a dedicated `NVMY[read/init]` block is invoked.
    *   This block first attempts to **read** the current value of the associated variable from the Non-Volatile Memory.
    *   If the read operation is successful and the retrieved data is valid (e.g., checksum correct, within expected range), then this stored value is used.
    *   If the NVM read fails (e.g., memory corruption), or if no valid data for the variable exists (e.g., first system boot, NVM reset), the block will **initialize** the variable to its predefined default value. The diagram specifies `init: 0` for all variables, which likely refers to a configured initial value in the NVM driver or definition, not necessarily a literal zero value in all cases. The `size: 1` indicates each variable is a scalar.

3.  **Output Assignment:** The value obtained from each `NVMY[read/init]` block (either read from NVM or initialized to its default) is then assigned to its corresponding output port, identified by the blue rounded rectangular blocks.

4.  **Parallel Operation:** All these read/initialize and output assignment operations occur in parallel or sequentially as part of the `f()` function's execution, ensuring all specified NVM variables are ready for use by downstream components of the fuel pressure actuator control system.


--- Page 198 ---

This page contains a Simulink-like diagram, likely representing a part of an automotive control system developed in an environment like Simulink, TargetLink, or a similar model-based design tool.

## Function

The primary function of this diagram is to manage the persistent storage of critical variables related to a "Fuel pressure actuator control" system (FUSL), specifically concerning the Volume Control Valve (VCV). It achieves this by writing the current values of these variables into Non-Volatile Memory (NVM) and making the persistently stored values available for retrieval. This ensures that these values are retained across power cycles of the Electronic Control Unit (ECU) or the vehicle.

## Inputs

The diagram takes seven distinct input signals, which represent the current, instantaneous values of the variables to be stored:

1.  `<R_VCV_CLOSE_SL_AD_ST>`: A status or state variable related to the VCV closing and slip/adaptation.
2.  `<VB_VCV_CLOSE_SL_AD_ST>`: Another status/state variable, possibly a "Voltage Back" or similar, related to VCV closing and adaptation.
3.  `<PWM_VCV_CLOSE_SL_AD_END>`: A Pulse Width Modulation (PWM) value indicating the end of a VCV closing/adaptation sequence.
4.  `<T_DUR_VCV_CLOSE_SL_AD_END>`: A time duration value indicating the end of a VCV closing/adaptation sequence.
5.  `<PWM_VCV_CTL_0_MIN>`: A minimum PWM control value for the VCV.
6.  `<CTR_VCV_CLOSE_SL_AD>`: A counter value related to VCV closing and adaptation.
7.  `<T_VCV_CLOSE_SL_AD_VLD>`: A flag or value indicating the validity of the VCV closing/adaptation time.

All input signals are scalars (`size: 1`) and have an initial value of `0` (`init:0`).

## Outputs

The diagram produces seven distinct output signals, corresponding to the values retrieved from Non-Volatile Memory for each of the stored variables:

1.  `<R_VCV_CLOSE_SL_AD_ST>`: The NVM-stored value of R_VCV_CLOSE_SL_AD_ST.
2.  `<VB_VCV_CLOSE_SL_AD_ST>`: The NVM-stored value of VB_VCV_CLOSE_SL_AD_ST.
3.  `<PWM_VCV_CLOSE_SL_AD_END>`: The NVM-stored value of PWM_VCV_CLOSE_SL_AD_END.
4.  `<T_DUR_VCV_CLOSE_SL_AD_END>`: The NVM-stored value of T_DUR_VCV_CLOSE_SL_AD_END.
5.  `<PWM_VCV_CTL_0_MIN>`: The NVM-stored value of PWM_VCV_CTL_0_MIN.
6.  `<CTR_VCV_CLOSE_SL_AD>`: The NVM-stored value of CTR_VCV_CLOSE_SL_AD.
7.  `<T_VCV_CLOSE_SL_AD_VLD>`: The NVM-stored value of T_VCV_CLOSE_SL_AD_VLD.

The output signal names are identical to their corresponding input signal names, indicating that they represent the persistent state of those variables.

## Logic Flow

The logical flow is straightforward and occurs in parallel for each variable:

1.  **Input Acquisition:** The system continuously generates or updates the seven input variables, which represent the current operational state or desired parameters of the Fuel pressure actuator control.
2.  **NVM Storage Block Entry:** Each of these current values is fed into the `in` port of a dedicated `NVMY[store]` block. The `NVMY` prefix strongly suggests a Non-Volatile Memory management function, and `[store]` indicates its primary role is to persist data.
3.  **Persistent Storage Operation:** Internally, each `NVMY[store]` block performs the necessary operations to save the received `in` value into a specific segment of the ECU's non-volatile memory. This operation typically involves:
    *   **Data Validation:** Checking if the incoming data is valid for storage.
    *   **Wear Leveling/Error Correction:** Managing the physical NVM to prolong its life and ensure data integrity.
    *   **Write Scheduling:** Deciding when to actually write the data to NVM (e.g., periodically, on change, on shutdown, or based on specific system events like "power latch phase" mentioned in the "Calculation Sequence" text).
    *   **Default Value Handling:** If no valid data is found in NVM (e.g., on first boot or due to corruption), the block would typically initialize the stored value to the `init:0` specified, or another defined default.
4.  **Output Retrieval:** The `out` port of each `NVMY[store]` block provides the value currently considered as the "stored" value for that variable. This value is typically the last value successfully written to NVM, or the default `init:0` value if NVM is not yet initialized or valid data cannot be read. This read-back mechanism ensures that other parts of the control software can access the persistently stored state of these parameters.
5.  **Parallel Processing:** All seven variables are processed independently and in parallel through their respective `NVMY[store]` blocks. This structure is common for managing multiple distinct NVM parameters.

The "Calculation Sequence" text below the diagram indicates that the overall system might be triggered every 10ms, suggesting that these NVM storage operations (or at least the acquisition of inputs) also occur on a periodic basis in the real-time embedded environment.


--- Page 199 ---

This page contains a Simulink-like diagram, likely representing a control algorithm for an automotive system.

## Function

The primary function of this Simulink diagram, titled "FUSL, Fuel pressure actuator control," is to determine and manage the operational modes (OPM) of a fuel pressure actuator (likely a VCV, or Valve Control Valve, as suggested by the accompanying text). It calculates different operational modes at various execution rates (10ms, segmented 10ms, and 1s) based on the ECU's state, system conditions, and specific enable flags. These individual mode calculations are then combined into a single output bus. The diagram explicitly addresses conditions for inhibition and manual activation of the VCV operation.

## Inputs

The key inputs to this system are:

1.  **ECU_STATE:** The current state of the Engine Control Unit, used for comparison.
2.  **SYN_ENG_IGK_ON:** A boolean signal indicating the engine ignition is turning on.
3.  **SYN_ENG_IGK_OFF:** A boolean signal indicating the engine ignition is turning off.
4.  **LV_ST_END:** A boolean flag indicating the end of a system start-up sequence.
5.  **LC_CUR_VCV_MAN_ACT:** A calibration or input signal for manual activation of the VCV.
6.  **LV_FUP_LIH_DPS_DI:** A digital input signal, likely related to fuel pump (FUP) or pressure sensor (DPS) inhibition (LIH).
7.  **fc_OPM_10MS:** A condition or enable flag specifically for the 10ms operational mode.
8.  **fc_OPM_SEG:** A condition or enable flag for the segmented operational mode.
9.  **fc_OPM_1S:** A condition or enable flag for the 1-second operational mode.
10. **<input> (to OPM_SEG_10MS):** A generic input signal to the segmented operational mode sub-system.
11. **<feedback> (to OPM_SEG_10MS, OPM_10MS, OPM_1S):** Generic feedback signals, likely representing the current output or state of the respective operational mode blocks, used for recurrence or state management.

## Outputs

The primary output of this system is:

1.  **opm:** A bus signal containing the merged operational mode outputs: `opm_seg_10ms`, `opm_10ms`, and `opm_1s`.

Intermediate outputs/flags generated within the diagram:

*   **fc_10ms_1:** A conditional flag or enable for the OPM_10MS block.
*   **fc_10ms_2:** A conditional flag or enable, likely for an alternative 10ms processing path.
*   **fc_seg_10ms:** A conditional flag or enable for the OPM_SEG_10MS block.
*   **opm_seg_10ms:** The output of the segmented 10ms operational mode sub-system.
*   **opm_10ms:** The output of the general 10ms operational mode sub-system.
*   **opm_1s:** The output of the 1-second operational mode sub-system.

## Logic Flow

The logical flow can be broken down into three main parts: conditioning logic, operational mode calculation sub-systems, and output consolidation.

1.  **Conditioning Logic for `fc_10ms_1` (Top Path):**
    *   The `ECU_STATE` is compared against `SYN_ENG_IGK_ON` and `SYN_ENG_IGK_OFF` using two equality blocks (V.6.6).
    *   The boolean results of these two comparisons are combined by an `OR` gate (V.6.7). This results in a true signal if the ECU is in an ignition-on or ignition-off transition state.
    *   This OR gate's output, along with `fc_OPM_10MS`, feeds into a conditional block (V.6.5, which resembles a `cond_if` or `Switch`). The output `fc_10ms_1` is generated based on these inputs, likely enabling or triggering the `OPM_10MS` sub-system under specific conditions related to `fc_OPM_10MS` and the ECU's ignition state. Output `[fc_10ms_2]` is also indicated but its direct use from this block isn't explicitly shown connected to a block input other than the second `cond_if` block.

2.  **Conditioning Logic for `fc_seg_10ms` and `fc_10ms_2` (Middle Path):**
    *   The output of the initial `OR` gate (from ECU state comparisons) is inverted by a `NOT` gate (V.6.8). This condition is true if the ECU is NOT in an ignition-on or ignition-off transition.
    *   The `LV_ST_END` signal is also inverted by a `NOT` gate.
    *   These two NOTed signals are then combined by an `AND` gate (V.6.10). This implies a condition where the ECU is stable (not transitioning ignition) AND the start-up sequence has not ended.
    *   The `LC_CUR_VCV_MAN_ACT` signal is inverted by a `NOT` gate.
    *   The output of the previous `AND` gate and the NOTed `LC_CUR_VCV_MAN_ACT` are combined by an `OR` gate (V.6.7). This sets a condition where either (ECU is stable and start-up is not ended) OR (VCV manual activation is NOT active).
    *   This final OR gate's output, along with `fc_OPM_SEG`, feeds into another conditional block (V.6.4, labeled `cond_if`). This block generates `fc_seg_10ms` and `fc_10ms_2`, acting as enable/trigger signals for the segmented 10ms operational mode and potentially a second 10ms mode or an alternative path.

3.  **Operational Mode (OPM) Calculation Sub-systems:**
    *   **OPM_SEG_10MS (X.2.1):** This sub-system receives `fc_seg_10ms` (its trigger/enable), generic `<input>`, `<feedback>`, `ECU_STATE`, and `LV_FUP_LIH_DPS_DI`. It processes these inputs to calculate `opm_seg_10ms`, which represents a specific, segmented operational mode, likely incorporating inhibition logic related to `LV_FUP_LIH_DPS_DI` as mentioned in the accompanying text.
    *   **OPM_10MS (X.2.2):** This sub-system receives `fc_10ms_1` (its trigger/enable) and `<feedback>`. It calculates `opm_10ms`, a general operational mode updated at a 10ms rate.
    *   **OPM_1S (X.2.3):** This sub-system receives `fc_OPM_1S` (its trigger/enable) and `<feedback>`. It calculates `opm_1s`, an operational mode updated at a 1-second rate.

4.  **Output Consolidation:**
    *   The three distinct operational mode outputs (`opm_seg_10ms`, `opm_10ms`, `opm_1s`) are then grouped together into a single bus signal named `opm` using a `BusMerge` block (V.6.6). This `opm` bus represents the combined output of the fuel pressure actuator control logic.


--- Page 200 ---

This diagram is a model-based design representation, highly characteristic of Simulink or similar automotive development tools (like TargetLink or ASCET), used for "FUSL, Fuel pressure actuator control." It illustrates the logic for selecting and generating control commands for fuel pressure actuators, likely the Volume Control Valve (VCV) and High-Pressure Pump (HPP).

## Function

The primary function of this Simulink diagram is to determine the active control strategy for fuel pressure actuators and to output a merged bus of relevant control values. It implements a hierarchical selection logic that prioritizes manual control, followed by normal high-pressure pump control under specific operating conditions, and defaults to a VCV actuator test mode if other conditions are not met. Concurrently, it calculates the values for each potential control strategy, making both the active and inactive calculated values available in a single output bus for further processing or diagnostics.

## Inputs

The key inputs to this system are:

1.  **`LC_CUR_VCV_MAN_ACT`**: A boolean signal indicating a request for manual activation of the VCV current control.
2.  **`<ECU_STATE>`**: An enumeration or value representing the current state of the Engine Control Unit (ECU).
3.  **`ENG_STOP`**: A specific state or condition related to the engine stopping.
4.  **`PWL`**: A boolean signal indicating if Power Limitation is active.
5.  **`ENG_LOCK`**: A specific state or condition related to the engine being locked.
6.  **`LV_FUP_LIH_DPS_DI`**: A boolean signal indicating a fuel pressure limitation due to internal system diagnostics or integrity monitoring.
7.  **`LC_ENA_VCV_LIH`**: A boolean signal enabling VCV control for a specific internal function or mode (LIH).
8.  **`<input>` (multiple instances)**: Generic input signals for the functional blocks `CLC_CUR_VCV_MAN_ACT`, `CLC_HPP_CTL`, and `CLC_VCV_ACR_TEST`. These would represent specific sensor readings, desired setpoints, or other control parameters.
9.  **`<feedback>` (multiple instances)**: Generic feedback signals for the functional blocks `CLC_CUR_VCV_MAN_ACT`, `CLC_HPP_CTL`, and `CLC_VCV_ACR_TEST`. These would typically be measured actuator positions, pressures, or currents used for closed-loop control.

## Outputs

The main output of this system is:

1.  **`opm_seg_10ms`**: A bus signal that merges various control values. It likely contains the currently active control command (selected by the conditional logic) along with the independently calculated control commands from all functional blocks. The `_10ms` suffix suggests this bus is updated every 10 milliseconds.

## Logic Flow

The logical flow can be broken down into three main stages: control strategy selection, individual control value calculation, and output merging.

### 1. Control Strategy Selection

This top section determines which control command is active based on system states and requests:

*   **Manual VCV Activation Check:**
    *   The signal `LC_CUR_VCV_MAN_ACT` serves as the primary condition for the first "cond_if" block (V.6.4).
    *   **IF `LC_CUR_VCV_MAN_ACT` is TRUE:** The selection logic chooses the control command designated `fc_cur_vcv_man_act`. This path implies a manual override or specific mode for VCV current control.
    *   **ELSE (if `LC_CUR_VCV_MAN_ACT` is FALSE):** The logic proceeds to evaluate general control readiness.

*   **General Control Readiness Evaluation:**
    *   Two "not equal" (`!=`) blocks (V.6.6) check if the `<ECU_STATE>` is neither `ENG_STOP` nor `ENG_LOCK`. Both conditions must be true for readiness.
    *   Two "NOT" gates (V.6.8) invert `PWL` (Power Limitation) and `LV_FUP_LIH_DPS_DI` (Fuel Pressure Limitation).
    *   An "OR" gate (V.6.7) combines these inverted signals. This means if there is NO power limitation OR NO fuel pressure limitation, this part of the condition is met.
    *   An "AND" gate (V.6.10) combines the results from `(ECU_STATE != ENG_STOP)`, `(ECU_STATE != ENG_LOCK)`, the `OR` gate's output, and the `LC_ENA_VCV_LIH` signal. The output of this `AND` gate is the "Control Enable" condition for the HPP.
    *   This "Control Enable" condition is then used as the condition for the second "cond_if" block (V.6.4), which is nested within the 'else' branch of the first "cond_if".

*   **HPP Control / VCV ACR Test Selection:**
    *   **IF "Control Enable" is TRUE (from the `AND` gate):** The selection logic chooses the control command designated `fc_hpp_ctl`. This represents the normal high-pressure pump control.
    *   **ELSE (if "Control Enable" is FALSE):** The selection logic chooses the control command designated `fc_vcv_acr_test`. This serves as a fallback or test mode for the VCV actuator.

The outputs of these "cond_if" blocks (indicated by dashed lines) represent the currently *active* control command based on the established priority.

### 2. Individual Control Value Calculation

Three independent functional blocks continuously calculate their respective control values:

*   **`CLC_CUR_VCV_MAN_ACT` (X.2.1.1):** This block calculates `fc_cur_vcv_man_act`, which is the control value for manual VCV current actuation. It likely contains an internal control algorithm (denoted by `f()`) using generic `<input>` and `<feedback>` signals.
*   **`CLC_HPP_CTL` (X.2.1.2):** This block calculates `fc_hpp_ctl`, the control value for the high-pressure pump. It also uses an internal algorithm (`f()`) with generic `<input>` and `<feedback>` signals.
*   **`CLC_VCV_ACR_TEST` (X.2.1.3):** This block calculates `fc_vcv_acr_test`, the control value for the VCV actuator control request test mode. It similarly uses an internal algorithm (`f()`) with generic `<input>` and `<feedback>` signals.

### 3. Output Merging

*   The `BusMerge` block (V.6.6) acts as a combiner, collecting various signals into a single bus named `opm_seg_10ms`.
*   The inputs to the `BusMerge` include:
    *   The *selected active control command* from the conditional logic (the output of the `cond_if` blocks, carried by the dashed lines).
    *   The *raw calculated control values* from each of the `CLC_` functional blocks (`fc_cur_vcv_man_act`, `fc_hpp_ctl`, and `fc_vcv_acr_test`, carried by the solid lines).
*   This output bus `opm_seg_10ms` therefore provides both the command currently controlling the actuator and the potential commands that *would* be active if other conditions were met. This is beneficial for diagnostics, monitoring, and potentially for other downstream functions that might need to know the state of all control strategies.


--- Page 201 ---

This page does contain a Simulink-style diagram.

## Function

This Simulink diagram, titled "Manual setting of VCV current control parameters via application tool (overview)," describes a system responsible for configuring and managing the current control parameters for a VCV (likely a Volume Control Valve in a fuel pressure actuator control system, as indicated by "FUSL, Fuel pressure actuator control"). Its primary function is to allow an external application tool (or higher-level logic) to manually set, modify, and activate various VCV current control parameters, modes, and test conditions. This includes defining specific pulse phases (e.g., PEAK, CTL_0, DEACC) and controlling whether they operate in open-loop or closed-loop mode, as well as enabling specific test modes.

## Inputs

The system receives a comprehensive set of inputs, primarily categorized into VCV PWM control parameters, diagnostic information, application tool commands, and ECU/system state:

*   **VCV PWM Control Parameters:** These define the specific current values or characteristics for different phases of the VCV control pulse.
    *   `<PWM_VCV_OPL_CTL_MAX>`: Maximum current for open-loop control.
    *   `PWM_VCV_CTL_PEAK`: Peak current for the control pulse.
    *   `PWM_VCV_CTL_0`: Control current for phase 0 (e.g., pick-up/hold_0).
    *   `PWM_VCV_CTL_1`: Control current for phase 1 (e.g., hold_1).
    *   `PWM_VCV_DEACC_PEAK`: Peak current during deactivation.
    *   `PWM_VCV_CTL_DEACC`: Deactivation current (hold).
    *   `PWM_VCV_CTL_PEAK_ST`: Peak current for the start phase.
    *   `PWM_VCV_CTL_ST`: Start current.
*   **Diagnostic Input:**
    *   `<LV_VCV_DI>`: Low Voltage VCV Diagnostic Input, likely a status flag or indicator.
*   **Application Tool Actions/Instructions (from `CLC_INFR_IF` block):** These are discrete commands from the application tool.
    *   `<ACTION_INFR_SetCurCtlModeVcv_T3>`: Command to set the current control mode for VCV.
    *   `<ACTION_INFR_MflUpdate_T3>`: Command to update a specific "Mfl" (possibly "Measurement Flow" or a specific internal flag/status).
    *   `<ACTION_INFR_MflStart_T3>`: Command to start the "Mfl" process.
    *   `<ACTION_INFR_MflSetVcvCtlPls_T3>`: Command to set VCV control pulse parameters.
    *   `<ACTION_INFR_MflSetVcvDeaccPls_T3>`: Command to set VCV deactivation pulse parameters.
    *   `<ACTION_INFR_MflEnable_T3>`: Command to enable the "Mfl" functionality.
    *   `<ACTION_INFR_MflDisable_T3>`: Command to disable the "Mfl" functionality.
*   **ECU and System State:**
    *   `<ECU_STATE>`: Current operational state of the Electronic Control Unit.
    *   `<LV_SYN_ENG_VCV_CTL>`: Low Voltage Synchronization for Engine VCV Control, possibly indicating a synchronized state or command.
*   **Generic/Bus Inputs (to `CLC_INFR_IF` block):**
    *   `<input>`: A generic input bus, likely carrying various system conditions or parameters.
    *   `<feedback>`: A generic feedback bus, potentially used for closed-loop control or status monitoring.

## Outputs

The system produces a single primary output:

*   `clc_cur_vcv_man_act`: This signal represents the consolidated set of manually activated or configured VCV current control parameters and states, typically provided as a bus or structure to other parts of the control system.

## Logic Flow

The logical flow of the system involves two main processing stages (`CLC_PWM_VCV` and `CLC_INFR_IF`) that converge into a merged output:

1.  **VCV PWM Control Parameter Generation/Validation (`CLC_PWM_VCV` block):**
    *   This subsystem receives all the specific current control parameters for the various VCV pulse phases (PEAK, CTL_0, CTL_1, DEACC_PEAK, DEACC, ST, PEAK_ST, OPL_CTL_MAX). These parameters dictate the precise current profile for the VCV actuator.
    *   It also takes the `<LV_VCV_DI>` diagnostic input, which might influence or gate the parameter processing (e.g., if there's a low voltage condition, parameters might be adjusted or clamped).
    *   The block likely performs validation, scaling, or interpolation of these raw input parameters based on the current control mode (open-loop/closed-loop) and current control phase, as described in the accompanying text.
    *   Its output, `<STATE_VCV>`, represents the calculated or selected VCV state and current parameters based on its inputs. This output is then fed into the `BusMerge` block.

2.  **Infrastructure Interface and Command Handling (`CLC_INFR_IF` block):**
    *   This subsystem acts as an interface for higher-level commands and system states. It receives a variety of `ACTION_INFR_...` signals, which are explicit triggers or commands from the application tool. These commands allow dynamic control over setting modes, updating, starting, enabling, or disabling specific VCV control aspects, including test modes.
    *   It processes `ECU_STATE` and `LV_SYN_ENG_VCV_CTL` to ensure that commands are executed in the appropriate system context.
    *   The generic `<input>` and `<feedback>` ports suggest it can also incorporate other system conditions or feedback for its decision-making.
    *   This block processes these commands and states to determine the active control mode, test mode, and other configurational settings that affect the VCV current control. The output of this block (implicitly connected to `BusMerge V.6.6`) represents the result of these commands, likely an active configuration or status related to the VCV control.

3.  **Output Merging (`BusMerge` blocks V.6.8 and V.6.6):**
    *   The `<STATE_VCV>` signal (from `CLC_PWM_VCV`) and the output from `CLC_INFR_IF` are directed to `BusMerge` blocks (labeled V.6.8 and V.6.6, suggesting possible internal merging steps or hierarchical bus structures).
    *   These `BusMerge` blocks combine the various, potentially disparate, signals and structures from the two main processing units into a single, cohesive bus.
    *   The final output of this merged bus is `clc_cur_vcv_man_act`, which is then available to other parts of the overall fuel pressure actuator control system to command the VCV. This output encapsulates all the manually set and activated current control information.


--- Page 202 ---

This page does contain a Simulink diagram.

## Function
This Simulink diagram is designed for **Fuel Pressure Actuator (VCV - Volume Control Valve) control**. Its primary function is to calculate and output Pulse Width Modulation (PWM) duty cycle set points for different phases of VCV operation. It also determines if the VCV actuation should be disabled based on specific control mode and parameter conditions. Essentially, it converts desired current set points into appropriate PWM signals, with an override capability for direct PWM settings, and includes safety/test disable logic.

## Inputs
The diagram receives the following key inputs:

*   **`C_CUR_VCV_OPL_CTL_MAX`**: A constant or parameter representing the maximum operating current control for the VCV.
*   **`x_val`**: An independent variable used as input to the 1D lookup table for PWM conversion.
*   **`CLF_CUR_CTL_MOD_VCV`**: A control flag or mode selection for VCV current control.
*   **`CLF_CUR_CTL_MOD_VCV_TEST`**: A control flag indicating a VCV test mode.
*   **`C_CUR_VCV_CTL_PEAK`**: Constant for VCV peak current control set point.
*   **`C_CUR_VCV_CTL_0`**: Constant for VCV current control phase 0 set point.
*   **`C_CUR_VCV_CTL_1`**: Constant for VCV current control phase 1 set point.
*   **`C_CUR_VCV_DEACC_PEAK`**: Constant for VCV deactivation peak current set point.
*   **`C_CUR_VCV_CTL_DEACC`**: Constant for VCV deactivation current set point.
*   **`C_CUR_VCV_CTL_PEAK_ST`**: Constant for VCV static peak current set point.
*   **`C_CUR_VCV_CTL_ST`**: Constant for VCV static current set point.
*   **`C_PWM_VCV_CTL_PEAK`**: Constant for VCV peak current PWM duty cycle (direct override).
*   **`C_PWM_VCV_CTL_0`**: Constant for VCV phase 0 PWM duty cycle (direct override).
*   **`C_PWM_VCV_CTL_1`**: Constant for VCV phase 1 PWM duty cycle (direct override).
*   **`C_PWM_VCV_DEACC_PEAK`**: Constant for VCV deactivation peak current PWM duty cycle (direct override).
*   **`C_PWM_VCV_CTL_DEACC`**: Constant for VCV deactivation current PWM duty cycle (direct override).
*   **`C_PWM_VCV_CTL_PEAK_ST`**: Constant for VCV static peak current PWM duty cycle (direct override).
*   **`C_PWM_VCV_CTL_ST`**: Constant for VCV static current PWM duty cycle (direct override).
*   **`num_dec`**: An input to the "GET BIT" block, likely a numerical value or register from which specific bits are extracted for disable logic.
*   **`0`**: Constant zero values used for comparison.

## Outputs
The diagram produces the following outputs:

*   **`PWM_VCV_OPL_CTL_MAX`**: The calculated PWM duty cycle for maximum VCV operating control.
*   **`PWM_VCV_CTL_PEAK`**: The final PWM duty cycle for VCV peak current control.
*   **`PWM_VCV_CTL_0`**: The final PWM duty cycle for VCV current control phase 0.
*   **`PWM_VCV_CTL_1`**: The final PWM duty cycle for VCV current control phase 1.
*   **`PWM_VCV_DEACC_PEAK`**: The final PWM duty cycle for VCV deactivation peak current.
*   **`PWM_VCV_CTL_DEACC`**: The final PWM duty cycle for VCV deactivation current.
*   **`PWM_VCV_CTL_PEAK_ST`**: The final PWM duty cycle for VCV static peak current.
*   **`PWM_VCV_CTL_ST`**: The final PWM duty cycle for VCV static current.
*   **`<LV_VCV_DI>`**: A boolean flag indicating whether VCV actuation is disabled.

## Logic Flow

1.  **Maximum Operating Control PWM Calculation**:
    *   The input `C_CUR_VCV_OPL_CTL_MAX` (a maximum current set point) and `x_val` (an independent variable) are fed into a 1D lookup table named `IP_PWM_CUR_VCV_REQ`.
    *   This lookup table converts the current set point into a corresponding PWM value, which is then output as `PWM_VCV_OPL_CTL_MAX`.

2.  **VCV Actuation Disable Logic (`<LV_VCV_DI>`)**:
    *   This section determines if the VCV actuation should be disabled. It consists of multiple conditions combined by a final AND gate.
    *   **Condition 1 (Modes/Bits)**: `CLF_CUR_CTL_MOD_VCV` and `CLF_CUR_CTL_MOD_VCV_TEST` are fed into an AND gate. The output of this AND gate is combined with the output of a "GET BIT" block (which extracts specific bits `[0:6]` from `num_dec`). All these are ANDed together to form a sub-condition related to active control/test modes and configuration bits.
    *   **Condition 2 (Current Parameters Zero)**: Each of the current set point inputs (`C_CUR_VCV_CTL_PEAK`, `C_CUR_VCV_CTL_0`, ..., `C_CUR_VCV_CTL_ST`) is checked if it is equal to zero (`== 0`). The results of these individual comparisons are then combined using an AND gate. This sub-condition is true if *all* current set points are zero.
    *   **Condition 3 (PWM Parameters Non-Zero)**: Each of the direct PWM set point inputs (`C_PWM_VCV_CTL_PEAK`, `C_PWM_VCV_CTL_0`, ..., `C_PWM_VCV_CTL_ST`) is checked if it is not equal to zero (`~= 0`). The results of these individual comparisons are then combined using an AND gate. This sub-condition is true if *none* of the direct PWM set points are zero.
    *   **Final Disable Flag**: The results of Condition 1, Condition 2, and Condition 3 are all fed into a final multi-input AND gate. The output of this AND gate is `<LV_VCV_DI>`. Thus, the VCV actuation is disabled if specific control/test modes are active and configuration bits are set, AND all current control parameters are set to zero, AND all direct PWM control parameters are set to a non-zero value.

3.  **Phase-Specific PWM Duty Cycle Calculation/Selection**:
    *   This is the main block for determining the final PWM duty cycles for various VCV operating phases. There are seven distinct phases (Peak, 0, 1, Deacc_Peak, Deacc, Peak_ST, ST).
    *   For each phase, two inputs are considered:
        *   A current set point (`C_CUR_VCV_CTL_X`).
        *   A direct PWM set point (`C_PWM_VCV_CTL_X`).
    *   The current set point (`C_CUR_VCV_CTL_X`) for a phase is fed into a `CLC_IP_PWM_CUR_VCV_REQ` block (a subsystem, indicated by X.2.1.1.1.1). This block performs the conversion from the desired current to a corresponding PWM duty cycle.
    *   Simultaneously, the direct PWM set point (`C_PWM_VCV_CTL_X`) for that phase is evaluated using a "Check ~= 0" block.
    *   The output of this "Check ~= 0" block acts as a selection signal (implicitly a switch or multiplexer, though not explicitly shown as a standard Simulink Switch block).
    *   If `C_PWM_VCV_CTL_X` is NOT zero (i.e., the "Check ~= 0" is true), then the `C_PWM_VCV_CTL_X` value is selected as the output for that phase.
    *   If `C_PWM_VCV_CTL_X` IS zero (i.e., the "Check ~= 0" is false), then the PWM value calculated by the `CLC_IP_PWM_CUR_VCV_REQ` block (from the `C_CUR_VCV_CTL_X` input) is selected as the output for that phase.
    *   This logic effectively prioritizes a directly specified non-zero PWM duty cycle; otherwise, it relies on converting the current set point to PWM.
    *   This process is repeated independently for all seven VCV control phases, resulting in the seven `PWM_VCV_CTL_X` outputs.


--- Page 203 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink diagram is to control a fuel pressure actuator, specifically a Voltage Control Valve (VCV), by generating a Pulse Width Modulation (PWM) signal. It takes a current VCV request or value and transforms it through a calibrated characteristic curve and potential dynamic processing into the final PWM command for the actuator.

## Inputs
*   **`<cur_vcv>`**: This is the main input signal, representing the current desired value or operating point for the Voltage Control Valve. It could be a desired voltage, current, pressure, or another relevant parameter.
*   **`u`**: An input to the second `C0` block. Its specific role is not fully detailed in the diagram but typically represents an additional control input, a feedback signal, or a parameter influencing the final PWM calculation.

## Outputs
*   **`<pwm_vcv>`**: This is the final output signal, representing the Pulse Width Modulation duty cycle or command for the Voltage Control Valve (fuel pressure actuator).

## Logic Flow

1.  **Iteration Initiation**: The process begins with a "For Iterator" block, indicating a loop that runs from `0` to `N-1`. This suggests that the operations within the loop are performed iteratively, possibly processing elements of a vector or executing steps of a multi-stage calculation.

2.  **Input Conditioning (First C0 block)**:
    *   The output of the "For Iterator" (likely an iteration index) and the `<cur_vcv>` input are fed into a block labeled `C0` (V.6.16).
    *   This `C0` block likely processes the `<cur_vcv>` signal based on the current iteration. For example, if `<cur_vcv>` is a vector, this block might select the element corresponding to the current iteration index, or perform some derived calculation.
    *   The output of this block is `x_val`, which serves as the input to the subsequent lookup table.

3.  **Lookup Table Mapping**:
    *   The `x_val` is then fed into a 1-D Lookup Table block named `IP_PWM_CUR_VCV_REQ` (V.7.11).
    *   This lookup table contains a pre-calibrated characteristic curve that maps the input `x_val` to an intermediate output `IP_val`. The name suggests this `IP_val` is an Intermediate Pressure (IP) or a raw Pulse Width Modulation (PWM) request based on the desired VCV state. This mapping typically captures the static, non-linear relationship between the desired VCV state and a preliminary control signal.

4.  **Dynamic Processing and Output Generation (Second C0 block)**:
    *   The `IP_val` from the lookup table, along with an input `u` and specific parameters labeled `1` and `z`, are fed into a second `C0` block (V.7.16).
    *   The `Init = zeros(1,7)` associated with `z` indicates that `z` is likely an internal state vector within this `C0` block, initialized as a 1x7 array of zeros.
    *   This block performs further dynamic processing, such as filtering, control law implementation (e.g., PID, state-space control), or smoothing, to transform the raw `IP_val` into the final, compensated `<pwm_vcv>` signal. The presence of internal state `z` implies a memory-based or dynamic behavior, essential for stable and precise actuator control.

5.  **PWM Output**: The final output of the second `C0` block is the `<pwm_vcv>` signal, which is then sent to control the fuel pressure VCV actuator.


--- Page 204 ---

This page contains a Simulink-like diagram, likely representing a control logic for an automotive system.

## Function
The primary function of this diagram, as indicated by the title "Manual setting of VCV current control parameters via application tool," is to provide a mechanism for manually configuring or overriding Volume Control Valve (VCV) current control parameters. This is typically used for development, calibration, testing, or diagnostic purposes, allowing an external application tool to modify the operational characteristics of the VCV, which is part of a fuel pressure actuator control system (FUSL).

## Inputs
The diagram receives various inputs, primarily for control logic and parameter values:

*   **System State/Mode Inputs:**
    *   `<ECU_STATE>`: Current state of the Electronic Control Unit.
    *   `SYN_ENG_IGK_ON`: Signal indicating engine ignition is ON.
    *   `SYN_ENG_IGK_OFF`: Signal indicating engine ignition is OFF.
    *   `LV_SYN_ENG_VCV_CTL`: Local variable for engine VCV control status.
    *   `LV_VCV_DI`: Local variable for VCV diagnostic input.
    *   `VCV_TEST_V`: Flag for VCV test mode.
*   **Manual Function Trigger Inputs (Application Tool Commands):**
    *   `fc_10MS_DI`, `fc_SEG`: Mode selection inputs, possibly for 10ms-triggered or segment-triggered actions.
    *   `fc_MflDisable_SEG`, `fc_MflDisable_10MS`: Triggers to disable a function.
    *   `fc_SetCurCtlModeVcv_SEG`, `fc_SetCurCtlModeVcv_10MS`: Triggers to set the current control mode of the VCV.
    *   `fc_MflUpdate_SEG`, `fc_MflUpdate_10MS`: Triggers to update parameters.
    *   `fc_MflSetVcvCtlPls_SEG`, `fc_MflSetVcvCtlPls_10MS`: Triggers to set VCV control pulse parameters.
    *   `fc_MflEnable_SEG`, `fc_MflEnable_10MS`: Triggers to enable a function.
    *   `fc_MflStart_10MS`: Trigger to start a function.
*   **Parameter Inputs (from Application Tool, prefixed 'PRM_'):** These are the values to be set for the VCV control.
    *   `PRM_PUMP_NR`: Pump number.
    *   `PRM_DISABLE_MODE`: Mode for disabling.
    *   `PRM_LF_CUR_CTL_MOD_VCV`: VCV current control mode.
    *   `PRM_LV_STATE_DEACC_PLS_ACT`, `PRM_T_DEACC_OFF_VCV`, `PRM_T_DUR_VCV_CTL_DEACC`, `PRM_PWM_VCV_DEACC_PEAK`, `PRM_FRQ_PWM_VCV_DEACC_PEAK`, `PRM_T_DEACC_ON_VCV`: Parameters for VCV deactivation pulse.
    *   `PRM_ANG_REF_VCV`, `PRM_ANG_CUR_ON_VCV`, `PRM_ANG_CUR_OFF_VCV`: Angular parameters for VCV control.
    *   `PRM_PWM_VCV_OPL_CTL_MAX`, `PRM_T_DUR_VCV_CTL_PEAK`, `PRM_PWM_VCV_CTL_PEAK`, `PRM_FRQ_PWM_VCV_CTL_PEAK`, `PRM_T_DUR_VCV_CTL_HOLD_0`, `PRM_PWM_VCV_CTL_0`, `PRM_FRQ_PWM_VCV_CTL_0`, `PRM_T_DUR_VCV_CTL_1`, `PRM_PWM_VCV_CTL_1`, `PRM_FRQ_PWM_VCV_CTL_1`, `PRM_T_DUR_VCV_CTL_FW`: Various PWM, duration, and frequency parameters for VCV control pulses.
    *   `PRM_T_VCV_CTL_ST`, `PRM_PWM_VCV_CTL_PEAK_ST`, `PRM_FRQ_PWM_VCV_CTL_PEAK_ST`, `PRM_PWM_VCV_CTL_ST`, `PRM_FRQ_PWM_VCV_CTL_ST`, `PRM_NC_T_DUR_MAX`, `PRM_T_DUR_VCV_CTL_FW`: Parameters for VCV control in a "start" or "standby" state.

## Outputs
The diagram produces the following outputs:

*   **VCV State/Mode Outputs:**
    *   `STATE_VCV`: The determined operational state of the VCV.
    *   `LV_SYN_ENG_VCV_CTL`: (Potentially an updated local variable).
    *   `LV_VCV_DI`: (Potentially an updated local variable).
*   **Action Confirmation/Trigger Outputs (prefixed 'ACTION_INFR_T3'):** These signals indicate that a specific configuration action has been triggered and parameters are being updated in the infrastructure.
    *   `ACTION_INFR_MflDisable_T3`
    *   `ACTION_INFR_SetCurCtlModeVcv_T3`
    *   `ACTION_INFR_MflSetVcvDeaccPls_T3`
    *   `ACTION_INFR_MflUpdate_T3`
    *   `ACTION_INFR_MflSetVcvCtlPls_T3`
    *   `ACTION_INFR_MflEnable_T3`
    *   `ACTION_INFR_MflStart_T3`
*   **Internal Constant Outputs (prefixed 'C_', 'LC_', 'CLF_', 'PWM_'):** These are the VCV control parameters that are set or updated by the application tool.
    *   `C_PUMP_NR`, `LC_VCV_DI_MOD`, `CLF_CUR_CTL_MOD_VCV`: Pump number, VCV diagnostic mode, VCV current control mode.
    *   `LC_STATE_DEACC_PLS_ACT`, `C_T_DEACC_OFF_VCV`, `C_T_DUR_VCV_CTL_DEACC`, `PWM_VCV_DEACC_PEAK`, `C_FRQ_PWM_VCV_DEACC_PEAK`, `C_T_DEACC_ON_VCV`: VCV deactivation pulse parameters (state, timings, PWM, frequency).
    *   `C_ANG_REF_VCV`, `C_ANG_CUR_ON_VCV`, `C_ANG_CUR_OFF_VCV`: VCV angular control parameters.
    *   `PWM_VCV_OPL_CTL_MAX`, `C_T_DUR_VCV_CTL_PEAK`, `PWM_VCV_CTL_PEAK`, `C_FRQ_PWM_VCV_CTL_PEAK`, `C_T_DUR_VCV_CTL_HOLD_0`, `PWM_VCV_CTL_0`, `C_FRQ_PWM_VCV_CTL_0`, `C_T_DUR_VCV_CTL_1`, `PWM_VCV_CTL_1`, `C_FRQ_PWM_VCV_CTL_1`, `C_T_DUR_VCV_CTL_FW`: Various VCV control pulse parameters (max PWM, peak duration/PWM/frequency, hold duration, specific PWMs/frequencies/durations for different states).
    *   `C_T_VCV_CTL_ST`, `PWM_VCV_CTL_PEAK_ST`, `C_FRQ_PWM_VCV_CTL_PEAK_ST`, `PWM_VCV_CTL_ST`, `C_FRQ_PWM_VCV_CTL_ST`, `C_T_DUR_MAX`, `C_T_DUR_VCV_CTL_FW`: VCV control parameters for start/standby states.

## Logic Flow

The logical flow of the diagram can be described in two main phases:

1.  **Enabling and Mode Selection Logic (Top Section):**
    *   **VCV Test State Determination:** The `ECU_STATE` is compared against `SYN_ENG_IGK_ON` and `SYN_ENG_IGK_OFF`. If the ECU is in either of these ignition states, an OR gate becomes true. This, along with the inverse of `LV_SYN_ENG_VCV_CTL` (which is itself derived from an OR of `LV_SYN_ENG_VCV_CTL` and `LV_VCV_DI`), contributes to determining `VCV_TEST_V`.
    *   **VCV Overall State:** The `STATE_VCV` output is derived from `LV_SYN_ENG_VCV_CTL`, `LV_VCV_DI`, and `VCV_TEST_V` through OR gates, indicating the active VCV control state or diagnostic mode.
    *   **Manual Function Activation Logic:** Another set of `ECU_STATE` comparisons with `SYN_ENG_IGK_ON` and `SYN_ENG_IGK_OFF` feeds into an `OR` block. The output of this `OR` block (representing a condition for enabling manual functions) controls a `cond_if` block.
        *   If the `if` condition is met (e.g., specific engine ignition state), it activates signals like `fc_10MS_DI`.
        *   Otherwise (the `else` path), it activates `fc_SEG`.
    *   These `fc_` signals (e.g., `fc_MflDisable_SEG`, `fc_SetCurCtlModeVcv_SEG`) are then routed through various selector blocks, which seem to choose between `_SEG` (segment-based) or `_10MS` (10-millisecond cycle based) triggers, depending on other internal control signals like `fc_10MS_ENA`. This ensures that the manual functions are activated with the correct timing or context.

2.  **Parameter Setting and Action Execution (Lower Main Section):**
    *   **Action Triggering:** Each selected `fc_` signal (e.g., `fc_MflDisable` after passing through the selector logic) acts as a trigger for a specific `ACTION_INFR_T3` signal (e.g., `ACTION_INFR_MflDisable_T3`). These `ACTION_INFR_T3` signals represent a command to the underlying system infrastructure.
    *   **Parameter Transfer:** Associated with each `ACTION_INFR_T3` trigger is a `fcn_call()` block (e.g., the block labeled `fcn_call()` connected to `ACTION_INFR_MflDisable`). These `fcn_call()` blocks represent the core mechanism for setting parameters.
        *   Each `fcn_call()` block receives specific parameters as inputs, prefixed with `PRM_` (e.g., `PRM_PUMP_NR`, `PRM_DISABLE_MODE`). These `PRM_` inputs are the values provided by the application tool.
        *   When an `ACTION_INFR_T3` is triggered, the corresponding `fcn_call()` block effectively "writes" or "applies" the input `PRM_` values to the internal constant or variable memory of the system, represented by `C_`, `LC_`, `CLF_`, or `PWM_` prefixed outputs.
    *   **Modular Parameter Configuration:** The diagram is modular, with separate `fcn_call()` blocks and corresponding `ACTION_INFR_T3` triggers for different sets of VCV parameters:
        *   Disabling parameters (`PRM_DISABLE_MODE` -> `LC_VCV_DI_MOD`).
        *   Current control mode (`PRM_LF_CUR_CTL_MOD_VCV` -> `CLF_CUR_CTL_MOD_VCV`).
        *   Deactivation pulse parameters (`PRM_LV_STATE_DEACC_PLS_ACT` etc. -> `LC_STATE_DEACC_PLS_ACT` etc.).
        *   General update (sets `C_PUMP_NR`).
        *   Detailed control pulse parameters (angles, PWMs, frequencies, durations).
        *   Enabling (sets `C_PUMP_NR`).
        *   Start/Standby parameters (sets `C_T_VCV_CTL_ST` etc.).

In summary, the system first determines the valid operational context for manual intervention based on ECU and ignition states. Then, based on specific trigger signals from an application tool (segmented or 10ms-based), it calls specific functions to write predefined parameter values (`PRM_`) into the system's internal configuration registers (`C_`, `LC_`, `CLF_`, `PWM_`), effectively overriding or setting the VCV current control behavior.


--- Page 205 ---

This page contains a block diagram illustrating a specific calculation within an automotive control system, likely related to fuel pressure regulation. While not a direct screenshot of a Simulink environment, it employs standard block diagram notation consistent with model-based design.

## Function
The primary function of this diagram is to calculate the **reference angle for the High-Pressure Fuel Pump's Volume Control Valve (VCV)**. This calculation takes into account the physical mounting angle of the pump on the camshaft and applies a correction to address Variable Valve Timing (VVT) effects, ensuring precise fuel pump control relative to engine operation.

## Inputs
1.  **<CAM_FUEL_PUMP>**: This is the basic value representing the angle of the camshaft at which the high-pressure fuel pump is mounted. It serves as the fundamental reference for the pump's position relative to the engine cycle.
2.  **C_VCV_CLOSE_BAS (V.6.11)**: This is a constant or calibration parameter representing a "correction angle." Its purpose is to compensate for or consider Variable Valve Timing (VVT) effects on the pump's operation, ensuring the reference angle remains accurate despite cam phasing changes.

## Outputs
1.  **<ANG_REF_VCV>**: This is the final calculated reference angle for the Volume Control Valve (VCV) of the high-pressure fuel pump. This output angle would likely be used by a downstream controller to regulate the VCV, thereby controlling the fuel quantity delivered by the pump.

## Logic Flow
1.  **Basic Angle Acquisition**: The process begins with the input `<CAM_FUEL_PUMP>`, which provides the fundamental camshaft angle relevant to the fuel pump's position. This forms the base value for the calculation.
2.  **Correction Angle Application**: A correction value, `C_VCV_CLOSE_BAS`, is introduced. As indicated by the text, this value is specifically designed to apply a correction to account for VVT effects, which can alter the effective timing of the pump's stroke relative to the engine's combustion cycle.
3.  **Summing Operation**: Both the `<CAM_FUEL_PUMP>` value and the `C_VCV_CLOSE_BAS` correction angle are fed into a summing junction (labeled V.7.7, likely an identification for the component or version). The two plus signs indicate that `C_VCV_CLOSE_BAS` is added to `<CAM_FUEL_PUMP>`. This addition integrates the VVT-related correction into the basic pump angle.
4.  **Output Generation**: The result of this summation, which is the adjusted angle, is then output as `<ANG_REF_VCV>`. This output represents the desired reference angle for the fuel pump's Volume Control Valve, reflecting both the physical pump position and any necessary VVT compensation.


--- Page 206 ---

This page contains a Simulink-like diagram, likely representing a control algorithm for an automotive fuel system.

## Function
The primary function of this Simulink diagram is to calculate and control the requested mass fuel pump (MFP) flow, considering various operating conditions, efficiency factors, and offsets. It determines a precise `MFP_REQ` signal to command a fuel pressure actuator, ensuring accurate fuel delivery based on engine speed, temperatures, and internal fuel pump characteristics.

## Inputs
*   **`<N_32>`**: Engine speed (used in multiple calculations for efficiency factors and offsets).
*   **`<TFU_HPP>`**: High-pressure pump temperature.
*   **`<MFF_SP_FUP_CTL>`**: Mass fuel flow setpoint for fuel pump control.
*   **`<FUP_SP>`**: Fuel pump speed setpoint (used in multiple calculations).
*   **`<TFU_IPP>`**: Intermediate pressure pump temperature.
*   **`<TFU_ADD>`**: Additional temperature input (e.g., ambient or coolant).
*   **`C_MFP_MAX`**: A calibrated constant representing the maximum mass fuel pump flow.
*   **`C_FAC_FUEL_PUMP_CTL`**: A calibrated constant factor for fuel pump control.
*   **`FUEL_MASS_REQ_CTL`**: The primary fuel mass request from a higher-level controller.
*   **`<LV_MFP_REQ_LOW>` (Input)**: A low-level mass fuel pump request, possibly a previous value or an external reference used for comparison or filtering.
*   **`<LV_MFP_REQ_CONT>` (Input)**: A continuous low-level mass fuel pump request, similar to the above, for control logic.

## Outputs
*   **`<MFP_MAX>`**: The calculated maximum permissible or nominal mass fuel pump flow, corrected for efficiency.
*   **`<FAC_FUEL_PUMP_EFF_COR>`**: A combined fuel pump efficiency correction factor.
*   **`<MFP_OFS>`**: The calculated mass fuel pump offset, accounting for factors like dead volume and temperature effects.
*   **`<MFP_REQ_CTL>`**: The controlled mass fuel pump request, derived from the primary request, a control factor, and the calculated offset.
*   **`<LV_MFP_REQ_LOW>` (Output)**: The low-level mass fuel pump request, which is a direct assignment of `<MFP_REQ_CTL>`.
*   **`<LV_MFP_REQ_CONT>` (Output)**: A continuous low-level mass fuel pump request. *Note: Its derivation within this specific diagram is not explicitly shown via an incoming signal.*
*   **`<MFP_REQ>`**: The final mass fuel pump request, which is the ultimate command signal for the actuator.

## Logic Flow

The logical flow can be broken down into several parallel calculation paths that ultimately converge to determine the final mass fuel pump request:

1.  **Maximum Mass Fuel Flow Calculation (`<MFP_MAX>`)**:
    *   Engine speed (`<N_32>`) and high-pressure pump temperature (`<TFU_HPP>`) are fed into a 2D lookup table (`IP_FAC_FUEL_PUMP_EFF_TFU_N`). This table outputs an efficiency factor (`_P_val`).
    *   This efficiency factor is multiplied by the constant `C_MFP_MAX`.
    *   The result is the output `<MFP_MAX>`, representing the maximum possible fuel mass flow under current conditions.

2.  **Fuel Pump Efficiency Correction Factor Calculation (`<FAC_FUEL_PUMP_EFF_COR>`)**:
    *   Engine speed (`<N_32>`) and mass fuel flow setpoint (`<MFF_SP_FUP_CTL>`) are fed into a 2D lookup table (`IP_FAC_FUEL_PUMP_EFF_MFF_SP_N`), yielding an efficiency factor (`_P_val`).
    *   In parallel, engine speed (`<N_32>`) and fuel pump speed setpoint (`<FUP_SP>`) are fed into another 2D lookup table (`IP_FAC_FUEL_PUMP_EFF_FUP_N`), yielding another efficiency factor (`_P_val`).
    *   These two efficiency factors are then multiplied together.
    *   The product is the output `<FAC_FUEL_PUMP_EFF_COR>`, a combined correction for fuel pump efficiency.

3.  **Mass Fuel Pump Offset Calculation (`<MFP_OFS>`)**:
    *   Engine speed (`<N_32>`) and fuel pump speed setpoint (`<FUP_SP>`) are fed into a 2D lookup table (`IP_MFP_OFS`), producing a base offset (`_P_val`).
    *   Engine speed (`<N_32>`) and intermediate pressure pump temperature (`<TFU_IPP>`) are fed into a 2D lookup table (`IP_MFP_OFS_TFU_IPP_ADD`), producing a temperature-dependent offset (`_P_val`).
    *   Engine speed (`<N_32>`) and an additional temperature (`<TFU_ADD>`) are fed into a 2D lookup table (`IP_MFP_OFS_TFU_ADD`), producing another temperature-dependent offset (`_P_val`).
    *   The three `_P_val` outputs from these lookup tables are summed together.
    *   The sum passes through a unity gain block (`V.6.8`) to become the output `<MFP_OFS>`, representing the total mass fuel flow offset.

4.  **Controlled Mass Fuel Pump Request Calculation (`<MFP_REQ_CTL>`)**:
    *   The primary fuel mass request (`FUEL_MASS_REQ_CTL`) is multiplied by the constant `C_FAC_FUEL_PUMP_CTL`.
    *   The result of this multiplication is added to the calculated mass fuel pump offset (`<MFP_OFS>`) from step 3.
    *   This sum passes through a unity gain block (`V.6.8`) to become the output `<MFP_REQ_CTL>`, which is the controlled fuel mass request.

5.  **Final Mass Fuel Pump Request (`<MFP_REQ>`) and Low-Level Outputs**:
    *   The calculated `<MFP_REQ_CTL>` is directly assigned to the output `<LV_MFP_REQ_LOW>`.
    *   The `CLC_MFP_REQ1` block receives the newly calculated `<MFP_REQ_CTL>`, along with the input `<LV_MFP_REQ_LOW>` (a previous/external low request) and the input `<LV_MFP_REQ_CONT>` (a previous/external continuous request).
    *   Based on these inputs, the `CLC_MFP_REQ1` block (which likely contains internal control logic such as filtering, ramping, or state machine logic) computes and outputs the final `<MFP_REQ>`.
    *   The output `<LV_MFP_REQ_CONT>` is shown as an output, but its value is not explicitly derived from signals within this diagram section.


--- Page 207 ---

This page contains a Simulink-like diagram, likely representing control logic for an automotive system.

## Function

The primary function of this Simulink diagram is to implement a "Small-quantity regulation" logic for fuel pressure actuator control (FUSL). It determines whether a "small quantity" fuel request condition is active, if this condition should continue over time, and consequently adjusts the final requested fuel mass (`<MFP_REQ>`). This regulation is crucial for handling situations where the requested fuel mass is below a minimum threshold, potentially accumulating multiple small requests.

## Inputs

*   **`LC_MFP_REQ_L_ACT`**: (Boolean/Logical) Manual activation switch for small-quantity regulation.
*   **`C_MFP_REQ_MIN`**: (Calibrated Value) Threshold for the minimum requested fuel mass to recognize a small quantity.
*   **`C_MFP_REQ_MAX`**: (Calibrated Value) Threshold for the maximum requested fuel mass, above which the small quantity condition is de-recognized.
*   **`<MFP_REQ_CTL>`**: (Numeric) Current requested fuel mass from the controller.
*   **`<LV_MFP_REQ_LOW>`**: (Boolean/Logical) Feedback/previous state indicating if the small quantity condition was active in the prior cycle. (Also an output).
*   **`MFP_REQ_CTL_OLD`**: (Numeric) Fuel mass requested in the previous recurrence/cycle.
*   **`<MFP_OFS>`**: (Numeric) An offset value for fuel mass, possibly for correction or base value.
*   **`mfp_req_ctl_2_tmp`**: (Numeric) A temporary variable representing a fuel control value, used in several calculations.
*   **`mfp_req_ctl_1_tmp`**: (Numeric) Another temporary variable representing a fuel control value.
*   **`<LV_MFP_REQ_CONT>`**: (Boolean/Logical) Feedback/previous state indicating small quantity continuation. (Also an output).

## Outputs

*   **`<LV_MFP_REQ_LOW>`**: (Boolean/Logical) Indicates whether the "small quantity low" condition is currently active.
*   **`<LV_MFP_REQ_CONT>`**: (Boolean/Logical) Indicates whether the "small quantity continuation" condition is active, often derived from previous states and current calculations.
*   **`<MFP_REQ>`**: (Numeric) The final, adjusted requested fuel mass, potentially modified by the small-quantity regulation logic.

## Logic Flow

The diagram can be broken down into two main logical sections: Small Quantity State Detection and Fuel Mass Calculation/Continuation.

1.  **Small Quantity State Detection (`<LV_MFP_REQ_LOW>`)**:
    *   **Set Condition for Small Quantity:**
        *   The current requested fuel mass (`<MFP_REQ_CTL>`) is compared to `C_MFP_REQ_MIN`. If `<MFP_REQ_CTL>` is less than or equal to `C_MFP_REQ_MIN`, this condition is true.
        *   This true condition is then logically ANDed with the `LC_MFP_REQ_L_ACT` signal (manual activation).
        *   The result of this AND operation serves as the SET input to an SR Flip-Flop (V.6.12).
    *   **Reset Condition for Small Quantity:**
        *   The current requested fuel mass (`<MFP_REQ_CTL>`) is compared to `C_MFP_REQ_MAX`. If `<MFP_REQ_CTL>` is greater than or equal to `C_MFP_REQ_MAX`, this condition is true.
        *   This true condition serves as the RESET input to the SR Flip-Flop.
    *   **SR Flip-Flop (V.6.12):** This block's Q output represents the current state of `<LV_MFP_REQ_LOW>`. It latches the "small quantity low" state. The `Q_in` input (which is the previous `<LV_MFP_REQ_LOW>`) is fed back, providing memory and influencing the flip-flop's behavior (e.g., to hold the state until a reset condition is met).
    *   The output `Q` of the flip-flop is buffered (V.6.8) and then output as **`<LV_MFP_REQ_LOW>`**, signifying if a small quantity is recognized.

2.  **Fuel Mass Calculation and Continuation Logic (`<LV_MFP_REQ_CONT>`, `<MFP_REQ>`)**:
    *   **Conditional Logic (If block V.6.4):** The diagram branches into two main paths based on the value of `<LV_MFP_REQ_LOW>` (the output from the SR Flip-Flop).
        *   **If `<LV_MFP_REQ_LOW>` is TRUE (Small Quantity is Active):**
            *   Two fuel mass values are summed: `<MFP_REQ_CTL>` (current requested) and `MFP_REQ_CTL_OLD` (previous requested).
            *   This sum, along with a constant `0` and `mfp_req_ctl_2_tmp`, are fed into a selector block ("Check ~= 0", V.6.10). This block likely prioritizes or selects a non-zero value among its inputs.
        *   **If `<LV_MFP_REQ_LOW>` is FALSE (Small Quantity is Not Active):**
            *   `mfp_req_ctl_1_tmp`, `<LV_MFP_REQ_CONT>` (from the previous cycle), and `mfp_req_ctl_2_tmp` are fed into another selector block ("Check ~= 0", V.6.10), similar to the above, which also likely selects a non-zero input.
    *   **Continuation Flag (`<LV_MFP_REQ_CONT>`):**
        *   The outputs of both "Check ~= 0" selector blocks are merged by a `BusMerge` block (V.6.6).
        *   The output of the `BusMerge` forms the **`<LV_MFP_REQ_CONT>`** signal, which indicates whether the small quantity delivery should be continued in the current recurrence.
    *   **Final Requested Fuel Mass (`<MFP_REQ>`):**
        *   Separately, an offset `MFP_OFS` is added to `mfp_req_ctl_2_tmp`. The result of this sum is one input to a `max` block (V.6.11).
        *   The `<LV_MFP_REQ_CONT>` signal (a boolean) is passed through a `max(X, 0)` block (V.6.11). This essentially ensures it remains non-negative if interpreted numerically (0 or 1).
        *   The two results (from `MFP_OFS + mfp_req_ctl_2_tmp` and the processed `LV_MFP_REQ_CONT`) are then fed into a final `max` block (V.6.11).
        *   The output of this final `max` block is the **`<MFP_REQ>`**, representing the ultimate requested fuel mass, potentially adjusted based on the small-quantity regulation logic. This indicates that the system will request the higher of the two values, either a baseline calculated fuel mass or a value derived from the small-quantity continuation state.


--- Page 209 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink diagram is to determine the active control state or request for a fuel pump's Volume Control Valve (VCV) and/or Mechanical Fuel Pump (MFP). It acts as a state machine or a priority encoder that evaluates various ECU states, operational conditions, and thresholds to activate a specific request flag, influencing the overall fuel pressure actuator control. As per the accompanying text, it's "Determining the State of Pump volume control".

## Inputs
The diagram receives the following input signals and parameters (indicated by green rounded rectangles and constants):

*   **`<ECU_STATE>`**: Current operational state of the Engine Control Unit.
*   **`SYN_ENG_IGK_ON`**: A constant or parameter representing the "Engine Ignition ON" state for comparison.
*   **`<LV_ST_END>`**: Status flag indicating the end of an engine stop sequence.
*   **`<LV_ST_H_PRS>`**: Status flag indicating the high pressure system state.
*   **`<FUP>`**: Current fuel pump pressure/value.
*   **`C_FUP_OFS_MFP_MAX`**: A constant/parameter representing the maximum offset for the Mechanical Fuel Pump.
*   **`<FUP_SP>`**: Fuel Pump Setpoint.
*   **`<LV_FUP_LIH_L_PRS_CTL_REQ>`**: Request flag for low pressure control in the fuel pump system.
*   **`<LV_VCV_OPEN_EXT_REQ>`**: External request to open the Volume Control Valve.
*   **`SYN_ENG_IGK_OFF`**: A constant or parameter representing the "Engine Ignition OFF" state for comparison.
*   **`<T_VCV_MFP_START>`**: Threshold for VCV/MFP start.
*   **`LC_PUMP_VOL_VCV_MAN`**: Manual control status for pump volume VCV (likely a boolean flag).
*   **`<MFF_SP_FUP_CTL>`**: Mass Flow Setpoint for Fuel Pump Control.
*   **`<FUP_DIF>`**: Fuel Pump Differential value.
*   **`C_FUP_DIF_VCV_OPEN_THD`**: Threshold for VCV open based on Fuel Pump Differential.
*   **`<MFP_REQ>`**: Current Mechanical Fuel Pump request value.
*   **`<MFP_MAX>`**: Maximum Mechanical Fuel Pump value.

## Outputs
The diagram generates five boolean request flags (indicated by blue rounded rectangles):

*   **`LV_VCV_OPEN_REQ`**: Request flag to open the Volume Control Valve.
*   **`LV_MFP_START_REQ`**: Request flag to start the Mechanical Fuel Pump.
*   **`LV_VCV_TEST_REQ`**: Request flag for VCV test mode.
*   **`LV_MFP_MAX_REQ`**: Request flag for maximum Mechanical Fuel Pump operation.
*   **`LV_MFP_CTL_REQ`**: Request flag for Mechanical Fuel Pump control.

## Logic Flow
The diagram implements a prioritized state determination logic. As described in the accompanying text, the "signal flow ... is from bottom to top, i.e. the bottom most filter is checked first and the flow proceeds up to the top most filter until one of the state request flags are active." This means the conditions for `LV_MFP_CTL_REQ` are evaluated first (highest priority). If that condition is true, `LV_MFP_CTL_REQ` is set to `1`, and all other request flags are set to `0`. If false, the system proceeds to check the next priority level (`LV_MFP_MAX_REQ`), and so on. Only one request flag can be active (`1`) at any given time based on this priority scheme.

Let's denote `COND_X` as the logical condition derived from the input signals for a specific request `LV_X_REQ`.

1.  **`LV_MFP_CTL_REQ` (Highest Priority):**
    *   **Condition (`COND_MFP_CTL_REQ`):** Is true if `LV_ST_H_PRS` is NOT true (no high pressure state) OR (`LV_ST_END` is NOT true AND `FUP_SP` is greater than `0`).
    *   **Result:** If `COND_MFP_CTL_REQ` is true, then `LV_MFP_CTL_REQ` is `1`, and all other request flags are `0`. If false, the system proceeds to evaluate the next priority level.

2.  **`LV_MFP_MAX_REQ`:**
    *   **Condition (`COND_MFP_MAX_REQ`):** Is true if `MFP_REQ` is greater than or equal to `MFP_MAX` AND `[lv_ff_max_req]` is true.
        *   The intermediate signal `[lv_ff_max_req]` is true if (`LV_ST_H_PRS` is NOT true AND `LV_ST_END` is NOT true AND `FUP` is greater than or equal to `C_FUP_OFS_MFP_MAX`).
    *   **Result:** If `COND_MFP_CTL_REQ` was false AND `COND_MFP_MAX_REQ` is true, then `LV_MFP_MAX_REQ` is `1`, and all other request flags are `0`. If false, the system proceeds to evaluate the next priority level.

3.  **`LV_VCV_TEST_REQ`:**
    *   **Condition (`COND_VCV_TEST_REQ`):** Is true if `MFF_SP_FUP_CTL` is equal to `0` AND `FUP_DIF` is greater than or equal to `C_FUP_DIF_VCV_OPEN_THD` AND `LV_ST_END` is true.
    *   **Result:** If `COND_MFP_CTL_REQ` and `COND_MFP_MAX_REQ` were false AND `COND_VCV_TEST_REQ` is true, then `LV_VCV_TEST_REQ` is `1`, and all other request flags are `0`. If false, the system proceeds to evaluate the next priority level.

4.  **`LV_MFP_START_REQ`:**
    *   **Condition (`COND_MFP_START_REQ`):** Is true if (`[lv_syn_eng_igk_on]` is NOT true AND `ECU_STATE` is equal to `SYN_ENG_IGK_OFF`) OR (`LV_ST_END` is NOT true AND `T_VCV_MFP_START` is greater than `0`) OR `LC_PUMP_VOL_VCV_MAN` is true.
        *   The intermediate signal `[lv_syn_eng_igk_on]` is true if `ECU_STATE` is equal to `SYN_ENG_IGK_ON`.
    *   **Result:** If `COND_MFP_CTL_REQ`, `COND_MFP_MAX_REQ`, and `COND_VCV_TEST_REQ` were false AND `COND_MFP_START_REQ` is true, then `LV_MFP_START_REQ` is `1`, and all other request flags are `0`. If false, the system proceeds to evaluate the next priority level.

5.  **`LV_VCV_OPEN_REQ` (Lowest Priority):**
    *   **Condition (`COND_VCV_OPEN_REQ`):** Is true if (`ECU_STATE` is equal to `SYN_ENG_IGK_ON` AND `LV_ST_END` is NOT true) OR (`LV_FUP_LIH_L_PRS_CTL_REQ` is true AND `LV_VCV_OPEN_EXT_REQ` is true AND `LV_ST_H_PRS` is NOT true).
    *   **Result:** If all higher priority conditions were false AND `COND_VCV_OPEN_REQ` is true, then `LV_VCV_OPEN_REQ` is `1`, and all other request flags are `0`. If false, then all request flags (`LV_VCV_OPEN_REQ`, `LV_MFP_START_REQ`, `LV_VCV_TEST_REQ`, `LV_MFP_MAX_REQ`, `LV_MFP_CTL_REQ`) are `0`.


--- Page 210 ---

This page contains two Simulink-like diagrams (likely Stateflow or custom logic diagrams within a Simulink environment) that define the state of a pump control system.

## Function

The primary function of these diagrams is to determine the operational state (`<STATE_VCV>`) of a Fuel Pump's Control Valve (VCV) and potentially the Main Fuel Pump (MFP). They implement a state selection logic based on various input request signals, with Figure 43.15.25 demonstrating a prioritized "If-Else If" structure to handle multiple requests, and Figure 43.15.24 showing a simpler two-state selection for specific phases of pump operation.

## Inputs

**For Figure 43.15.24 ("State of the Pump Control after Test phase"):**
*   `<LV_VCV_TEST_REQ>`: A boolean signal (Local Variable VCV Test Request) indicating whether a VCV test is currently requested.

**For Figure 43.15.25 ("State of the Pump Control after Maximum open phase"):**
*   `<LV_VCV_OPEN_REQ>`: A boolean signal (Local Variable VCV Open Request) indicating whether the VCV should be commanded to an open state.
*   `<LV_MFP_START_REQ>`: A boolean signal (Local Variable Main Fuel Pump Start Request) indicating whether the Main Fuel Pump (MFP) should be commanded to a start state.
*   `<LV_MFP_CTL_REQ>`: A boolean signal (Local Variable Main Fuel Pump Control Request) indicating whether the MFP should be commanded to a controlled state.
*   `<LV_VCV_TEST_REQ>`: A boolean signal (Local Variable VCV Test Request) indicating whether a VCV test is requested.

## Outputs

**For both figures:**
*   `<STATE_VCV>`: The resulting operational state of the VCV and/or the fuel pump system. This output will take on one of the predefined state constant values (e.g., `VCV_OPEN`, `VCV_TEST`, `MFP_START`, `MFP_CTL`, `MFP_MAX`).

## Logic Flow

The diagrams use a series of conditional switches (represented by the `Check ~= 0 V.6.10` blocks) to determine the final `<STATE_VCV>`. These blocks act as priority decoders, where higher priority requests (top-most in Figure 43.15.25) override lower ones. The `STATE_VCV V.6.12` blocks (e.g., `VCV_OPEN`, `VCV_TEST`, `MFP_START`, `MFP_CTL`, `MFP_MAX`) represent constant values corresponding to distinct operational states.

**Figure 43.15.24: State of the Pump Control after Test phase**

This diagram determines the VCV state based solely on a test request:

1.  The boolean input `<LV_VCV_TEST_REQ>` is evaluated.
2.  A `NOT` logical gate inverts this request.
3.  A conditional switch block (`Check ~= 0 V.6.10`) appears to function as an "If-Else" selector:
    *   If `NOT LV_VCV_TEST_REQ` is TRUE (meaning `<LV_VCV_TEST_REQ>` is **FALSE**), the output `<STATE_VCV>` is set to the constant value `VCV_OPEN`.
    *   If `NOT LV_VCV_TEST_REQ` is FALSE (meaning `<LV_VCV_TEST_REQ>` is **TRUE**), the output `<STATE_VCV>` is set to the constant value `VCV_TEST`.
4.  **In essence:** If a VCV test is requested (`<LV_VCV_TEST_REQ>` is TRUE), the system enters the `VCV_TEST` state. Otherwise, it defaults to the `VCV_OPEN` state.

**Figure 43.15.25: State of the Pump Control after Maximum open phase**

This diagram implements a prioritized "If-Else If" decision structure to determine `<STATE_VCV>` based on multiple requests:

1.  **Priority 1 (VCV Open Request):**
    *   The topmost conditional switch evaluates `<LV_VCV_OPEN_REQ>`.
    *   If `<LV_VCV_OPEN_REQ>` is **TRUE**, the output `<STATE_VCV>` is set to `VCV_OPEN`.
    *   If `<LV_VCV_OPEN_REQ>` is **FALSE**, the logic proceeds to the next priority level (the output of the middle switch block).

2.  **Priority 2 (MFP Start Request):**
    *   The middle conditional switch (receiving the "else" branch from Priority 1) evaluates `<LV_MFP_START_REQ>`.
    *   If `<LV_MFP_START_REQ>` is **TRUE**, the output `<STATE_VCV>` is set to `MFP_START`.
    *   If `<LV_MFP_START_REQ>` is **FALSE**, the logic proceeds to the next priority level (the output of the bottom switch block).

3.  **Priority 3 (MFP Control Request):**
    *   The bottom conditional switch (receiving the "else" branch from Priority 2) evaluates `<LV_MFP_CTL_REQ>`.
    *   If `<LV_MFP_CTL_REQ>` is **TRUE**, the output `<STATE_VCV>` is set to `MFP_CTL`.
    *   If `<LV_MFP_CTL_REQ>` is **FALSE**, the logic proceeds to the final priority level.

4.  **Priority 4 (VCV Test Request / MFP Max Default):**
    *   This final logic branch (receiving the "else" from Priority 3) behaves similarly to Figure 43.15.24, using a switch controlled by the inverted `<LV_VCV_TEST_REQ>`:
        *   If `<LV_VCV_TEST_REQ>` is **TRUE**, the output `<STATE_VCV>` is set to `VCV_TEST`.
        *   If `<LV_VCV_TEST_REQ>` is **FALSE** (meaning none of the higher priority requests are active, and a VCV test is not requested), the output `<STATE_VCV>` is set to `MFP_MAX`.

**Overall Prioritized Logic for Figure 43.15.25:**
```
If LV_VCV_OPEN_REQ Then
    STATE_VCV = VCV_OPEN
Else If LV_MFP_START_REQ Then
    STATE_VCV = MFP_START
Else If LV_MFP_CTL_REQ Then
    STATE_VCV = MFP_CTL
Else If LV_VCV_TEST_REQ Then
    STATE_VCV = VCV_TEST
Else
    STATE_VCV = MFP_MAX
```
This logic ensures that the highest priority active request dictates the current operational state of the VCV and fuel pump system.


--- Page 211 ---

This page contains two Stateflow diagrams, which are commonly used within the Simulink environment to model reactive, event-driven systems. These diagrams illustrate the control logic for a fuel pump's Volume Control Valve (VCV) during different operational phases.

## Function

The primary function of these diagrams is to determine the appropriate operational state for the Volume Control Valve (VCV) of a fuel pump. This decision is based on a hierarchy of incoming requests, ensuring that the pump operates according to the highest-priority valid demand. The two diagrams represent this state selection logic during distinct phases of the pump's operation: "after Control phase" (Figure 43.15.26) and "after Opening phase" (Figure 43.15.27). The core difference between the two is the prioritization sequence of the requests, adapting the control logic to the specific requirements of each phase.

## Inputs

The key inputs, represented by green `<LV_..._REQ>` bubbles, are boolean signals indicating various operational demands or requests for the VCV:

*   **`<LV_VCV_OPEN_REQ>`**: Request to open the VCV.
*   **`<LV_MFP_START_REQ>`**: Request to start the Main Fuel Pump (MFP).
*   **`<LV_MFP_MAX_REQ>`**: Request for maximum flow from the MFP.
*   **`<LV_VCV_TEST_REQ>`**: Request to enter a VCV test mode.
*   **`<LV_MFP_CTL_REQ>`**: Request for controlled flow from the MFP (implied by the `MFP_CTL` state block, an explicit input bubble is only present in Figure 43.15.27).

Internal to the logic, each state block also uses a `STATE_VCV` variable (e.g., `VCV_OPEN STATE_VCV V.6.12`), which likely represents the specific value or identifier for that particular VCV state.

## Outputs

The key output, represented by the blue `<STATE_VCV>` bubble, is:

*   **`<STATE_VCV>`**: This variable represents the final, selected operational state of the Volume Control Valve. It is likely an enumerated value or an integer mapping to specific VCV positions or control modes.

## Logic Flow

Both diagrams follow a similar structure of request reception, validation, prioritized selection, and final state assignment, but with different prioritization logic:

### Figure 43.15.26: State of the Pump Control after Control phase

1.  **Request Reception:** The system receives various requests: `<LV_VCV_OPEN_REQ>`, `<LV_MFP_START_REQ>`, `<LV_MFP_MAX_REQ>`, `<LV_VCV_TEST_REQ>`, and implicitly a request for `MFP_CTL`.
2.  **State Association and Validation:** Each request is paired with a corresponding operational state block (`VCV_OPEN`, `MFP_START`, `MFP_MAX`, `VCV_TEST`, `MFP_CTL`). Each of these potential states then undergoes a validation step. This is represented by a block that performs a "Check ~= 0" (version V.6.10). This implies that a requested state is only considered active or valid if its associated `Check` condition evaluates to true (non-zero), ensuring it's permissible in the current context. The `STATE_VCV` variable within these blocks indicates the specific state value associated with that mode.
3.  **Prioritized State Selection:** The validated states are fed into a series of "priority" or "selection" blocks (represented by blocks with multiple triangular inputs/outputs, often acting like junctions or merge blocks in Stateflow with implied prioritization).
    *   The validated `VCV_OPEN` and `MFP_START` states are evaluated together.
    *   The validated `MFP_MAX` and `VCV_TEST` states are evaluated together.
    *   The outputs of these initial selections, along with the `MFP_CTL` state, are further processed in a hierarchical manner. The visual arrangement suggests that some states may take precedence over others (e.g., if multiple requests are valid, only the highest priority one is passed through).
4.  **Final State Assignment:** The output of this multi-level prioritized selection process is fed into a `case: { }` block. This block acts as the final decision point, assigning the ultimate, highest-priority valid state to the `<STATE_VCV>` output variable.

### Figure 43.15.27: State of the Pump Control after Opening phase

1.  **Request Reception:** Similar to the previous phase, the system receives requests: `<LV_MFP_CTL_REQ>`, `<LV_MFP_MAX_REQ>`, `<LV_VCV_TEST_REQ>`, `<LV_MFP_START_REQ>`, and implicitly a request for `VCV_OPEN`.
2.  **State Association and Validation:** Each request is linked to its state block (`MFP_CTL`, `MFP_MAX`, `VCV_TEST`, `MFP_START`, `VCV_OPEN`). As before, a "Check ~= 0" condition (V.6.10) validates each potential state, allowing it to proceed only if conditions are met.
3.  **Prioritized State Selection:** The validated states are again fed into priority selection blocks. However, the order of evaluation and prioritization is different:
    *   The validated `MFP_START` and `VCV_OPEN` states are evaluated together.
    *   The validated `MFP_MAX` and `VCV_TEST` states are evaluated together.
    *   The explicit input `<LV_MFP_CTL_REQ>` for the `MFP_CTL` state appears higher in the overall prioritization chain in this diagram compared to Figure 43.15.26, indicating a potentially higher priority for controlled flow after the opening phase.
    *   These initial selections are then combined through further priority logic.
4.  **Final State Assignment:** The final selected state from the prioritized evaluation is passed to the `case: { }` block, which then outputs this state as `<STATE_VCV>`.

The primary difference between the two diagrams lies in the specific order and combination logic within the "Prioritized State Selection" step, reflecting how the fuel pump's Volume Control Valve needs to behave differently depending on whether the system is "after Control phase" or "after Opening phase."


--- Page 212 ---

This page contains two Simulink-like diagrams (Figure 43.15.28 and Figure 43.15.29) which are expert automotive systems engineering models, likely from a model-based design environment like Simulink. Both diagrams are related to "FUSL, Fuel pressure actuator control".

---

## **Diagram 1: Figure 43.15.28 - State of the Pump Control after Start phase**

### Function
This diagram's primary function is to determine and output the current operating state (`<STATE_VCV>`) for the Fuel Pump's Volume Control Valve (VCV) after the engine has entered its start phase. It prioritizes various control requests to ensure the correct VCV state is selected.

### Inputs
*   `<LV_MFP_CTL_REQ>`: Mass Fuel Pressure Control Request (Boolean/Flag).
*   `<LV_VCV_OPEN_REQ>`: Volume Control Valve Open Request (Boolean/Flag).
*   `<LV_MFP_MAX_REQ>`: Mass Fuel Pressure Maximum Request (Boolean/Flag).
*   `<LV_VCV_TEST_REQ>`: Volume Control Valve Test Request (Boolean/Flag). *Note: This input appears to be used in two branches, one for `VCV_TEST` state and another for `MFP_START` state, implying either a diagram simplification, a specific design choice, or a potential typo in the diagram where the second instance might logically be a different request, e.g., `<LV_MFP_START_REQ>`.*
*   `MFP_CTL`: A constant value representing the VCV state for Mass Fuel Pressure Control mode.
*   `VCV_OPEN`: A constant value representing the VCV state for VCV Open mode.
*   `MFP_MAX`: A constant value representing the VCV state for Mass Fuel Pressure Maximum mode.
*   `VCV_TEST`: A constant value representing the VCV state for VCV Test mode.
*   `MFP_START`: A constant value representing the VCV state for Mass Fuel Pressure Start mode.
*   `STATE_VCV` (input to `Check ~= 0` blocks): Represents the default or current VCV state that is passed down if a higher-priority request is inactive.

### Outputs
*   `<STATE_VCV>`: The determined active state of the Volume Control Valve.

### Logic Flow
1.  **Request Evaluation:** The diagram processes five distinct control requests: `LV_MFP_CTL_REQ`, `LV_VCV_OPEN_REQ`, `LV_MFP_MAX_REQ`, `LV_VCV_TEST_REQ` (used twice for different states).
2.  **Prioritized State Selection (Individual `Check ~= 0` blocks):** Each of the five parallel branches contains a block labeled `Check ~= 0` (V.6.10). These blocks appear to act as conditional selectors (similar to a Simulink Switch block or a logic gate). Each block takes three inputs:
    *   A boolean request signal (e.g., `<LV_MFP_CTL_REQ>`).
    *   A specific constant state value (e.g., `MFP_CTL`).
    *   A `STATE_VCV` input, which represents a lower-priority or default state.
    *   It is likely that if the request signal (top input) is active (non-zero), the block outputs the associated state constant (middle input). If the request is inactive (zero), it passes through the `STATE_VCV` from its third input.
3.  **Final State Consolidation (`case: {}` block):** The outputs from all five `Check ~= 0` blocks (which are all potential candidate `STATE_VCV` values) converge into a `case: {}` block (V.6.10). This block acts as a Multiport Switch or a Stateflow Chart, selecting the single active `<STATE_VCV>` based on an inherent priority scheme (typically highest input port or a defined logic within the 'case' block). The order of inputs to this `case` block typically defines their priority.

---

## **Diagram 2: Figure 43.15.29 - Pump volume control calculation for 'control mode'**

### Function
This diagram's primary function is to calculate the required fuel pump performance parameters – specifically the actual mass fuel flow (`<MFP>`), the corresponding pump volume (`<PUMP_VOL_VCV>`), and the VCV closing range (`<VCV_CLOSE_RNG>`) – when the fuel pump is operating in a 'control mode'. It also derives a VCV inhibit signal.

### Inputs
*   `0`: A constant zero value, serving as the lower limit for saturation.
*   `<MFP_REQ>`: Requested Mass Fuel Pressure/Flow.
*   `<MFP_MAX>`: Maximum allowed Mass Fuel Pressure/Flow.
*   `<MFP_OFS>`: Mass Fuel Pressure/Flow Offset (a compensation value).
*   `IP_VCV_CLOSE_RNG`: A 1D lookup table (or a 1D interpolation block) which maps an input value (`x_val`) to a VCV closing range (`IP_val`). This represents a calibrated characteristic.

### Outputs
*   `<LV_VCV_INH_VCV>`: Volume Control Valve Inhibit Signal.
*   `<PUMP_VOL_VCV>`: Calculated Pump Volume for the VCV.
*   `<VCV_CLOSE_RNG>`: Calculated VCV Closing Range.
*   `<MFP>`: Calculated (actual) Mass Fuel Pressure/Flow.

### Logic Flow
1.  **Mass Fuel Pressure (MFP) Limiting:** The `<MFP_REQ>` (requested mass fuel flow) is passed through a Saturation block (V.7.7). This block ensures that `MFP_REQ` is constrained within a valid operating range, specifically between `0` (lower limit) and `<MFP_MAX>` (upper limit). The output of this block is `limited_mfp_req`.
2.  **Scaling for Pump Volume Calculation:** The `limited_mfp_req` is multiplied by a gain of `100` (V.6.11 block) to produce `scaled_mfp_req`.
3.  **Actual Mass Fuel Pressure (`<MFP>`) Calculation:** The `scaled_mfp_req` is added to `<MFP_OFS>` (Sum block, V.7.11). The result of this addition represents the final calculated `<MFP>`.
4.  **Pump Volume for VCV (`<PUMP_VOL_VCV>`) Calculation:** The `limited_mfp_req` and `scaled_mfp_req` are multiplied together (Product block, V.7.8). The result of this multiplication is assigned to `<PUMP_VOL_VCV>`. This suggests that the pump volume is a quadratic function of the limited mass fuel request, scaled.
5.  **VCV Closing Range (`<VCV_CLOSE_RNG>`) Calculation:** The calculated `<PUMP_VOL_VCV>` (output of V.7.8) serves as the input (`x_val`) to the 1D Lookup Table `IP_VCV_CLOSE_RNG` (V.6.8). The output (`IP_val`) of this lookup table, which provides the VCV closing range based on the pump volume, is assigned to `<VCV_CLOSE_RNG>`.
6.  **VCV Inhibit Signal (`<LV_VCV_INH_VCV>`) Derivation:** The calculated `<VCV_CLOSE_RNG>` (output of V.6.8) is directly passed through to `<LV_VCV_INH_VCV>`. This implies that the VCV closing range value directly determines or is equivalent to the VCV inhibit signal, or is subject to a simple passthrough/conversion.


--- Page 213 ---

This page contains Simulink-like diagrams.

## Function
The primary function of these diagrams is to define the control logic and output signals for a fuel pressure management system, specifically addressing two distinct operating modes for a fuel pump and its associated Volume Control Valve (VCV): a "minimum mode" (representing no pump activity or minimum fuel delivery) and a "maximum mode" (representing 100% fuel delivery or full pump performance). These blocks are part of a larger Fuel Pressure Actuator Control system (FUSL).

## Inputs
Across both diagrams, the key inputs are:
*   `<ECU_STATE>`: The current operational state of the Electronic Control Unit (ECU).
*   `SYN_ENG_IGK_ON`: A boolean or enumerated value indicating if the engine ignition is in the ON state.
*   `SYN_ENG_IGK_OFF`: A boolean or enumerated value indicating if the engine ignition is in the OFF state.
*   `<MFP_MAX>`: A value representing the maximum possible mass fuel flow.
*   `<MFP_OFS>`: An offset value applied to the mass fuel flow, likely for calibration or specific operating conditions.

## Outputs
Across both diagrams, the key outputs are:
*   `<LV_INH_VCV>`: A boolean signal (likely Low Voltage Inhibit VCV or Latch Value Inhibit VCV) that controls whether the Volume Control Valve is inhibited.
*   `<MFP>`: The commanded mass fuel pressure/flow or fuel pump demand.
*   `<PUMP_VOL_VCV>`: The commanded pump volume for the Volume Control Valve, typically a percentage or a raw control value.
*   `<VCV_CLOSE_RNG>`: The commanded closing range for the Volume Control Valve, indicating how much it should close to regulate pressure/flow.

## Logic Flow

The image presents two distinct logical flows for different pump control modes:

### Logic Flow for "minimum mode" (Figure 43.15.30)
This mode represents the case of "no pump activity".

1.  **Determine VCV Inhibit (`<LV_INH_VCV>`)**:
    *   The `<ECU_STATE>` is compared for equality with `SYN_ENG_IGK_ON`.
    *   Simultaneously, `<ECU_STATE>` is compared for equality with `SYN_ENG_IGK_OFF`.
    *   The results of these two equality checks are fed into an `OR` gate. This means if the ECU state is either `SYN_ENG_IGK_ON` *or* `SYN_ENG_IGK_OFF`, the `OR` gate output is true.
    *   The output of the `OR` gate is then inverted by a `NOT` gate.
    *   The final result of the `NOT` gate is assigned to `<LV_INH_VCV>`.
    *   **Interpretation**: The VCV is inhibited if the ECU state is *neither* `SYN_ENG_IGK_ON` *nor* `SYN_ENG_IGK_OFF`. This implies that in states outside of active engine ignition ON or OFF, the VCV should be inhibited to prevent pump activity.

2.  **Set Pump Volume, VCV Closing Range, and Mass Flow (`<PUMP_VOL_VCV>`, `<VCV_CLOSE_RNG>`, `<MFP>`)**:
    *   A constant value of `0` is directly assigned to `<PUMP_VOL_VCV>`.
    *   A constant value of `0` is directly assigned to `<VCV_CLOSE_RNG>`.
    *   A constant value of `0` is directly assigned to `<MFP>`.
    *   **Interpretation**: In this "minimum mode" (no pump activity), all key control outputs related to fuel delivery and VCV position are explicitly set to zero, effectively ensuring no fuel flow or pump operation.

### Logic Flow for "maximum mode" (Figure 43.15.31)
This mode represents a request for "maximum pump performance (100% delivery)".

1.  **Determine VCV Inhibit (`<LV_INH_VCV>`)**:
    *   A constant value of `0` is directly assigned to `<LV_INH_VCV>`.
    *   **Interpretation**: In "maximum mode," the VCV is explicitly commanded *not* to be inhibited (assuming `0` represents "false" or "not inhibited"), allowing the pump to operate at full capacity.

2.  **Calculate Mass Flow (`<MFP>`)**:
    *   The input `<MFP_MAX>` is added to the input `<MFP_OFS>` using a sum block.
    *   The result of this addition is assigned to `<MFP>`.
    *   **Interpretation**: The total mass fuel flow demand in maximum mode is determined by summing a maximum base value and an offset, suggesting fine-tuning of the "100% delivery" command.

3.  **Set Pump Volume and VCV Closing Range (`<PUMP_VOL_VCV>`, `<VCV_CLOSE_RNG>`)**:
    *   A constant value of `100` is directly assigned to `<PUMP_VOL_VCV>`.
    *   A constant value of `100` is used as the input (`x_val`) to a characteristic curve or 1D lookup table block labeled `IP_VCV_CLOSE_RNG`.
    *   The output of this `IP_VCV_CLOSE_RNG` block is assigned to `<VCV_CLOSE_RNG>`.
    *   **Interpretation**: In "maximum mode," the pump volume is set to 100 (likely representing 100% opening or command). The VCV closing range is determined by consulting a pre-defined characteristic curve, where an input of 100 yields the specific closing range required for maximum fuel delivery.


--- Page 214 ---

This page contains two Simulink-like diagrams, both related to "FUSL, Fuel pressure actuator control." The first, Figure 43.15.32, appears to be the primary control logic. The second, Figure 43.15.33, is explicitly described as "Pump volume control calculation for 'test mode'". I will analyze Figure 43.15.32 as the main diagram.

---

## Function
The primary function of this Simulink diagram (Figure 43.15.32) is to calculate and determine various control parameters for a fuel pressure actuator, specifically concerning a Volume Control Valve (VCV). It processes sensor inputs and calibration parameters to output the calculated Mass Fuel Pressure (`MFP`), the pump volume for the VCV, the VCV's closing range, and an inhibit status for the VCV. This system likely forms part of a larger engine management or fuel delivery control unit.

## Inputs
1.  **`t_VCV_IN_VALVE`**: An input signal, likely representing a time or factor related to the VCV's operation or fuel injection duration.
2.  **`PUMP_VOL_VCV` (input)**: An input signal representing the initial or desired pump volume for the Volume Control Valve.
3.  **`IP_val`**: An independent variable input used for indexing the VCV closing range lookup table.
4.  **`<MFP_MAX>`**: A parameter or signal representing the maximum allowable Mass Fuel Pressure.
5.  **`<MFP_OFS>`**: A parameter or signal representing an offset value used in the Mass Fuel Pressure calculation.
6.  **`0` (Constant)**: A constant value (zero), used in an addition with `<MFP_MAX>`.
7.  **`100` (Constant)**: A constant value, likely used for scaling or defining the x-axis range for the lookup table.

## Outputs
1.  **`<LV_INH_VCV>`**: A signal indicating the inhibited status of the Volume Control Valve (e.g., 0 for not inhibited, 1 for inhibited).
2.  **`<MFP>`**: The calculated Mass Fuel Pressure, which is a key control output.
3.  **`<PUMP_VOL_VCV>` (output)**: The processed or determined pump volume for the VCV. Note that a signal with the same name also appears as an input; this often implies the input value is passed through or modified by the block.
4.  **`<VCV_CLOSE_RNG>`**: The calculated closing range for the Volume Control Valve.

## Logic Flow

The diagram's logic flow can be broken down into parallel calculations that converge at a final selection block:

1.  **VCV Closing Range Calculation Path**:
    *   The `IP_val` input signal is fed into a 1-D Lookup Table block named `IP_VCV_CLOSE_RNG`. The `x_val` signal, derived from the constant `100`, likely defines the independent variable (x-axis) range or scaling for the lookup table.
    *   The lookup table uses `IP_val` to interpolate and produce an output signal named `V_VCV_CLOSE_RNG`.
    *   This `V_VCV_CLOSE_RNG` signal is then routed as one of the final outputs of the overall diagram, `<VCV_CLOSE_RNG>`, and is also used in the MFP calculation path.

2.  **Mass Fuel Pressure (`MFP`) Calculation Path**:
    *   The input signal `t_VCV_IN_VALVE` and the input signal `PUMP_VOL_VCV` are multiplied together using a multiplication block (`X`).
    *   The result of this multiplication is then added to the `V_VCV_CLOSE_RNG` signal (calculated in step 1) using a summation block (`+`).
    *   From this sum, the input parameter `<MFP_OFS>` is subtracted using a subtraction block (`-`).
    *   The resulting value (an intermediate MFP calculation) is then fed into the `case: {}` block for final processing.

3.  **Inhibit Logic Input Path**:
    *   The constant `0` and the input parameter `<MFP_MAX>` are added together using a summation block (`+`). The purpose of this specific sum, `0 + <MFP_MAX>`, is likely to pass `<MFP_MAX>` into the `case: {}` block for conditional use, perhaps as a threshold or a parameter in determining the inhibit status.

4.  **Final Output Selection and Processing (`case: {}` Block)**:
    *   All the calculated intermediate signals – the intermediate MFP value (from step 2), `V_VCV_CLOSE_RNG` (from step 1), the input `PUMP_VOL_VCV`, and the sum `(0 + <MFP_MAX>)` – are fed as inputs to a `case: {}` block.
    *   This `case: {}` block acts as a conditional selector or variant subsystem. Based on internal logic (which is not explicitly visible in this diagram, but often controlled by external conditions or mode selection, e.g., "test mode" as described for Figure 43.15.33), it determines and outputs the final values for:
        *   `<LV_INH_VCV>`
        *   `<MFP>`
        *   `<PUMP_VOL_VCV>` (potentially passing through or modifying the input `PUMP_VOL_VCV`)
        *   `<VCV_CLOSE_RNG>` (potentially passing through or modifying the `V_VCV_CLOSE_RNG` calculated earlier)

In essence, the diagram takes various operational parameters and calibration values, performs calculations for fuel pressure, pump volume, and valve range, and then uses a conditional block to output the final control signals for the fuel pressure actuator.


--- Page 215 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram describes the **Actuator Calculation for Currentless Open VCV (Volume Control Valve)**, which is part of a broader **Fuel Pressure Actuator Control (FUSL)** system. Its primary function is to calculate control parameters for a VCV, incorporating a "soft landing" mode for noise reduction and optimization of VCV wear. The logic differentiates between "currentless open" and "currentless close" scenarios based on an input condition, producing an appropriate VCV actuator control output.

## Inputs

1.  **`LV_VAR_HPP`**: A high-pressure pump variable or condition, acting as the primary selector for the conditional logic (determining whether to calculate for "open" or "close" mode).
2.  **`fc_hpp_cur_off_open`**: A parameter or signal specific to the "currentless open" mode calculation.
3.  **`fc_hpp_cur_off_close`**: A parameter or signal specific to the "currentless close" mode calculation.
4.  **`<VCV_CLOSE_RNG>`**: A parameter indicating the VCV's close range, used in both calculation paths.
5.  **`<STATE_VCV>`**: The current state of the VCV, used in both calculation paths.
6.  **`<input>` (to CLC_VCV_ACT_CUR_OFF_OPEN)**: A generic, unnamed input signal to the "currentless open" calculation block.
7.  **`<feedback>`**: A feedback signal specifically provided to the "currentless open" calculation block, suggesting a closed-loop aspect for this mode.
8.  **`<input>` (to CLC_VCV_ACT_CUR_OFF_CLOSE)**: A generic, unnamed input signal to the "currentless close" calculation block.
9.  **`V.6.6`**: An additional signal or value that is merged into the final output bus. Its origin is not fully depicted but could be a global parameter, a data store read, or a constant.

## Outputs

1.  **`clc_vcv_act`**: The main output of the diagram, which is a bus signal containing the calculated VCV actuator control parameters. This bus likely encapsulates components from both the "currentless open" and "currentless close" calculations, along with the `V.6.6` signal.

## Logic Flow

1.  **Conditional Selection:** The process begins with a `cond_if` block that evaluates the input signal `LV_VAR_HPP`. This acts as a decision point to select between two main operational modes:
    *   **If `LV_VAR_HPP` is true (or a specific condition is met):** The "if" branch is activated.
    *   **Else (if `LV_VAR_HPP` is false or the condition is not met):** The "else" branch is activated.

2.  **"Currentless Open" Calculation Path (if branch):**
    *   The `fc_hpp_cur_off_open` signal is passed as an input to the `CLC_VCV_ACT_CUR_OFF_OPEN` functional block (denoted as a function call `fc()`).
    *   This block also receives `<VCV_CLOSE_RNG>`, `<STATE_VCV>`, a generic `<input>`, and a `<feedback>` signal.
    *   Inside this block (a subsystem or function), complex calculations are performed to determine the VCV actuator parameters for the "currentless open" mode.
    *   The result of this calculation is the signal `clc_vcv_act_cur_off_open`.

3.  **"Currentless Close" Calculation Path (else branch):**
    *   The `fc_hpp_cur_off_close` signal is passed as an input to the `CLC_VCV_ACT_CUR_OFF_CLOSE` functional block (also denoted as a function call `fc()`).
    *   This block receives `<VCV_CLOSE_RNG>`, `<STATE_VCV>`, and another generic `<input>` signal.
    *   Similar to the "open" path, this block performs calculations specific to the VCV actuator parameters for the "currentless close" mode.
    *   The result of this calculation is the signal `clc_prm_vcv_act_off_close` (note: there might be a naming convention or a slight functional difference implied by `prm` compared to `cur_off` in the "open" path, or it could be a variant of `clc_vcv_act_cur_off_close`).

4.  **Output Merging:**
    *   The calculated output signals from both conditional branches (`clc_vcv_act_cur_off_open` and `clc_prm_vcv_act_off_close`) are fed into a `BusMerge` block.
    *   Additionally, the signal `V.6.6` is also input to the `BusMerge` block.
    *   The `BusMerge` block aggregates these individual signals into a single structured output, the bus `clc_vcv_act`. This bus represents the consolidated VCV actuator control parameters, which would then be used by subsequent control logic in the fuel pressure actuator system.


--- Page 216 ---

This page contains a Simulink-like diagram, which is a common representation for control system logic in automotive engineering.

## Function

The primary function of this diagram is the **calculation and selection of control current for a VCV (Valve Control Valve) actuator, specifically implementing a "soft landing" (SL) strategy**. This "soft landing" control aims to minimize noise and wear of the VCV, particularly at lower engine speeds (e.g., below 1000 rpm), by applying a carefully managed, often lower, current. The system selects between different control modes (closed-loop, open-loop, and various soft landing types) based on specific input conditions to determine the final actuator command.

## Inputs

The key inputs to this system are:

*   **`CLF_CUR_CTL_MOD_VCV`**: VCV Current Control Mode.
*   **`CLF_CUR_CTL_MOD_VCV_SL`**: VCV Current Control Mode for Soft Landing.
*   **`LC_SWI_VCV_TYP`**: A switch or selection signal for the VCV control type.
*   **`<STATE_VCV>`**: Represents the current state of the VCV, used by several internal function blocks.
*   **`<VCV_CLOSE_RNG>`**: Indicates a condition related to the VCV's closing range, used by internal function blocks.
*   **`<input>`**: Generic input signals to the various sub-function blocks (details not explicitly named but implied by the placeholders).
*   **`<feedback>`**: Feedback signals, likely related to current, position, or other VCV operational parameters, used by internal function blocks for closed-loop behavior.
*   **`clc_vcv_sl_off_open`**: A signal indicating a soft landing off/open condition, also fed into a function block.

## Outputs

The key outputs from this system are:

*   **`fc_vcv_cur_cll_ctl`**: Fuel Current VCV Current Closed-Loop Control (an intermediate selection).
*   **`fc_vcv_cur_opl_ctl`**: Fuel Current VCV Current Open-Loop Control (an intermediate selection).
*   **`fc_vcv_cur_cll_ctl_typ_1`**: Fuel Current VCV Current Closed-Loop Control Type 1 (an intermediate selection).
*   **`fc_vcv_cur_cll_ctl_typ_2`**: Fuel Current VCV Current Closed-Loop Control Type 2 (an intermediate selection).
*   **`clc_vcv_act_cur_off_open`**: The final, aggregated actuator command for VCV current, incorporating soft landing and off/open states, produced by the `BusMerge` block.

## Logic Flow

The logical flow can be broken down into the following steps:

1.  **Primary Control Mode Selection (Top `cond_if` block):**
    *   The system first compares `CLF_CUR_CTL_MOD_VCV` with `CLF_CUR_CTL_MOD_VCV_SL` using a greater-than `(>)` operator.
    *   Based on this comparison, an "If-Else" condition (`cond_if`) decides which current control signal to route:
        *   **If** `CLF_CUR_CTL_MOD_VCV` is greater, the system selects `fc_vcv_cur_cll_ctl` (Closed-Loop Control Current).
        *   **Else**, the system selects `fc_vcv_cur_opl_ctl` (Open-Loop Control Current).
    *   *Interpretation:* This likely determines whether the VCV operates in a standard closed-loop mode or a simpler open-loop mode, potentially related to whether the soft landing strategy is active or required.

2.  **VCV Control Sub-Type Selection (Lower `cond_if` block):**
    *   The `fc_vcv_cur_cll_ctl` signal (if selected in the previous step) is then compared with `LC_SWI_VCV_TYP`.
    *   Another "If-Else" condition (`cond_if`) uses this comparison to select between two different closed-loop control types:
        *   **If** `fc_vcv_cur_cll_ctl` is greater than `LC_SWI_VCV_TYP`, `fc_vcv_cur_cll_ctl_typ_1` (Closed-Loop Control Type 1) is selected.
        *   **Else**, `fc_vcv_cur_cll_ctl_typ_2` (Closed-Loop Control Type 2) is selected.
    *   *Interpretation:* This refines the closed-loop control, likely choosing between different soft landing current profiles or control algorithms based on specific VCV operating conditions or requirements defined by `LC_SWI_VCV_TYP`.

3.  **Soft Landing and Primary Actuation Calculations (Function Blocks):**
    *   Several function blocks (`f()` blocks with specific names and hierarchical paths like `X.2.1.2.2.3.1.1`) perform detailed calculations:
        *   `CLC_VCV_SL_OFF_OPEN`: Calculates signals related to VCV soft landing off/open states, using inputs such as `<STATE_VCV>`, `<VCV_CLOSE_RNG>`, and feedback.
        *   `CLC_VCV_CUR_CLL_CTL_TYP_1`: Calculates the specific current for Closed-Loop Control Type 1, based on its inputs including `<STATE_VCV>`, `<VCV_CLOSE_RNG>`, and feedback, and `fc_vcv_cur_cll_ctl_typ_1`.
        *   `CLC_VCV_CUR_CLL_CTL_TYP_2`: Calculates the specific current for Closed-Loop Control Type 2, similar to Type 1 but for the alternate mode, using `fc_vcv_cur_cll_ctl_typ_2`.
        *   `CLC_PRM_VCV_ACT_OFF_OPEN`: Calculates the primary VCV actuation signal for off/open conditions, using `<STATE_VCV>` and `<VCV_CLOSE_RNG>`.
        *   `CLC_VCV_CTL_DEACC`: Calculates a de-acceleration or deactivation control signal.
    *   *Interpretation:* These blocks encapsulate the complex logic for generating the actual current values or control signals for various operational states, including the specific "soft landing" current profiles that minimize noise and wear.

4.  **Final Actuator Command Merging (BusMerge):**
    *   All the derived control signals (`fc_vcv_cur_cll_ctl_typ_1`, `fc_vcv_cur_cll_ctl_typ_2`, `clc_vcv_sl_off_open`, `clc_prm_vcv_act`, `clc_vcv_ctl_deacc`, `fc_vcv_cur_opl_ctl` - potentially others are implicitly merged too) are gathered into a `BusMerge` block.
    *   This `BusMerge` block combines these individual signals into a single output bus.
    *   The final output, `clc_vcv_act_cur_off_open`, represents the complete, aggregated command to the VCV actuator, which will then interpret and apply the correct current based on the conditions encoded in the bus.
    *   *Interpretation:* This stage consolidates all the different control aspects (mode, type, soft landing, open/off conditions) into a structured command that the VCV actuator interface can use to precisely control the valve.


--- Page 218 ---

## Function
The primary function of this Simulink diagram (Figure 43.15.37) is to **coordinate and authorize the Variable Camshaft/Valve (VCV) soft landing functionality** for a fuel pressure actuator control system. It calculates authorizations for VCV soft landing based on various environmental conditions, the current VCV Soft Landing (SL) status, and system working points. The goal is to ensure a controlled transition (soft landing) during VCV closing and/or opening operations, preventing harsh impacts or rapid changes. The diagram depicts how coordinated and adapted soft landing commands are processed to generate a final enable/disable signal for this functionality.

## Inputs
The key inputs to the system, as shown in Figure 43.15.37, are:

*   **`STATE_VCV`**: Represents the current operational state of the overall VCV system.
*   **`<input>`**: General input signals required by the `CLC_VCV_SL_CORD` and `CLC_VCV_CLOSE_SL_AD` subsystems. These are generic labels in the diagram but represent specific control parameters or sensor readings.
*   **`<feedback>`**: General feedback signals for the `CLC_VCV_SL_CORD` and `CLC_VCV_CLOSE_SL_AD` subsystems, likely used for closed-loop adjustments or state confirmation.
*   **`clc_vcv_close_sl_cord`**: A commanded soft landing closure value, derived from the `CLC_VCV_SL_CORD` subsystem. This acts as both an input to the adaptation logic and a direct feed to the final output stage.
*   **`clc_vcv_close_sl_ad`**: An adapted soft landing closure value, derived from the `CLC_VCV_CLOSE_SL_AD` subsystem. This value incorporates environmental conditions and system working points.

## Outputs
The primary output of the system, as depicted in Figure 43.15.37, is:

*   **`clc_vcv_sl_off_open`**: This signal determines the operational state of the VCV soft landing functionality, typically indicating whether it is "off" (disabled) or "open" (enabled/active).

## Logic Flow
The logical flow of the VCV soft landing coordination, as illustrated in Figure 43.15.37, proceeds as follows:

1.  **Coordination Subsystem (`CLC_VCV_SL_CORD`):**
    *   This subsystem receives `STATE_VCV`, generic `<input>`, and `<feedback>` signals.
    *   It processes these inputs to calculate and output `clc_vcv_close_sl_cord`. This signal represents the "coordinated" soft landing command or status, derived from fundamental system requirements and overall operating conditions.

2.  **Adaptation Subsystem (`CLC_VCV_CLOSE_SL_AD`):**
    *   This subsystem takes the `clc_vcv_close_sl_cord` signal from the coordination block as an input, along with its own generic `<input>` and `<feedback>` signals.
    *   It performs adaptation calculations, adjusting the soft landing behavior based on specific environmental conditions, learned parameters, or system working points.
    *   The output of this subsystem is `clc_vcv_close_sl_ad`, which represents the "adapted" soft landing command or status for VCV closure.

3.  **Signal Aggregation and Final Processing:**
    *   Both the `clc_vcv_close_sl_cord` and `clc_vcv_close_sl_ad` signals are fed into intermediary blocks (labeled `V.6.8`, likely Bus Creators or similar grouping blocks).
    *   The outputs of these `V.6.8` blocks are then combined by a `BusMerge` block (`V.6.6`). This aggregates the individual soft landing commands into a single bus signal.
    *   The merged bus, along with a direct connection of `clc_vcv_close_sl_cord` (which bypasses the `BusMerge` and directly feeds into the final processing stage), is then fed into another block (also labeled `V.6.8`). This block acts as a final decision or selection logic unit.
    *   This final `V.6.8` block processes the combined information from the bus and the direct `clc_vcv_close_sl_cord` signal. The direct connection of `clc_vcv_close_sl_cord` suggests that the initial coordinated value might have a primary or overriding role in the final decision, ensuring a baseline behavior.
    *   Finally, this block generates the `clc_vcv_sl_off_open` output, which is the ultimate command to enable or disable the VCV soft landing functionality.

This intricate flow ensures that VCV soft landing operations are precisely controlled, factoring in both baseline coordination and real-time adaptation for optimal system performance and durability.


--- Page 219 ---

This page contains a Simulink-like block diagram.

## Function
The primary function of this Simulink diagram, titled "FUSL, Fuel pressure actuator control," is to determine the authorization for various "Soft Landing" (SL) operations of a Volume Control Valve (VCV) in a fuel pressure system. Specifically, it calculates authorizations for VCV Open Soft Landing, VCV Close Soft Landing, and Adaptive VCV Close Soft Landing based on a comprehensive set of environmental, engine, and system parameters. The logic ensures that VCV soft landing modes are enabled only when specific conditions are met to maintain system stability and performance.

## Inputs
The diagram receives the following key inputs from the surrounding system:

*   **`STATE_VCV`**: Current operating state of the Volume Control Valve.
*   **`N_32`**: Engine speed (e.g., in RPM).
*   **`FUP_DIF`**: Fuel pressure deviation (difference from target pressure).
*   **`TCO`**: Coolant temperature.
*   **`T_AST`**: Time elapsed since engine start.
*   **`VB`**: Battery voltage.
*   **`LV_VCV_SL_ENA`**: Master enable signal for VCV Soft Landing (a boolean flag).
*   **`STATE_VCV_CLOSE_SL`**: Specific state information related to VCV Close Soft Landing.
*   **`CTR_FUP_DIF_VCV_CLOSE_SL_AUTH`**: Counter related to fuel pressure deviation authorization for VCV Close SL, possibly for hysteresis or delay.
*   **`CTR_FUP_DIF_HYS_MAX_AUTH`**: Counter related to the maximum hysteresis for fuel pressure deviation authorization.
*   **`FUP_SP_GRD_SEG`**: Fuel pump speed grade segment.
*   **`R_VCV`**: Resistance of the VCV (or a related component).
*   **`LV_IS`**: A generic Load Value or Internal Status indicator.
*   **`VB_VCV_CLOSE_SL_AD_ST`**: Status of battery voltage specific to VCV Close SL Adaptive control.
*   **`R_VCV_CLOSE_SL_AD_ST`**: Status of VCV resistance specific to VCV Close SL Adaptive control.
*   **`LV_VCV_CLOSE_SL_AD_AUTH`**: Authorization for VCV Close Soft Landing Adaptive (appears as an input to the first block, indicating a possible feedback or dependency on its current/previous state).
*   **`LV_VCV_CLOSE_SL_AD_RST`**: Reset signal for VCV Close Soft Landing Adaptive (similar to the above, indicating feedback or dependency).
*   **`T_VCV_CLOSE_SL_AD_VLD`**: Validity flag for temperature conditions specific to VCV Close SL Adaptive (similar to the above, indicating feedback or dependency).

## Outputs
The diagram produces a bus of control and authorization signals for VCV Soft Landing, which are merged into a single bus:

*   **`LV_VCV_OPEN_SL_AUTH`**: Authorization for VCV Open Soft Landing.
*   **`LV_VCV_CLOSE_SL_AUTH`**: Authorization for VCV Close Soft Landing.
*   **`LV_VCV_CLOSE_SL_AD_AUTH`**: Authorization for VCV Close Soft Landing Adaptive.
*   **`LV_VCV_CLOSE_SL_AD_RST`**: Reset signal for VCV Close Soft Landing Adaptive.
*   **`LV_VCV_CLOSE_SL_AD_REQ`**: Request signal for VCV Close Soft Landing Adaptive.
*   **`T_VCV_CLOSE_SL_AD_VLD`**: Validity flag for temperature conditions specific to VCV Close SL Adaptive.
*   **`CLC_VCV_SL_CTL`**: A bus that aggregates all the above individual authorization and control signals.

## Logic Flow

The diagram comprises two main functional subsystems, `CLC_VCV_SL_AUTH` and `CLC_VCV_CLOSE_SL_AD_AUTH`, which process inputs to generate the VCV soft landing control bus.

1.  **General VCV Soft Landing Authorization (`CLC_VCV_SL_AUTH`):**
    *   This subsystem (identified as `X.2.1.2.2.3.1.1.1.1`) is responsible for calculating the primary authorizations for VCV Open and Close Soft Landing (`LV_VCV_OPEN_SL_AUTH`, `LV_VCV_CLOSE_SL_AUTH`).
    *   It takes a broad range of inputs, including system states (`STATE_VCV`), engine parameters (`N_32`, `TCO`, `T_AST`), fuel system parameters (`FUP_DIF`), and electrical system parameters (`VB`). It also considers a master enable (`LV_VCV_SL_ENA`) and feedback from the adaptive logic (`LV_VCV_CLOSE_SL_AD_AUTH`, `LV_VCV_CLOSE_SL_AD_RST`).
    *   **Decision Logic (based on accompanying text):**
        *   **After Start Time:** Soft Landing is enabled only after a calibratable time (`C_T_AST_VCV_SL_MIN`) following engine start, ensuring VCV control has stabilized.
        *   **Battery Voltage:** Sufficient battery voltage (`VB`) is required, checked against a minimum threshold (`C_VB_VCV_SL_MIN`). Low voltage might extend VCV actuation pulse duration.
        *   **Coolant Temperature:** `TCO` must be within calibrated minimum and maximum thresholds (`C_TCO_VCV_SL_MIN` and `C_TCO_VCV_SL_MAX`) to avoid SL in extreme temperatures.
        *   **Engine Speed (for VCV Close SL):** VCV Close SL is authorized if engine speed (`N_32`) is within a specific range, i.e., below `C_N_VCV_CLOSE_SL_HYS_MIN` and not above `C_N_VCV_CLOSE_SL_HYS_MAX`. This accounts for pump period considerations at higher speeds.
        *   **Fuel Pressure Deviation (for VCV Close SL):** VCV Close SL is authorized only if fuel pressure deviation (`FUP_DIF`) is within a hysteresis band, specifically below `C_FUP_DIF_VCV_CLOSE_SL_HYS_MIN` and not above `C_FUP_DIF_VCV_CLOSE_SL_HYS_MAX`, to prevent interference with fuel pressure control. Counters (`CTR_FUP_DIF...`) likely manage the hysteresis or introduce delays for stability.
    *   These conditions are logically combined (e.g., using AND/OR gates or state machine logic within the block) to derive the `LV_VCV_OPEN_SL_AUTH` and `LV_VCV_CLOSE_SL_AUTH` signals.

2.  **Adaptive VCV Close Soft Landing Authorization (`CLC_VCV_CLOSE_SL_AD_AUTH`):**
    *   This subsystem (identified as `X.2.1.2.2.3.1.1.1.2`) focuses on the adaptive aspects of VCV Close Soft Landing.
    *   It takes `LV_VCV_CLOSE_SL_AUTH` (from the first block), specific engine/fuel parameters (`N_32`, `FUP_DIF`, `FUP_SP_GRD_SEG`), sensor information (`R_VCV`, `LV_IS`), and status signals (`VB_VCV_CLOSE_SL_AD_ST`, `R_VCV_CLOSE_SL_AD_ST`) as inputs. It also likely has internal feedback mechanisms as `T_VCV_CLOSE_SL_AD_VLD` appears as both an input and an output.
    *   Based on these inputs, this block calculates the specific `LV_VCV_CLOSE_SL_AD_AUTH` (adaptive authorization), `LV_VCV_CLOSE_SL_AD_RST` (reset for adaptive mode), and `LV_VCV_CLOSE_SL_AD_REQ` (request for adaptive mode). It also generates `T_VCV_CLOSE_SL_AD_VLD` to indicate temperature validity for this adaptive mode. This block refines the general `CLOSE_SL_AUTH` by adding more granular, adaptive control logic.

3.  **Bus Aggregation (`BusMerge`):**
    *   All the individual authorization and control signals generated by the two subsystems (`LV_VCV_OPEN_SL_AUTH`, `LV_VCV_CLOSE_SL_AUTH`, `LV_VCV_CLOSE_SL_AD_AUTH`, `LV_VCV_CLOSE_SL_AD_RST`, `LV_VCV_CLOSE_SL_AD_REQ`, `T_VCV_CLOSE_SL_AD_VLD`) are fed into a `BusMerge` block.
    *   This block bundles these distinct signals into a single structured data type, `CLC_VCV_SL_CTL`, for simplified interface management and communication to other parts of the fuel pressure actuator control system.


--- Page 221 ---

This page clearly displays a Simulink diagram. The diagram outlines a control strategy for a fuel pressure actuator, likely a Volume Control Valve (VCV), based on various engine, environmental, and fuel system parameters.

---

## Function

The primary function of this Simulink diagram is to calculate and output authorization flags for the "close" and "open" operations of a fuel pressure actuator, specifically referred to as a Volume Control Valve (VCV). This control logic is designed to ensure the VCV operates only under permissible conditions, considering engine speed, fuel pressure difference, temperatures, battery voltage, and overall system enablement. It incorporates hysteresis and time delays for stable operation and includes counter-based authorization signals, potentially for fault management or mode transitions.

---

## Inputs

The diagram receives a variety of inputs, which can be categorized as follows:

**Dynamic System States/Measurements:**
*   `STATE_VCV`: Current operational state of the Volume Control Valve.
*   `T_AST`: Ambient temperature.
*   `VB`: Battery voltage.
*   `TCO`: Coolant temperature.
*   `<N_32>`: Engine speed.
*   `<FUP_DIF>`: Fuel pressure difference.
*   `<STATE_VCV_CLOSE_SL>`: Specific state variable related to the VCV's closing slide.

**Control/Enable Signals:**
*   `LV_VCV_SL_ENA`: General enable signal for the VCV slide mechanism.
*   `MFP_CTL`: Reference or target control value for `STATE_VCV`.
*   `LV_VCV_CLOSE_SL_AD_RST`: Adaptive reset signal for the VCV close logic.
*   `LV_VCV_OPEN_SL_AD_RST`: Adaptive reset signal for the VCV open logic.

**Calibration Parameters/Thresholds:**
*   `C_T_AST_VCV_SL_MIN`: Minimum ambient temperature for VCV slide authorization.
*   `C_VB_VCV_SL_MIN`: Minimum battery voltage for VCV slide authorization.
*   `C_TCO_VCV_SL_MAX`: Maximum coolant temperature for VCV slide authorization.
*   `C_TCO_VCV_SL_MIN`: Minimum coolant temperature for VCV slide authorization.
*   `C_N_VCV_CLOSE_SL_HYS_MIN`/`MAX`: Hysteresis band (min/max) for engine speed when closing the VCV.
*   `C_FUP_DIF_VCV_CLOSE_SL_HYS_MIN`/`MAX`: Hysteresis band (min/max) for fuel pressure difference when closing the VCV.
*   `C_T_DLY_VCV_CLOSE_SL_AUTH`: Delay time for VCV close authorization.
*   `C_CTR_FUP_DIF_VCV_SL_AUTH_MAX`: Maximum count for the fuel pressure difference counter (used for both close and open).
*   `C_N_VCV_OPEN_SL_HYS_MIN`/`MAX`: Hysteresis band (min/max) for engine speed when opening the VCV.
*   `C_FUP_DIF_VCV_OPEN_SL_HYS_MIN`/`MAX`: Hysteresis band (min/max) for fuel pressure difference when opening the VCV.
*   `C_T_DLY_VCV_OPEN_SL_AUTH`: Delay time for VCV open authorization.
*   `C_STATE_VCV_CLOSE_SL_OPEN_AUTH`: Threshold for VCV close slide state to enable VCV open authorization.

---

## Outputs

The diagram generates the following key output signals:

*   `LV_VCV_CLOSE_SL_AUTH`: A boolean flag indicating authorization for the VCV to transition to a closed state.
*   `CTR_FUP_DIF_VCV_CLOSE_SL_AUTH`: A counter-based authorization or status flag related to fuel pressure difference conditions for VCV closing.
*   `LV_VCV_OPEN_SL_AUTH`: A boolean flag indicating authorization for the VCV to transition to an open state.
*   `CTR_FUP_DIF_VCV_OPEN_SL_AUTH`: A counter-based authorization or status flag related to fuel pressure difference conditions for VCV opening.

---

## Logic Flow

The logical flow can be broken down into several main sections:

1.  **General VCV Slide Authorization (`[lv_vcv_sl_auth]`)**:
    *   This section determines a master enable for all subsequent VCV slide operations.
    *   It first checks if `STATE_VCV` matches `MFP_CTL` using an equality comparator.
    *   It then verifies if `T_AST` (ambient temperature) is greater than `C_T_AST_VCV_SL_MIN`.
    *   Similarly, `VB` (battery voltage) must be greater than `C_VB_VCV_SL_MIN`.
    *   `TCO` (coolant temperature) is checked to be within a range: greater than `C_TCO_VCV_SL_MIN` AND less than `C_TCO_VCV_SL_MAX`. This is achieved by separate comparisons and then potentially combined or using a Min/Max block effectively.
    *   Finally, the external enable signal `LV_VCV_SL_ENA` must be active.
    *   All these individual conditions are combined using an `AND` logic gate. The output `[lv_vcv_sl_auth]` becomes true only if all prerequisites are met.

2.  **VCV Close Authorization (`LV_VCV_CLOSE_SL_AUTH`)**:
    *   This part calculates the authorization to close the VCV, based on engine speed and fuel pressure difference, with hysteresis and time delays.
    *   **Engine Speed (`N_32`) Condition:**
        *   `N_32` is fed into a Hysteresis Latch (LSP/RSP block) with thresholds `C_N_VCV_CLOSE_SL_HYS_MIN` (Latch Set Point, LSP) and `C_N_VCV_CLOSE_SL_HYS_MAX` (Reset Set Point, RSP). This prevents rapid toggling if `N_32` hovers near a single threshold.
        *   The output of the hysteresis latch (`x_out`) is inverted by a `NOT` gate.
        *   This inverted signal is then `AND`ed with the general VCV authorization `[lv_vcv_sl_auth]` and a specific parameter `C_T_DLY_VCV_CLOSE_SL_AUTH` (likely representing a timed enable).
        *   The result is passed through a Timer (`T` block with `dT=0.01`). This block acts as a delay-on, immediate-off timer, ensuring the condition is stable for at least 0.01 seconds before the output `[lv_n_vcv_close_hys]` becomes active.
    *   **Fuel Pressure Difference (`FUP_DIF`) Condition:**
        *   `FUP_DIF` undergoes a similar process using a Hysteresis Latch with `C_FUP_DIF_VCV_CLOSE_SL_HYS_MIN`/`MAX`.
        *   Its inverted output is `AND`ed with `[lv_vcv_sl_auth]` and `C_T_DLY_VCV_CLOSE_SL_AUTH`.
        *   The result is passed through another Timer (`T` block) to produce `[lv_fup_dif_vcv_close_hys]`.
    *   **Combined Close Authorization Logic:**
        *   The `LV_VCV_CLOSE_SL_AUTH` output is derived from an `OR` gate. Its inputs include:
            *   A condition checking `0 > [lv_fup_dif_vcv_close_hys]`.
            *   The `LV_VCV_CLOSE_SL_AD_RST` signal (an external reset or override).
            *   An intermediate signal from the counter logic (`CTR_FUP_DIF_VCV_SL_AUTH_MAX`). This structure implies that if any of these conditions are met, closing is authorized.

3.  **VCV Close Counter Authorization (`CTR_FUP_DIF_VCV_CLOSE_SL_AUTH`)**:
    *   This logic likely involves a counter mechanism related to the `FUP_DIF` conditions for closing.
    *   A `+1` block suggests an incrementing counter. This counter is influenced by `0 > [lv_fup_dif_vcv_close_hys]`, `LV_VCV_CLOSE_SL_AD_RST`, and a signal derived from `C_CTR_FUP_DIF_VCV_SL_AUTH_MAX` via an `OR` gate.
    *   The output `CTR_FUP_DIF_VCV_CLOSE_SL_AUTH` likely indicates if a specific count threshold or condition related to fuel pressure difference has been met for VCV closing.

4.  **VCV Open Authorization (`LV_VCV_OPEN_SL_AUTH`)**:
    *   This section largely mirrors the VCV Close Authorization logic but with parameters and conditions specific to opening the valve.
    *   **Engine Speed (`N_32`) Condition (for Open):** Similar hysteresis (using `C_N_VCV_OPEN_SL_HYS_MIN`/`MAX`), `NOT` gate, `AND` gate with `[lv_vcv_sl_auth]` and `C_T_DLY_VCV_OPEN_SL_AUTH`, and a Timer block lead to `[lv_n_vcv_open_hys]`.
    *   **Fuel Pressure Difference (`FUP_DIF`) Condition (for Open):** Similar hysteresis (using `C_FUP_DIF_VCV_OPEN_SL_HYS_MIN`/`MAX`), `NOT` gate, `AND` gate with `[lv_vcv_sl_auth]` and `C_T_DLY_VCV_OPEN_SL_AUTH`, and a Timer block lead to `[lv_fup_dif_vcv_open_hys]`.
    *   **Combined Open Authorization Logic:** Similar to the close logic, an `OR` gate combines conditions, including `0 > [lv_fup_dif_vcv_open_hys]`, `LV_VCV_OPEN_SL_AD_RST`, and the counter output.
    *   An additional path directly feeds the result of `STATE_VCV_CLOSE_SL > C_STATE_VCV_CLOSE_SL_OPEN_AUTH` into `LV_VCV_OPEN_SL_AUTH`, suggesting an alternative or override condition for opening authorization based on the VCV close slide state.

5.  **VCV Open Counter Authorization (`CTR_FUP_DIF_VCV_OPEN_SL_AUTH`)**:
    *   This section is analogous to the VCV Close Counter Authorization, but monitors `FUP_DIF` conditions relevant to opening the VCV and produces `CTR_FUP_DIF_VCV_OPEN_SL_AUTH` based on a counter reaching `C_CTR_FUP_DIF_VCV_SL_AUTH_MAX`.

In summary, the diagram meticulously processes sensor data and control parameters through chained logical operations, hysteresis, and time delays to generate robust authorization signals for controlling the fuel pressure actuator's opening and closing actions, crucial for precise fuel system management in an automotive context.


--- Page 223 ---

This page contains a Simulink-like diagram, likely representing control logic for an automotive system.

## Function

This Simulink diagram's primary function is to determine the authorization, activation status, reset conditions, validation, and ultimate request for a "Soft Landing" (SL) adaptation during the closing phase of a "VCV" (Valve Control Valve), specifically within a fuel pressure actuator control system. The "soft landing" aims for a controlled, gradual closure of the valve, and this logic handles the conditions under which this adaptation is enabled, active, reset, valid, and requested.

## Inputs

The diagram uses various signals and parameters as inputs. Green-colored blocks generally represent input signals or parameters, while constants are numerical values directly in blocks.

*   `C_T_DLY_VCV_CLOSE_SL_AD_AUTH`: Time delay constant for VCV close SL adaptation authorization.
*   `<LV_VCV_CLOSE_SL_AUTH>`: Authorization status of VCV close SL adaptation (also an output, implying a feedback loop or internal state).
*   `<LV_IS>`: Current (or similar electrical quantity) signal.
*   `<N_32>`: Engine speed or similar rotational frequency signal.
*   `C_N_MAX_VCV_SL_AD_AUTH`: Maximum `N` (e.g., RPM) for VCV SL adaptation authorization.
*   `<FUP_SP_GRD_SEG>`: Fuel Pressure (FUP) related signal, possibly a setpoint or ground segment.
*   `C_FUP_SP_GRD_VCV_SL_AD_AUTH`: Constant for `FUP_SP_GRD` VCV SL adaptation authorization.
*   `<FUP_DIF>`: Differential Fuel Pressure signal.
*   `C_FUP_DIF_VCV_SL_AD_AUTH`: Constant for differential `FUP` VCV SL adaptation authorization.
*   `<STATE_VCV_CLOSE_SL>`: Current operational state of the VCV closing soft landing.
*   `AD_PWM`: State value corresponding to adaptation of duty-cycle for VCV holding phase (state 2 from accompanying text).
*   `AD_T_DUR`: State value corresponding to adaptation of pull-in time for VCV peak phase (state 3 from accompanying text).
*   `AD_ON`: State value corresponding to soft landing active with default parameters (state 1 from accompanying text).
*   `<VB>`: Battery voltage or supply voltage.
*   `<VB_VCV_CLOSE_SL_AD_ST>`: Stored/reference battery voltage for VCV close SL adaptation.
*   `C_VB_DIF_MAX_CLOSE_SL_RST_AD`: Maximum differential voltage for soft landing reset (adaptation).
*   `C_VB_DIF_MAX_CLOSE_SL_RST`: Maximum differential voltage for soft landing reset (general).
*   `<R_VCV>`: Resistance of the VCV valve.
*   `<R_VCV_CLOSE_SL_AD_ST>`: Stored/reference resistance for VCV close SL adaptation.
*   `C_R_DIF_MAX_CLOSE_SL_RST_AD`: Maximum differential resistance for soft landing reset (adaptation).
*   `C_CTR_FUP_DIF_HYS_MAX_AUTH`: Maximum hysteresis counter for FUP differential authorization (connection not fully visible to an output in this image).
*   `<T_VCV_CLOSE_SL_AD_VLD>`: VCV close SL adaptation temperature valid flag (also an output, implying feedback or internal state).
*   `C_T_MAX_VCV_CLOSE_SL_AD_VLD`: Maximum temperature for VCV close SL adaptation valid.
*   `C_VB_DIF_MAX_VCV_CLOSE_SL_REQ`: Maximum differential voltage for VCV close SL request.
*   `C_R_DIF_MAX_VCV_CLOSE_SL_REQ`: Maximum differential resistance for VCV close SL request.

## Outputs

The blue-colored blocks represent the key outputs of this logic.

*   `<LV_VCV_CLOSE_SL_AD_AUTH>`: Boolean flag indicating if the VCV Close Soft Landing Adaptation is authorized.
*   `lv_vcv_close_sl_ad_act`: Internal boolean flag indicating if VCV Close Soft Landing Adaptation is currently active based on system state.
*   `lv_vcv_close_sl_ad_act_rst`: Internal boolean flag indicating if VCV Close Soft Landing Adaptation is active for reset purposes.
*   `<LV_VCV_CLOSE_SL_AD_RST>`: Boolean flag indicating if the VCV Close Soft Landing Adaptation is in a reset state.
*   `<T_VCV_CLOSE_SL_AD_VLD>`: Boolean flag indicating if the VCV Close Soft Landing Adaptation is valid, likely temperature-wise or timed.
*   `<LV_VCV_CLOSE_SL_AD_REQ>`: Boolean flag indicating if a VCV Close Soft Landing Adaptation request is active.

## Logic Flow

The logic flow can be broken down into several interconnected sections:

**1. Soft Landing Authorization (`<LV_VCV_CLOSE_SL_AD_AUTH>`):**
    *   **Fuel Pressure (FUP) Conditions:**
        *   The current `FUP_SP_GRD_SEG` is compared (less than) to `C_FUP_SP_GRD_VCV_SL_AD_AUTH`.
        *   The `FUP_DIF` is compared (less than) to `C_FUP_DIF_VCV_SL_AD_AUTH`.
    *   **Engine Speed (N) and Current (IS) Conditions:**
        *   `<LV_IS>` is compared (less than) to `<N_32>`.
        *   `<N_32>` is compared (less than) to `C_N_MAX_VCV_SL_AD_AUTH`.
    *   **Combined Authorization Logic:** The outputs of these comparisons, along with `C_T_DLY_VCV_CLOSE_SL_AD_AUTH` and the feedback `<LV_VCV_CLOSE_SL_AD_AUTH>`, feed into an `AND` gate. This `AND` gate's output then passes through a timed logic block (appears to be a discrete-time element with `dT=0.01` and feedback `1/z`) to produce the final `<LV_VCV_CLOSE_SL_AD_AUTH>` output. This block likely acts as a debouncer or accumulator, requiring conditions to be met for a certain duration before authorization is granted.

**2. Soft Landing Active Status (`lv_vcv_close_sl_ad_act` and `lv_vcv_close_sl_ad_act_rst`):**
    *   The `<STATE_VCV_CLOSE_SL>` signal is checked for equality against `AD_PWM`, `AD_T_DUR`, and `AD_ON`.
    *   If `STATE_VCV_CLOSE_SL` matches any of these, `lv_vcv_close_sl_ad_act` becomes true (via two `OR` gates). This signifies that the soft landing adaptation is active if the system is in one of the specific adaptation states.
    *   Similarly, `lv_vcv_close_sl_ad_act_rst` is derived from `STATE_VCV_CLOSE_SL` being compared to other (partially obscured) states, indicating an active state for reset purposes.

**3. Soft Landing Reset Conditions (`<LV_VCV_CLOSE_SL_AD_RST>`):**
    *   **Voltage (VB) Reset Conditions:**
        *   The difference between `<VB>` and `<VB_VCV_CLOSE_SL_AD_ST>` is compared (greater than) with `C_VB_DIF_MAX_CLOSE_SL_RST_AD` and `C_VB_DIF_MAX_CLOSE_SL_RST`.
        *   `<VB_VCV_CLOSE_SL_AD_ST>` is checked to be non-zero.
        *   These conditions, along with `lv_vcv_close_sl_ad_act`, feed into an `OR` gate.
    *   **Resistance (R_VCV) Reset Conditions:**
        *   The difference between `<R_VCV>` and `<R_VCV_CLOSE_SL_AD_ST>` is compared (greater than) with `C_R_DIF_MAX_CLOSE_SL_RST_AD`.
        *   `<R_VCV_CLOSE_SL_AD_ST>` is checked to be non-zero.
        *   These conditions, along with `lv_vcv_close_sl_ad_act`, feed into the same `OR` gate as the VB conditions.
    *   **Final Reset Logic:** The output of this `OR` gate is then combined with `lv_vcv_close_sl_ad_act_rst` via an `AND` gate to produce `<LV_VCV_CLOSE_SL_AD_RST>`. This indicates a reset is active if certain voltage/resistance deviations or states are met, AND the system is in an "active for reset" state.

**4. Soft Landing Validation (`<T_VCV_CLOSE_SL_AD_VLD>`):**
    *   This output is derived from a "Check ~= 0" block, which means it is true if its input (partially obscured, but likely temperature-related or a counter result like `C_CTR_FUP_DIF_HYS_MAX_AUTH`) is non-zero. This suggests a temperature-based or timed validation.
    *   It also involves a comparison of `<T_VCV_CLOSE_SL_AD_VLD>` (feedback) with `C_T_MAX_VCV_CLOSE_SL_AD_VLD`, which contributes to the request logic.

**5. Soft Landing Request (`<LV_VCV_CLOSE_SL_AD_REQ>`):**
    *   **Voltage (VB) Request Conditions:** The difference between `<VB>` and `<VB_VCV_CLOSE_SL_AD_ST>` is compared (greater than) with `C_VB_DIF_MAX_VCV_CLOSE_SL_REQ`.
    *   **Resistance (R_VCV) Request Conditions:** The difference between `<R_VCV>` and `<R_VCV_CLOSE_SL_AD_ST>` is compared (greater than) with `C_R_DIF_MAX_VCV_CLOSE_SL_REQ`.
    *   **Combined Request Logic:** The outputs of these two '>' comparisons are combined via an `OR` gate. This `OR` gate's output, along with `<LV_VCV_CLOSE_SL_AD_RST>` and `<T_VCV_CLOSE_SL_AD_VLD>`, feeds into a final `AND` gate to produce `<LV_VCV_CLOSE_SL_AD_REQ>`.
    *   Therefore, a soft landing adaptation request is issued if:
        *   (Voltage difference exceeds `C_VB_DIF_MAX_VCV_CLOSE_SL_REQ` OR Resistance difference exceeds `C_R_DIF_MAX_VCV_CLOSE_SL_REQ`)
        *   AND the `<LV_VCV_CLOSE_SL_AD_RST>` signal is true (interpreting it as "reset conditions are met for allowing a request," or that the reset condition is *not* active, depending on signal convention).
        *   AND the `<T_VCV_CLOSE_SL_AD_VLD>` (temperature/time valid) signal is true.


--- Page 225 ---

This page contains a Simulink-like diagram.

## Function

This Simulink diagram is a control logic module, likely part of a broader "Fuel Pressure Actuator Control" system as indicated by the "FUSL" header. Its primary function is to manage and determine the state of "Soft Landing Adaptation" during a "VCV Close" event. This involves calculating when the adaptation process should end or wait, and then transitioning through various adaptation states such as 'Off', 'Static', 'Adaptation On', 'Adaptation PWM', and 'Adaptation Time Duration'. The "soft landing" implies a controlled, smooth transition or operation to prevent abrupt changes or oscillations in fuel pressure control.

## Inputs

The key inputs to this system are:

*   **`<CTR_VCV_CLOSE_SL_AD>`**: A counter for the VCV Close Soft Landing Adaptation process, indicating its progress.
*   **`C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR`**: Calibrated maximum counter value for the Time Duration aspect of VCV Close Soft Landing Adaptation.
*   **`C_CTR_MAX_VCV_CLOSE_SL_AD_PWM`**: Calibrated maximum counter value for the PWM (Pulse Width Modulation) aspect of VCV Close Soft Landing Adaptation.
*   **`<LV_VCV_CLOSE_SL_AUTH>`**: A boolean flag indicating if VCV Close Soft Landing Adaptation is currently authorized.
*   **`<LV_IS>`**: A local variable, possibly indicating an internal state or status, used for authorization checks.
*   **`<N_32>`**: A constant or variable used as a threshold in authorization checks.
*   **`C_N_MAX_VCV_SL_AD_AUTH`**: Calibrated maximum value for `N` (likely related to `<N_32>` or a count) for VCV Soft Landing Adaptation authorization.
*   **`<FUP>`**: A general-purpose flag or input, possibly related to a 'Function Up' status.
*   **`C_FUP_MAX_VCV_SL_AD_AUTH`**: Calibrated maximum `FUP` value for VCV Soft Landing Adaptation authorization.
*   **`<LV_VCV_CLOSE_SL_AD_REQ>`**: A boolean flag indicating if VCV Close Soft Landing Adaptation is requested.
*   **`<LV_VCV_CLOSE_SL_AD_RST>`**: A boolean flag indicating if VCV Close Soft Landing Adaptation should be reset.
*   **`lv_vcv_close_sl_ad_end`**: An internal feedback signal indicating if the adaptation end condition was previously met and latched.

## Outputs

The key outputs generated by this system are:

*   **`GLV_VCV_CLOSE_SL_AD_END`**: A global local variable, a boolean flag, indicating that the VCV Close Soft Landing Adaptation process has ended.
*   **`GLV_VCV_CLOSE_SL_AD_WAIT`**: A global local variable, a boolean flag, indicating that the system is currently in a waiting state for VCV Close Soft Landing Adaptation.
*   **`STATE_VCV_CLOSE_SL`**: An enumerated output representing the current operating state of the VCV Close Soft Landing Adaptation, which can be one of: `OFF`, `STAT` (Static/Idle), `AD_ON` (Adaptation On), `AD_PWM` (Adaptation based on PWM), or `AD_T_DUR` (Adaptation based on Time Duration).

## Logic Flow

The logical flow can be broken down into two main parts:

### 1. Adaptation End and Wait Condition Calculation

This section determines when the adaptation process ends and when it should wait.

*   **Adaptation End Logic (Top Path):**
    1.  The `<CTR_VCV_CLOSE_SL_AD>` counter is compared against two maximum thresholds: `C_CTR_MAX_VCV_CLOSE_SL_AD_PWM` and `C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR`.
    2.  The `max` block selects the higher of these two threshold values.
    3.  A `>='` comparator checks if `<CTR_VCV_CLOSE_SL_AD>` is greater than or equal to the selected maximum threshold.
    4.  The result of this comparison, along with `lv_vcv_close_sl_ad_end` (a feedback signal), feeds into block `V.6.8` (likely a latch or memory element). This block sets `lv_vcv_close_sl_ad_end` to TRUE once the counter reaches the threshold and holds it.
    5.  The output of `V.6.8` is then assigned to `GLV_VCV_CLOSE_SL_AD_END`, signaling the end of adaptation.

*   **Adaptation Wait Logic (Middle Path):**
    1.  Two authorization checks are performed:
        *   `<LV_VCV_CLOSE_SL_AUTH>` is checked if it's less than `<N_32>`.
        *   `<LV_IS>` is checked if it's less than `C_N_MAX_VCV_SL_AD_AUTH`.
    2.  An `AND` gate combines the results of these two authorization checks with the logical `NOT` of `lv_vcv_close_sl_ad_end` (meaning the adaptation has *not* yet ended).
    3.  The output of this `AND` gate determines `GLV_VCV_CLOSE_SL_AD_WAIT`. This flag is TRUE if authorization conditions are met and the adaptation has not ended, indicating the system is waiting for other conditions to proceed to active adaptation.

### 2. State Determination for `STATE_VCV_CLOSE_SL`

This section uses a cascaded `if-else if` structure (implemented by `cond_if` blocks V.6.4 and a `Merge` block V.6.12) to determine the current `STATE_VCV_CLOSE_SL`. The conditions are evaluated sequentially with priority:

1.  **OFF State:**
    *   **Condition:** If `GLV_VCV_CLOSE_SL_AD_WAIT` is TRUE (i.e., the system is in a waiting state).
    *   **Action:** `STATE_VCV_CLOSE_SL` is set to `OFF`. (This suggests that while waiting, active adaptation is considered 'OFF', or `GLV_VCV_CLOSE_SL_AD_WAIT` represents a condition *preventing* activation, leading to an OFF state).
2.  **STAT (Static/Idle Adaptation) State:**
    *   **Else If Condition:** (If not in `OFF` state) AND if any of the following are TRUE:
        *   `<LV_VCV_CLOSE_SL_AD_AUTH>` is FALSE (adaptation is not authorized).
        *   `<LV_VCV_CLOSE_SL_AD_REQ>` is TRUE (adaptation is requested).
        *   `<LV_VCV_CLOSE_SL_AD_RST>` is TRUE (adaptation is reset).
        *   (`LV_VCV_CLOSE_SL_AD_AUTH` is TRUE AND `lv_vcv_close_sl_ad_end` is TRUE) (adaptation was authorized and has now ended).
    *   **Action:** `STATE_VCV_CLOSE_SL` is set to `STAT`.
3.  **AD_ON (Adaptation On) State:**
    *   **Else If Condition:** (If not in `OFF` or `STAT` state) AND if `GLV_VCV_CLOSE_SL_AD_WAIT` is TRUE.
    *   **Logical Ambiguity:** This condition is logically problematic in a standard `if-else if` cascade, as the execution path would only reach this `else if` branch if the prior `OFF` condition (which also depends on `GLV_VCV_CLOSE_SL_AD_WAIT`) was FALSE, implying `GLV_VCV_CLOSE_SL_AD_WAIT` was FALSE. Therefore, `AD_ON` could not be reached via this path if `GLV_VCV_CLOSE_SL_AD_WAIT` refers to the exact same boolean signal in both `OFF` and `AD_ON` conditions. This implies either a non-standard behavior of the `cond_if` block, a graphical simplification, or a logical error in the diagram representation.
    *   **Assuming it could be reached:** `STATE_VCV_CLOSE_SL` would be set to `AD_ON`.
4.  **AD_PWM (Adaptation PWM) State:**
    *   **Else If Condition:** (If previous states are not active) AND if:
        *   `<CTR_VCV_CLOSE_SL_AD>` is greater than or equal to `C_CTR_MAX_VCV_CLOSE_SL_AD_PWM`.
        *   AND the output of a "Check ~= 0" block (V.6.10, possibly checking if the counter value is valid or non-zero, or the comparison result is TRUE).
    *   **Action:** `STATE_VCV_CLOSE_SL` is set to `AD_PWM`.
5.  **AD_T_DUR (Adaptation Time Duration) State:**
    *   **Else If Condition:** (If previous states are not active) AND if:
        *   `<CTR_VCV_CLOSE_SL_AD>` is less than `C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR`.
        *   AND the output of a "Check ~= 0" block (V.6.10, same as above).
    *   **Action:** `STATE_VCV_CLOSE_SL` is set to `AD_T_DUR`.

The `Merge` block (V.6.12) ensures that only one of these states is output as `STATE_VCV_CLOSE_SL` at any given time, reflecting the prioritized decision-making process.


--- Page 226 ---

This page contains a Simulink diagram that represents a control logic subsystem.

## Function

The primary function of this Simulink subsystem is to calculate and manage "soft landing" states for a Volume Control Valve (VCV) within a fuel pressure actuator control system. Specifically, it determines two status flags (`VB_VCV_CLOSE_SL_AD_ST`, `R_VCV_CLOSE_SL_AD_ST`) and calculates adjusted Pulse Width Modulation (PWM) and Time Duration (`PWM_VCV_CLOSE_SL_AD_END`, `T_DUR_VCV_CLOSE_SL_AD_END`) values. This calculation is triggered and dependent on the `STATE_VCV_CLOSE_SL` (VCV close soft landing state) and other operational parameters and requests. The "soft landing" aspect implies a controlled and smooth transition for the valve's operation to avoid sudden changes or wear.

## Inputs

1.  **`STATE_VCV_CLOSE_SL_old`**: The previous state of the VCV close soft landing.
2.  **`<STATE_VCV_CLOSE_SL>`**: The current state of the VCV close soft landing (used multiple times).
3.  **`AD_PWM`**: An adjustment value related to Pulse Width Modulation for VCV closing.
4.  **`AD_T_DUR`**: An adjustment value related to Time Duration for VCV closing.
5.  **`<VB>`**: A boolean or status signal, likely indicating valve brake or enablement.
6.  **`<R_VCV>`**: A boolean or status signal, likely a reset or readiness indicator for the VCV.
7.  **`<LV_VCV_CLOSE_SL_AD_RST>`**: Local Variable: VCV close soft landing adjustment reset request (boolean).
8.  **`<LV_VCV_CLOSE_SL_AD_END>`**: Local Variable: VCV close soft landing adjustment end status (boolean).
9.  **`<LV_VCV_CLOSE_SL_AD_REQ>`**: Local Variable: VCV close soft landing adjustment request (boolean). This acts as a primary control for the PWM/Time Duration calculation.
10. **`<PWM_VCV_CLOSE_SL_AD_END>`**: The current/feedback value of the PWM for VCV close soft landing end (used as an input for incremental adjustment).
11. **`C_PWM_AD_OFS_VCV_CLOSE_SL_REQ`**: A constant or parameter representing the offset to be added to the PWM adjustment when requested.
12. **`<T_DUR_VCV_CLOSE_SL_AD_END>`**: The current/feedback value of the Time Duration for VCV close soft landing end (used as an input for incremental adjustment).
13. **`C_T_DUR_AD_OFS_VCV_CLOSE_SL_REQ`**: A constant or parameter representing the offset to be added to the Time Duration adjustment when requested.

## Outputs

1.  **`VB_VCV_CLOSE_SL_AD_ST`**: Status output: VCV close soft landing adjustment state related to `<VB>`.
2.  **`R_VCV_CLOSE_SL_AD_ST`**: Status output: VCV close soft landing adjustment state related to `<R_VCV>`.
3.  **`PWM_VCV_CLOSE_SL_AD_END`**: The calculated or adjusted PWM value for the VCV close soft landing end.
4.  **`T_DUR_VCV_CLOSE_SL_AD_END`**: The calculated or adjusted Time Duration value for the VCV close soft landing end.

## Logic Flow

The subsystem's logic can be broken down into two main parts: calculating the status flags and calculating the adjustment end values.

**Part 1: Calculation of Status Flags (`VB_VCV_CLOSE_SL_AD_ST`, `R_VCV_CLOSE_SL_AD_ST`)**

1.  **`VB_VCV_CLOSE_SL_AD_ST` Calculation:**
    *   Compares `STATE_VCV_CLOSE_SL_old` with `STATE_VCV_CLOSE_SL`.
    *   Compares `AD_PWM` with `STATE_VCV_CLOSE_SL`.
    *   Compares `AD_T_DUR` with `STATE_VCV_CLOSE_SL`.
    *   The results of the `AD_PWM` and `AD_T_DUR` comparisons are combined with an `OR` logic.
    *   This `OR` result is then combined with the `STATE_VCV_CLOSE_SL_old` vs `STATE_VCV_CLOSE_SL` comparison result using an `AND` logic.
    *   The output of this `AND` gate acts as the condition for a `cond_if` block. If the condition is true, the input signal `<VB>` is passed through; otherwise, a default value (likely 0 or previous state) is used, generating `VB_VCV_CLOSE_SL_AD_ST`.

2.  **`R_VCV_CLOSE_SL_AD_ST` Calculation:**
    *   Compares `<LV_VCV_CLOSE_SL_AD_RST>` with `STATE_VCV_CLOSE_SL`.
    *   The `<LV_VCV_CLOSE_SL_AD_END>` signal is inverted using a `NOT` gate.
    *   The result of the `LV_VCV_CLOSE_SL_AD_RST` comparison and the inverted `LV_VCV_CLOSE_SL_AD_END` are combined with an `OR` logic.
    *   `STATE_VCV_CLOSE_SL` is compared to a constant `OFF`.
    *   The output of the previous `OR` gate and the `STATE_VCV_CLOSE_SL == OFF` comparison are combined with another `OR` logic.
    *   This final `OR` output acts as the condition for a `cond_if` block. If the condition is true, the input signal `<R_VCV>` is passed through; otherwise, a default value (likely 0 or previous state) is used, generating `R_VCV_CLOSE_SL_AD_ST`.

**Part 2: Calculation of Adjustment End Values (`PWM_VCV_CLOSE_SL_AD_END`, `T_DUR_VCV_CLOSE_SL_AD_END`)**

1.  This section uses an `if` / `else` structure controlled by the `<LV_VCV_CLOSE_SL_AD_REQ>` signal.
2.  **If `<LV_VCV_CLOSE_SL_AD_REQ>` is `false` (Else branch):**
    *   The outputs `PWM_VCV_CLOSE_SL_AD_END` and `T_DUR_VCV_CLOSE_SL_AD_END` are set to constant `0` values.
3.  **If `<LV_VCV_CLOSE_SL_AD_REQ>` is `true` (If branch):**
    *   `PWM_VCV_CLOSE_SL_AD_END`: The input `<PWM_VCV_CLOSE_SL_AD_END>` (current value) is added to the offset `C_PWM_AD_OFS_VCV_CLOSE_SL_REQ`. The result becomes the new `PWM_VCV_CLOSE_SL_AD_END`.
    *   `T_DUR_VCV_CLOSE_SL_AD_END`: The input `<T_DUR_VCV_CLOSE_SL_AD_END>` (current value) is added to the offset `C_T_DUR_AD_OFS_VCV_CLOSE_SL_REQ`. The result becomes the new `T_DUR_VCV_CLOSE_SL_AD_END`.
4.  The outputs from the `if` and `else` branches are merged to produce the final `PWM_VCV_CLOSE_SL_AD_END` and `T_DUR_VCV_CLOSE_SL_AD_END` values.

**Final Output Consolidation:**
All four computed output signals (`VB_VCV_CLOSE_SL_AD_ST`, `R_VCV_CLOSE_SL_AD_ST`, `PWM_VCV_CLOSE_SL_AD_END`, `T_DUR_VCV_CLOSE_SL_AD_END`) are then gathered by a `BusMerge` block, indicating they are part of a structured output bus for the subsystem. The individual outputs are then exposed as the subsystem's output ports.


--- Page 227 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, titled "FUSL, Fuel pressure actuator control," implements a control strategy for the "Soft Landing" (SL) behavior of a Volume Control Valve (VCV) during its closing phase. Its primary function is to manage and adapt the VCV's control parameters (such as Pulse Width Modulation (PWM) and duration) across different operational modes. The system utilizes feedback to enable adaptation, learning, and stateful behavior, aiming for a precise and smooth control of the fuel pressure actuator. The goal is to optimize the closing characteristics of the VCV, preventing harsh stops and improving overall system performance and longevity.

## Inputs

1.  **`clc_vcv_close_sl_cord`**: (Mode Selector) An integer or enumerated input that selects the current operational mode or state for the VCV soft landing control (0 for OFF, 1 for STAT, 2 for AD_PWM, 3 for AD_T_DUR, 4 for AD_ON).
2.  **`LV_VCV_CLOSE_SL_AD_REQ`**: (Request Input) A signal indicating a request for VCV closing soft landing adaptation.
3.  **`PWM_VCV_CLOSE_SL_AD_END`**: (PWM Target) The desired or end Pulse Width Modulation value for the VCV during its closing soft landing sequence.
4.  **`T_DUR_VCV_CLOSE_SL_AD_END`**: (Duration Target) The desired or end duration value for the VCV closing soft landing sequence.
5.  **`FUP_DIF`**: (Fuel Pressure Difference) A signal representing a difference or error in fuel pressure, used by adaptation algorithms.
6.  **`VB`**: (Battery Voltage) The vehicle's battery voltage, potentially used for compensation or diagnostic checks in specific modes.
7.  **`R_VCV`**: (VCV Resistance) The electrical resistance of the Volume Control Valve, possibly for diagnostic purposes or internal calculations.
8.  **`VB_VCV_CLOSE_SL_AD_ST`**: (Battery Voltage State) A status flag or value related to the battery voltage specifically during adaptation.
9.  **`R_VCV_CLOSE_SL_AD_ST`**: (Resistance State) A status flag or value related to the VCV resistance during adaptation.
10. **Feedback Signals**: These signals are outputs from the previous control cycle and are fed back into the system:
    *   **`CTR_VCV_CLOSE_SL_AD`**: An adaptation counter or control value.
    *   **`PWM_VCV_CLOSE_SL_AD_TMP`**: A temporary Pulse Width Modulation value.
    *   **`T_DUR_VCV_CLOSE_SL_AD`**: The current calculated duration for the soft landing.
    *   **`LV_PWM_VCV_CLOSE_SL_AD_END`**: The last calculated PWM end value.

## Outputs

1.  **`clc_vcv_close_sl_ad`**: (Output Bus) A structured bus containing all the relevant control and adaptation parameters for the VCV's closing soft landing. This bus includes:
    *   **`CTR_VCV_CLOSE_SL_AD`**: The updated adaptation counter.
    *   **`PWM_VCV_CLOSE_SL_AD`**: The primary PWM output to control the VCV.
    *   **`PWM_VCV_CLOSE_SL_AD_TMP`**: An updated temporary PWM value.
    *   **`T_DUR_VCV_CLOSE_SL_AD`**: The updated duration for the soft landing.
    *   **`LV_PWM_VCV_CLOSE_SL_AD_END`**: The updated last PWM end value.

## Logic Flow

1.  **Mode Selection**: The process begins by evaluating the input signal `clc_vcv_close_sl_cord`. This signal acts as a selector for a Multiport Switch (or similar state logic) that determines which of the five operational modes for the VCV closing soft landing is currently active.
2.  **Subsystem Activation**: Based on the value of `clc_vcv_close_sl_cord`, one of the five dedicated subsystems is activated. Only the outputs from the active subsystem are propagated further:
    *   **`CLC_VCV_CLOSE_SL_OFF` (case 0)**: This mode is engaged when the VCV closing soft landing is inactive. According to the text, all adaptation values are reset in this state, except for the adaptation counter which retains its value to preserve learning progress. It primarily processes `LV_VCV_CLOSE_SL_AD_REQ`, `PWM_VCV_CLOSE_SL_AD_END`, and `T_DUR_VCV_CLOSE_SL_AD_END`.
    *   **`CLC_VCV_CLOSE_SL_STAT` (case 1)**: Represents a static or baseline operational mode. It likely applies predefined or non-adapting soft landing parameters, also processing `LV_VCV_CLOSE_SL_AD_REQ`, `PWM_VCV_CLOSE_SL_AD_END`, and `T_DUR_VCV_CLOSE_SL_AD_END`.
    *   **`CLC_VCV_CLOSE_SL_AD_PWM` (case 2)**: This mode is dedicated to adapting the PWM values for the VCV soft landing. It uses `FUP_DIF` (fuel pressure difference) along with feedback signals (`CTR_VCV_CLOSE_SL_AD`, `PWM_VCV_CLOSE_SL_AD_TMP`, `T_DUR_VCV_CLOSE_SL_AD`, `LV_PWM_VCV_CLOSE_SL_AD_END`) to calculate optimized PWM parameters.
    *   **`CLC_VCV_CLOSE_SL_AD_T_DUR` (case 3)**: This mode focuses on adapting the duration (`T_DUR`) of the soft landing. Similar to `AD_PWM`, it utilizes `FUP_DIF` and the same set of feedback signals for its adaptation algorithms.
    *   **`CLC_VCV_CLOSE_SL_AD_ON` (case 4)**: This is an active "on" adaptation mode, possibly for general adaptation or fine-tuning. It processes `PWM_VCV_CLOSE_SL_AD_END`, `T_DUR_VCV_CLOSE_SL_AD_END`, and various vehicle-specific inputs like `VB`, `R_VCV`, and their respective states (`VB_VCV_CLOSE_SL_AD_ST`, `R_VCV_CLOSE_SL_AD_ST`), along with the `CTR_VCV_CLOSE_SL_AD` feedback.
3.  **Parameter Calculation and Adaptation**: Within the active subsystem, the incoming inputs (including feedback from the previous cycle) are processed according to the logic specific to that mode. This involves calculations to derive or adjust the VCV's control parameters (PWM, duration, and adaptation counter) to achieve the desired soft landing characteristics and implement the adaptation strategy.
4.  **Output Bus Formation**: Each active subsystem produces a consistent set of five output signals. These individual signals are then consolidated into a single structured output bus named `clc_vcv_close_sl_ad` via a `BusMerge` block. This bus serves as the overall output of the control system, providing the necessary commands to the fuel pressure actuator and feeding back critical state information for the subsequent control cycle.


--- Page 228 ---

This page contains two Simulink-like diagrams embedded within a technical document related to "FUSL, Fuel pressure actuator control." Both diagrams represent specific logic flows for the adaptation of a Valve Control Valve (VCV) closing mechanism.

---

## Function

The diagrams describe two distinct operational modes for VCV closing adaptation in a fuel pressure actuator control system:
1.  **Figure 43.15.46 (Top Diagram):** Represents the calculation of VCV closing parameters during a "static mode" where no adaptation is active. Its primary function is to reset adaptive parameters to zero while passing through a control counter.
2.  **Figure 43.15.47 (Bottom Diagram):** Represents the logic for "adaptation of duty-cycle for VCV holding phase." Its primary function is to apply learned (adapted) PWM and duration values for VCV closing if an adaptation request is active, or to reset these values if no request is present, effectively controlling the VCV's operation based on adaptation status.

---

## Inputs

**For Figure 43.15.46 (Static Mode, No Adaptation):**
*   `<CTR_VCV_CLOSE_SL_AD>`: Control counter for VCV close adaptation.

**For Figure 43.15.47 (Adaptation of Duty-Cycle):**
*   `<CTR_VCV_CLOSE_SL_AD>`: Control counter for VCV close adaptation.
*   `<PWM_VCV_CLOSE_SL_AD_END>`: The final or "learned" PWM value for VCV close adaptation from a previous cycle or storage.
*   `<LV_VCV_CLOSE_SL_AD_REQ>`: A boolean or control signal indicating if an adaptation request for VCV closing is active (e.g., non-zero for active, zero for inactive).
*   `<T_DUR_VCV_CLOSE_SL_AD_END>`: The final or "learned" duration time for VCV close adaptation from a previous cycle or storage.

---

## Outputs

**For Figure 43.15.46 (Static Mode, No Adaptation):**
*   `<CTR_VCV_CLOSE_SL_AD>`: The output control counter (passed through from input).
*   `<PWM_VCV_CLOSE_SL_AD>`: Pulse Width Modulation (PWM) value for VCV close adaptation (reset to 0).
*   `<PWM_VCV_CLOSE_SL_AD_TMP>`: Temporary PWM value for VCV close adaptation (reset to 0).
*   `<T_DUR_VCV_CLOSE_SL_AD>`: Duration time for VCV close adaptation (reset to 0).
*   `<LV_PWM_VCV_CLOSE_SL_AD_END>`: Learn value for PWM VCV close adaptation end (reset to 0).

**For Figure 43.15.47 (Adaptation of Duty-Cycle):**
*   `<CTR_VCV_CLOSE_SL_AD>`: The output control counter (passed through from input).
*   `<PWM_VCV_CLOSE_SL_AD>`: The calculated/adapted PWM value for VCV closing.
*   `<PWM_VCV_CLOSE_SL_AD_TMP>`: A temporary PWM value used in the calculation of `<PWM_VCV_CLOSE_SL_AD>`.
*   `<T_DUR_VCV_CLOSE_SL_AD>`: The calculated/adapted duration time for VCV closing.
*   `<LV_PWM_VCV_CLOSE_SL_AD_END>`: A specific learn value, which is reset to 0 by this diagram.

---

## Logic Flow

**Figure 43.15.46: Calculations during static mode, no adaptation active**

1.  **Counter Pass-through:** The input signal `<CTR_VCV_CLOSE_SL_AD>` is directly routed to the output `<CTR_VCV_CLOSE_SL_AD>`. This suggests that in static mode without active adaptation, the counter's value is preserved or managed externally, but not modified by this specific logic block.
2.  **Adaptation Parameter Reset:** All other output signals (`<PWM_VCV_CLOSE_SL_AD>`, `<PWM_VCV_CLOSE_SL_AD_TMP>`, `<T_DUR_VCV_CLOSE_SL_AD>`, `<LV_PWM_VCV_CLOSE_SL_AD_END>`) are assigned a constant value of `0` (from blocks labeled `0 V.6.11`). This aligns with the "no adaptation active" description, ensuring adaptive parameters are cleared or initialized to a default zero state.

**Figure 43.15.47: Adaptation of duty-cycle for VCV holding phase**

1.  **Counter Pass-through:** Similar to the static mode, the input signal `<CTR_VCV_CLOSE_SL_AD>` is directly routed to the output `<CTR_VCV_CLOSE_SL_AD>`.
2.  **PWM Adaptation Logic:**
    *   A Simulink Switch block (labeled `Check ~= 0 V.6.10`) receives three inputs:
        *   Top input: `<PWM_VCV_CLOSE_SL_AD_END>` (the learned/final PWM value).
        *   Middle input: A constant `0` (V.6.11).
        *   Control input (bottom): `<LV_VCV_CLOSE_SL_AD_REQ>` (adaptation request).
    *   **Conditional Selection:** If `<LV_VCV_CLOSE_SL_AD_REQ>` is active (non-zero), the switch selects `<PWM_VCV_CLOSE_SL_AD_END>`. If `<LV_VCV_CLOSE_SL_AD_REQ>` is inactive (zero), the switch selects `0`.
    *   **Temporary Value Assignment:** The selected value from the switch then passes through a triangular block (labeled `V.6.8`), which typically represents a gain (often unity if not specified, or a data type conversion). The output of this block is assigned to `<PWM_VCV_CLOSE_SL_AD_TMP>`.
    *   **Final PWM Assignment:** The value of `<PWM_VCV_CLOSE_SL_AD_TMP>` is then directly assigned to the output `<PWM_VCV_CLOSE_SL_AD>`, which is the effective PWM duty-cycle for VCV closing.
3.  **Duration Adaptation Logic:**
    *   A second Simulink Switch block (identical in logic to the first) receives:
        *   Top input: `<T_DUR_VCV_CLOSE_SL_AD_END>` (the learned/final duration time).
        *   Middle input: A constant `0` (V.6.11).
        *   Control input (bottom): `<LV_VCV_CLOSE_SL_AD_REQ>`.
    *   **Conditional Selection:** If `<LV_VCV_CLOSE_SL_AD_REQ>` is active, the switch selects `<T_DUR_VCV_CLOSE_SL_AD_END>`. If inactive, it selects `0`.
    *   **Duration Assignment:** The selected value from this switch is directly assigned to the output `<T_DUR_VCV_CLOSE_SL_AD>`, which is the effective duration time for VCV closing.
4.  **Learn Value Reset:** The output `<LV_PWM_VCV_CLOSE_SL_AD_END>` is explicitly set to a constant value of `0` (from block `0 V.6.11`). This suggests that after this particular adaptation phase or calculation, this specific learn value flag might be cleared or reset, possibly to prepare for the next adaptation cycle or signal that the current 'end' value has been consumed.


--- Page 229 ---

This page contains a Simulink-like diagram, likely representing control logic for an automotive system.

## Function
The primary function of this Simulink diagram is to implement an adaptive control mechanism for the **Valve Current Valve (VCV) pull-in time** and **PWM (Pulse Width Modulation) duty cycle** in a fuel pressure actuator control system. The goal is to ensure stable fuel pressure and proper VCV operation, particularly during peak phases, by compensating for deviations (like fuel pressure drops). It dynamically adjusts key operational parameters (PWM and duration) based on measured fuel pressure difference and adaptation status.

## Inputs
The key inputs to this control logic are:

*   **`FUP_DIF`**: Fuel Pressure Difference – likely a measured or calculated deviation in fuel pressure.
*   **`C_FUP_DIF_VCV_CLOSE_SL_AD_PWM`**: Calibrated threshold for fuel pressure difference, used for PWM adaptation triggering. (Also labeled as `C_FUP_DIF_VCV_CLOSE_SL_AD_T_DUR` for duration adaptation, implying it's the same threshold).
*   **`LV_PWM_VCV_CLOSE_SL_AD_END`**: A boolean flag indicating the end status of the PWM adaptation cycle (current state).
*   **`CTR_VCV_CLOSE_SL_AD`**: The current value of the SL adaptation counter for VCV closing.
*   **`PWM_VCV_CLOSE_SL_AD_TMP`**: The current temporary or previously adapted PWM value.
*   **`C_PWM_OFS_VCV_CLOSE_SL_AD`**: A calibrated offset value used to decrease the PWM adaptation.
*   **`C_PWM_INC_VCV_CLOSE_SL_AD`**: A calibrated increment value used to increase the PWM adaptation.
*   **`T_DUR_VCV_CLOSE_SL_AD`**: The current duration adaptation value.
*   **`C_T_DUR_INC_VCV_CLOSE_SL_AD`**: A calibrated increment value used to increase the duration adaptation.
*   **`C_T_DUR_OFS_VCV_CLOSE_SL_AD`**: A calibrated offset value used to decrease the duration adaptation.
*   **`C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR`**: (Implied by text) A calibrated maximum value for the adaptation counter, influencing the application of offset corrections.

## Outputs
The key outputs generated or updated by this control logic are:

*   **`LV_PWM_VCV_CLOSE_SL_AD_END`**: The updated boolean flag indicating the end status of the PWM adaptation cycle.
*   **`CTR_VCV_CLOSE_SL_AD`**: The updated SL adaptation counter value.
*   **`PWM_VCV_CLOSE_SL_AD_TMP`**: The updated temporary PWM adaptation value.
*   **`PWM_VCV_CLOSE_SL_AD`**: The final adapted PWM value for VCV closing.
*   **`PWM_VCV_CLOSE_SL_AD_END`**: A flag indicating the completion or end state of the PWM adaptation.
*   **`T_DUR_VCV_CLOSE_SL_AD`**: The updated duration adaptation value for VCV closing.
*   **`T_DUR_VCV_CLOSE_SL_AD_END`**: A flag indicating the completion or end state of the duration adaptation.

## Logic Flow

The diagram implements parallel adaptive logic for both PWM and duration, primarily triggered by a fuel pressure difference condition and managed by a shared adaptation counter.

1.  **Fuel Pressure Drop Detection:**
    *   The `FUP_DIF` (Fuel Pressure Difference) is compared against a calibrated threshold, `C_FUP_DIF_VCV_CLOSE_SL_AD_PWM` (which is also used for duration adaptation).
    *   If `FUP_DIF` exceeds this threshold (`FUP_DIF > C_FUP_DIF_VCV_CLOSE_SL_AD_PWM`), it indicates that the VCV did not close adequately, leading to a pressure drop. This condition triggers the adaptation process.

2.  **PWM Adaptation Path (Upper Branch):**
    *   **Trigger Condition:** The adaptation is active if `FUP_DIF` exceeds the threshold AND the `LV_PWM_VCV_CLOSE_SL_AD_END` flag is NOT set (meaning PWM adaptation is not yet finished). This combined condition is fed into an `AND` gate.
    *   **Counter and PWM Adjustment:** The output of this `AND` gate, along with the current `CTR_VCV_CLOSE_SL_AD`, `PWM_VCV_CLOSE_SL_AD_TMP`, `C_PWM_INC_VCV_CLOSE_SL_AD`, and `C_PWM_OFS_VCV_CLOSE_SL_AD`, feeds into a complex block (V.7.11, labeled "E x_in x_out").
        *   Within this block (or its associated logic, per the text), if the trigger condition is met, the `CTR_VCV_CLOSE_SL_AD` is incremented.
        *   If `CTR_VCV_CLOSE_SL_AD` exceeds a calibrated maximum (`C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR`), `PWM_VCV_CLOSE_SL_AD_TMP` is decreased by `C_PWM_OFS_VCV_CLOSE_SL_AD`.
        *   Otherwise, `PWM_VCV_CLOSE_SL_AD_TMP` is increased by `C_PWM_INC_VCV_CLOSE_SL_AD`.
    *   **Output:** The updated `PWM_VCV_CLOSE_SL_AD_TMP` is passed through a "Check ~=0" block (V.6.10, likely for validation or clamping) to produce the final `PWM_VCV_CLOSE_SL_AD`.
    *   **Flags:** `LV_PWM_VCV_CLOSE_SL_AD_END` and `PWM_VCV_CLOSE_SL_AD_END` are generated, likely indicating the status and completion of the PWM adaptation process, based on the adaptation logic.

3.  **Duration Adaptation Path (Lower Branch):**
    *   **Trigger Condition:** Similar to PWM, if `FUP_DIF` exceeds the threshold (`FUP_DIF > C_FUP_DIF_VCV_CLOSE_SL_AD_T_DUR`).
    *   **Duration Adjustment:** The trigger directly feeds into an adder block which takes the current `T_DUR_VCV_CLOSE_SL_AD` and adds `C_T_DUR_INC_VCV_CLOSE_SL_AD`. This implements the "increase by calibrated value" step.
    *   **Offset Correction (Implied):** Although not explicitly shown as a direct subtractor in the visible part of this branch, the textual description states that if `CTR_VCV_CLOSE_SL_AD` exceeds `C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR`, `T_DUR_VCV_CLOSE_SL_AD` is decreased by `C_T_DUR_OFS_VCV_CLOSE_SL_AD`. This correction might occur within the "Check ~=0" block (V.6.10) or be part of the larger system logic interacting with the output of this diagram.
    *   **Output:** The updated `T_DUR_VCV_CLOSE_SL_AD` (after increment and potential offset correction) is output.
    *   **Flag:** `T_DUR_VCV_CLOSE_SL_AD_END` is generated, signifying the completion or stable state of the duration adaptation.

4.  **Interdependencies:**
    *   Both adaptation paths are critically linked by the initial `FUP_DIF` condition.
    *   The `CTR_VCV_CLOSE_SL_AD` is a shared counter that is incremented when a fuel pressure drop occurs, influencing both PWM and duration adjustments, particularly for applying offset corrections once a maximum count is reached. This implies a coordinated adaptation strategy.


--- Page 230 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "FUSL, Fuel pressure actuator control" and described as "Calculations for adapted soft landing during VCV closing," primarily functions to calculate and adapt control parameters for a Fuel Pressure Actuator (likely a Volume Control Valve, VCV) during its closing "soft landing" phase. It focuses on correcting learned adaptation variables (specifically `T_DUR` and potentially `PWM`) based on current environmental conditions and deviations from stored working points, ensuring stable and precise control of the VCV. It also calculates an adaptive counter/state (`CTR_VCV_CLOSE_SL_AD`) based on fuel pressure differentials.

## Inputs
*   **`<FUP_DIF>`**: Fuel pressure differential or deviation. (Input to the counter adaptation logic).
*   **`C_FUP_DIF_VCV_CLOSE_SL_AD_T_DUR`**: Calibration value for the fuel pressure differential threshold in T_DUR adaptation.
*   **`<CTR_VCV_CLOSE_SL_AD>`**: Current or initial adaptive counter/state for VCV close soft landing adaptation. (Shown as an input but also an output, indicating an update).
*   **`<PWM_VCV_CLOSE_SL_AD_TMP>`**: Temporary adapted Pulse Width Modulation (PWM) value for VCV close soft landing. (Passed through).
*   **`<T_DUR_VCV_CLOSE_SL_AD>`**: Current or initial adapted duration (T_DUR) value for VCV close soft landing. (Input to the T_DUR adaptation logic).
*   **`C_T_DUR_OFS_VCV_CLOSE_SL_AD`**: Offset calibration for T_DUR adaptation.
*   **`C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR`**: Maximum counter value or limit for the T_DUR adaptation process.
*   **`C_T_DUR_INC_VCV_CLOSE_SL_AD`**: Increment value for T_DUR adaptation.
*   **`0`**: A constant zero value, used in a conditional switch.

## Outputs
*   **`CTR_VCV_CLOSE_SL_AD`**: The adapted counter or state for VCV close soft landing.
*   **`PWM_VCV_CLOSE_SL_AD_TMP`**: The temporary adapted PWM value (passed through from input).
*   **`PWM_VCV_CLOSE_SL_AD`**: The current adapted PWM value (passed through from input).
*   **`PWM_VCV_CLOSE_SL_AD_END`**: The final, corrected PWM value for the end of the VCV close soft landing phase. (Calculation not fully shown in this snippet, but declared as an output).
*   **`T_DUR_VCV_CLOSE_SL_AD_END`**: The final, corrected duration (T_DUR) value for the end of the VCV close soft landing phase.
*   **`LV_PWM_VCV_CLOSE_SL_AD_END`**: Another final PWM value for the end, possibly a calculated limit or adjusted value. (Calculation not fully shown).

## Logic Flow

The diagram presents two main parallel computation paths:

### 1. Adaptive Counter (`CTR_VCV_CLOSE_SL_AD`) Calculation:
1.  **Fuel Pressure Difference Comparison**: The input fuel pressure differential `<FUP_DIF>` is compared to a calibration threshold `C_FUP_DIF_VCV_CLOSE_SL_AD_T_DUR` using a "Greater Than" ( `>` ) block (V.6.6). This determines if the difference exceeds a certain limit.
2.  **Characteristic Curve/Mapping**: The boolean result of this comparison (0 or 1) serves as an input (`x_in`) to a block labeled `E` (V.7.11), which has a squiggly line, suggesting a 1D lookup table or a characteristic curve. This block likely maps the comparison result to an adaptive output `x_out`.
3.  **Output**: The `x_out` from block V.7.11 is then output as `CTR_VCV_CLOSE_SL_AD`. This implies that `CTR_VCV_CLOSE_SL_AD` is adjusted or updated based on the fuel pressure difference exceeding a calibrated threshold, through a defined mapping.

### 2. Adapted Duration (`T_DUR_VCV_CLOSE_SL_AD_END`) Calculation:
1.  **Offset Application**: The current adapted duration value `<T_DUR_VCV_CLOSE_SL_AD>` is added to a calibrated offset `C_T_DUR_OFS_VCV_CLOSE_SL_AD` using a "Sum" block (V.7.7).
2.  **Maximum Limit Check**: The result of this sum is then compared against a maximum counter/limit value `C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR` using a "Greater Than or Equal" ( `>=` ) block (V.6.6).
3.  **Conditional Increment**: The boolean result of the limit check (from V.6.6) acts as the control input to a "Switch" block (V.6.10) labeled "Check ~= 0".
    *   If the sum (`<T_DUR_VCV_CLOSE_SL_AD>` + `C_T_DUR_OFS_VCV_CLOSE_SL_AD`) is **less than** `C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR` (i.e., the limit is not reached), the switch selects the `C_T_DUR_INC_VCV_CLOSE_SL_AD` (increment value).
    *   If the sum is **greater than or equal to** `C_CTR_MAX_VCV_CLOSE_SL_AD_T_DUR` (i.e., the limit is reached or exceeded), the switch selects `0`.
4.  **Final T_DUR Calculation**: The output from the switch (either the increment value or 0) is then added to the original `<T_DUR_VCV_CLOSE_SL_AD>` using another "Sum" block (V.7.7) to produce the final adapted duration value, `T_DUR_VCV_CLOSE_SL_AD_END`. This effectively increments `T_DUR_VCV_CLOSE_SL_AD` by `C_T_DUR_INC_VCV_CLOSE_SL_AD` unless it has reached its maximum allowed value, in which case it is held (or potentially capped).

### 3. PWM Outputs:
*   `<PWM_VCV_CLOSE_SL_AD_TMP>` and `<PWM_VCV_CLOSE_SL_AD>` are shown as inputs that are directly passed through to corresponding outputs.
*   `PWM_VCV_CLOSE_SL_AD_END` and `LV_PWM_VCV_CLOSE_SL_AD_END` are displayed as outputs of the subsystem. While their internal calculation logic is not explicitly shown in this snippet, the context implies they represent the final, corrected PWM values after adaptation based on working point status, likely derived from the passed-through PWM inputs and other un-depicted calculations using the `T_DUR` adaptation results or other inputs.


--- Page 231 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "FUSL, Fuel pressure actuator control," primarily functions to calculate and adapt the Pulse Width Modulation (PWM) duty cycle and the corresponding activation duration for a Volume Control Valve (VCV) within a fuel pressure control system. The presence of "SL_AD" in variable names suggests a "Self-Learning Adaptation" or "System Level Adaptation" mechanism, where initial or current values are refined based on operating conditions (e.g., battery voltage and VCV resistance) using calibrated lookup tables.

## Inputs
*   `<CTR_VCV_CLOSE_SL_AD>`: A control signal or flag related to the VCV close function and its self-learning adaptation.
*   `<VB>`: Battery Voltage, used as an input for the PWM calculation lookup table.
*   `<R_VCV>`: Resistance of the VCV, used as an input for the PWM calculation lookup table.
*   `<VB_VCV_CLOSE_SL_AD_ST>`: Battery Voltage (Start), specifically for the duration calculation lookup table related to VCV close and self-learning adaptation.
*   `<R_VCV_CLOSE_SL_AD_ST>`: Resistance of the VCV (Start), specifically for the duration calculation lookup table related to VCV close and self-learning adaptation.
*   `<PWM_VCV_CLOSE_SL_AD_END>`: An existing or previously adapted PWM value for the VCV close function.
*   `<T_DUR_VCV_CLOSE_SL_AD_END>`: An existing or previously adapted time duration value for the VCV close function.

## Outputs
*   `<CTR_VCV_CLOSE_SL_AD>`: The pass-through control signal.
*   `<PWM_VCV_CLOSE_SL_AD>`: The final, adapted PWM value for controlling the VCV.
*   `PWM_VCV_CLOSE_SL_AD_TMP`: An intermediate/temporary adapted PWM value, before final scaling.
*   `<T_DUR_VCV_CLOSE_SL_AD>`: The final, adapted time duration value for controlling the VCV.
*   `<LV_PWM_VCV_CLOSE_SL_AD_END>`: A status or initialization flag, which is set to a constant zero in this diagram. (Likely "Learned Value" or "Last Value").

## Logic Flow

1.  **Control Signal Pass-through:**
    *   The input `<CTR_VCV_CLOSE_SL_AD>` is directly routed to an output `<CTR_VCV_CLOSE_SL_AD>`, indicating it's either passed through this subsystem unmodified or acts as an external trigger/status for operations elsewhere.

2.  **PWM Calculation and Adaptation:**
    *   The battery voltage (`<VB>`) and VCV resistance (`<R_VCV>`) are fed as `x_val` and `y_val` respectively into a 2D lookup table named `IP_PWM_VCV_CTL_SL_AD_END (V.7.11)`. This table outputs a `P_val`, which represents a calibrated PWM adjustment based on these electrical conditions.
    *   This calibrated `P_val` is then added to the incoming adapted PWM value (`<PWM_VCV_CLOSE_SL_AD_END>`) using a summation block (`V.7.7`). This step performs the core adaptation, modifying the existing PWM value.
    *   The result of this summation is then passed through a gain block (`V.6.8`) to apply a scaling factor.
    *   The output of the gain block is the final adapted PWM value, `<PWM_VCV_CLOSE_SL_AD>`.
    *   Additionally, the output of the summation block, *before* the final gain, is also provided as an intermediate output `PWM_VCV_CLOSE_SL_AD_TMP`.

3.  **Duration Calculation and Adaptation:**
    *   Similarly, the "start" battery voltage (`<VB_VCV_CLOSE_SL_AD_ST>`) and VCV resistance (`<R_VCV_CLOSE_SL_AD_ST>`) are fed as `x_val` and `y_val` into another 2D lookup table, `IP_T_DUR_VCV_CTL_SL_AD_END (V.7.11)`. This table outputs a `P_val`, which represents a calibrated duration adjustment.
    *   This calibrated `P_val` is then added to the incoming adapted time duration value (`<T_DUR_VCV_CLOSE_SL_AD_END>`) using a summation block (`V.7.7`). This performs the duration adaptation.
    *   The result of this summation is also passed through a gain block (`V.6.8`) for scaling.
    *   The output of this gain block is the final adapted time duration, `<T_DUR_VCV_CLOSE_SL_AD>`.

4.  **Learned Value Initialization/Reset:**
    *   A constant block outputting '0' (`V.6.11`) is directly connected to the output `<LV_PWM_VCV_CLOSE_SL_AD_END>`. This suggests that a "Learned Value" or "Last Value" for the PWM at the end of the VCV close adaptation cycle is being explicitly set to zero within this subsystem, possibly as part of a reset, initialization phase, or to indicate a specific state.


--- Page 232 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram describes a **Closed-Loop Controlled Actuation of a Volume Control Valve (VCV)**, specifically within a **Fuel Pressure Actuator Control** system (indicated by "FUSL, Fuel pressure actuator control"). Its primary function is to calculate and provide a comprehensive set of parameters, including Pulse Width Modulation (PWM) duty cycles, frequencies, and timing, required to precisely actuate the VCV based on various engine operating conditions, desired states, and feedback from the valve itself. The "closed-loop" aspect implies that the system uses feedback (e.g., actual current or position) to adjust its control outputs to achieve the target VCV state.

## Inputs
The system receives the following key inputs:

1.  **`<input>`**: A generic input signal, likely representing a primary control request or reference.
2.  **`<feedback>`**: A generic feedback signal, crucial for closed-loop control, likely indicating the actual current or position of the VCV.
3.  **`<VB>`**: Battery Voltage or System Supply Voltage.
4.  **`<N_32>`**: Engine Speed (likely in RPM), affecting VCV operating conditions.
5.  **`<TFPA>`**: Fuel Pressure Actuator signal, indicating measured fuel pressure.
6.  **`<VCV_CLOSE_RNG>`**: Defines the operational range for VCV closing.
7.  **`<clc_vcv_sl_off_open>`**: A control signal to enable or disable the closed-loop VCV slave or set it to an open state.
8.  **`<STATE_VCV_CLOSE_SL>`**: The current operational state of the VCV close slave.
9.  **`<PWM_VCV_CLOSE_SL_AD>`**: An adjusted PWM duty cycle specifically for the VCV close slave.
10. **`<LV_VCV_CLOSE_SL_AD_AUTH>`**: Authorization level for the adjusted VCV close slave functionality.
11. **`<T_DUR_VCV_CLOSE_SL_AD_END>`**: The end duration for the adjusted VCV close slave operation.

## Outputs
The primary output of this system is a merged bus signal named `vcv_cur_cll_ctl_typ_1`, which encapsulates a wide array of control parameters for the VCV. This bus contains signals from both internal processing stages:

**From `CLC_VCV_CUR_CLL_CTL_1`:**
*   **`<T_DUR_VCV_CTL_PEAK>`**: Peak duration for VCV control.
*   **`<T_DLY_VCV_CTL>`**: Delay duration for VCV control.
*   **`<ANG_VCV_CTL_HOLD>`**: Angle parameter for VCV control hold.
*   **`<FRQ_PWM_VCV_CTL_0_SL>`**: PWM frequency for VCV control in state 0, slave mode.
*   **`<CUR_VCV_CTL_RAW>`**: Raw VCV control current.
*   **`<CUR_VCV_CTL_PEAK>`**: Peak VCV control current.
*   **`<CUR_VCV_CTL_HOLD>`**: Hold VCV control current.
*   **`<ANG_CUR_ON_VCV>`**: Angle at which current is turned ON for VCV.
*   **`<ANG_DLY_VCV_CLOSE_ADD>`**: Additional delay angle for VCV closing.
*   **`<LV_VCV_CLOSE_RNG_MIN>`**: Minimum level for VCV close range.
*   **`<ANG_CUR_OFF_VCV>`**: Angle at which current is turned OFF for VCV.

**From `CLC_VCV_CUR_CLL_CTL_2`:**
*   **`<PWM_VCV_CTL_PEAK>`**: Peak PWM duty cycle for VCV control.
*   **`<FRQ_PWM_VCV_CTL_PEAK>`**: Peak PWM frequency for VCV control.
*   **`<T_DUR_VCV_CTL_HOLD_0>`**: Duration for VCV control hold state 0.
*   **`<PWM_VCV_CTL_0>`**: PWM duty cycle for VCV control in state 0.
*   **`<FRQ_PWM_VCV_CTL_1>`**: PWM frequency for VCV control in state 1.
*   **`<T_DUR_VCV_CTL_FW>`**: Duration for VCV control in forward state.
*   **`<LF_CUR_CTL_MOD_VCV>`**: Linear factor for current control modification of VCV.
*   **`<PWM_VCV_CTL_1>`**: PWM duty cycle for VCV control in state 1.
*   **`<FRQ_PWM_VCV_CTL_0>`**: PWM frequency for VCV control in state 0.
*   **`<PWM_VCV_CTL_ST>`**: PWM duty cycle for VCV control in steady state.
*   **`<FRQ_PWM_VCV_CTL_ST>`**: PWM frequency for VCV control in steady state.
*   **`<FRQ_PWM_VCV_CTL_PEAK_ST>`**: Peak PWM frequency for VCV control in steady state.
*   **`<T_VCV_CTL_ST>`**: Duration for VCV control in steady state.
*   **`<CUR_VCV_OPL_CTL_MAX>`**: Maximum current for VCV open-loop control.
*   **`<T_DUR_VCV_CTL_0_FW>`**: Duration for VCV control in state 0, forward.
*   **`<PWM_VCV_CTL_PEAK_ST>`**: Peak PWM duty cycle for VCV control in steady state.

## Logic Flow

1.  **Input Acquisition**: The model gathers various operational parameters, commanded states, and actual system feedback. This includes engine speed (`N_32`), fuel pressure (`TFPA`), supply voltage (`VB`), and specific control settings (`VCV_CLOSE_RNG`, `clc_vcv_sl_off_open`, `STATE_VCV_CLOSE_SL`, `PWM_VCV_CLOSE_SL_AD`, `LV_VCV_CLOSE_SL_AD_AUTH`, `T_DUR_VCV_CLOSE_SL_AD_END`). A generic `<input>` and a crucial `<feedback>` signal are also received.

2.  **Parallel Control Calculation**: The core of the system consists of two main processing blocks, `CLC_VCV_CUR_CLL_CTL_1` and `CLC_VCV_CUR_CLL_CTL_2`. These are likely subsystems or model references that implement specific current-controlled closed-loop (CUR_CLL_CTL) logic for the VCV.
    *   **`CLC_VCV_CUR_CLL_CTL_1` (Top Block)**: This block takes a subset of the primary inputs, as well as some signals that appear to be internal feedback or pass-through values (e.g., `CUR_VCV_CTL_PEAK` as both input and output). It computes various timing, current, and angular parameters related to the VCV's operation, likely defining the desired profiles for actuation. The outputs are bundled into a bus `clc_vcv_cur_cll_ctl_typ_1`.
    *   **`CLC_VCV_CUR_CLL_CTL_2` (Bottom Block)**: This block receives a similar set of inputs, including some outputs from `CLC_VCV_CUR_CLL_CTL_1` (e.g., `T_DUR_VCV_CTL_PEAK`, `T_DLY_VCV_CTL`, `CUR_VCV_CTL_PEAK`, `CUR_VCV_CTL_HOLD`, `PWM_VCV_CTL_0_SL`, `FRQ_PWM_VCV_CTL_0_SL`). It calculates the actual PWM duty cycles, frequencies, and specific durations for different VCV operational states (peak, hold, steady state, different modes '0' and '1'), along with current modification factors and open-loop maximum current.

3.  **Output Merging**: The outputs from both `CLC_VCV_CUR_CLL_CTL_1` and `CLC_VCV_CUR_CLL_CTL_2` are merged. The outputs from `CLC_VCV_CUR_CLL_CTL_1` form the bus `clc_vcv_cur_cll_ctl_typ_1`. The outputs from `CLC_VCV_CUR_CLL_CTL_2` are also bundled into a bus. These two buses are then combined by a `BusMerge` block to form a single, comprehensive output bus named `vcv_cur_cll_ctl_typ_1`. This final bus contains all the necessary parameters and commands to control the fuel pressure actuator's VCV, including its timing, current, PWM, and frequency characteristics.


--- Page 233 ---

This page contains a Simulink-like diagram, likely representing a block diagram from an automotive embedded software development environment (e.g., Simulink, TargetLink).

## Function
The primary function of this diagram, titled "43.15.2.1.2.2.3.1.2.1 Closed loop controlled actuation of VCV (Part 1)" and "FUSL, Fuel pressure actuator control," is to calculate and determine various control parameters (durations, delays, angles, PWM values, and currents) required for the precise, closed-loop actuation of a Volume Control Valve (VCV) within a fuel pressure control system. This is "Part 1" of the logic, suggesting it generates key command signals that are then used by other parts of the control system to directly drive the VCV.

## Inputs
The diagram receives various inputs, typically represented by green signal blocks on the left:

*   **`<VB>`**: Battery voltage, influencing electrical calculations.
*   **`<N_32>`**: Engine speed (RPM), a fundamental engine operating condition.
*   **`<VCV_CLOSE_RNG>`**: Desired range or target for VCV closing.
*   **`<STATE_VCV_CLOSE_SL>`**: Current state or mode of VCV closing.
*   **`<PWM_VCV_CLOSE_SL_AD>`**: Adaptive PWM duty cycle for VCV closing.
*   **`<TFPA>`**: Temperature of the Fuel Pressure Actuator.
*   **`<CUR_VCV_CTL_PEAK>`**: Feedback or estimated peak current for VCV control.
*   **`<LV_VCV_CLOSE_SL_AD_AUTH>`**: Authorized level for VCV close adaptive slice.
*   **`<PWM_VCV_CLOSE_SL_AD_END>`**: Adaptive PWM duty cycle for the end of VCV closing.
*   **`<T_DUR_VCV_CLOSE_SL_AD_END>`**: Adaptive duration time for the end of VCV closing.
*   **`[ANG_CUR_ON_VCV]`**: Intermediate angle for when current is applied to VCV.
*   **`[ANG_VCV_CTL_HOLD]`**: Intermediate angle for holding VCV control.
*   **`[T_DUR_VCV_CTL_PEAK]`**: Intermediate duration time for VCV control peak.
*   **`[T_DLY_VCV_CTL]`**: Intermediate delay time for VCV control.

## Outputs
The diagram produces several calculated parameters, typically represented by light blue signal blocks on the right:

*   **`<T_DUR_VCV_CTL_PEAK>`**: Calculated duration time for the peak control phase of the VCV.
*   **`<T_DLY_VCV_CTL>`**: Calculated delay time for VCV control.
*   **`<ANG_VCV_CTL_HOLD>`**: Calculated angle for VCV control hold.
*   **`<PWM_VCV_CTL_0_SL>`**: Calculated base PWM duty cycle for VCV control (0-slice).
*   **`<FRQ_PWM_VCV_CTL_0_SL>`**: Calculated frequency of the base PWM for VCV control.
*   **`<CUR_VCV_CTL_PEAK_RAW>`**: Raw calculated peak current for VCV control.
*   **`<CUR_VCV_CTL_PEAK>`**: Processed calculated peak current for VCV control.
*   **`<CUR_VCV_CTL_HOLD>`**: Calculated hold current for VCV control.
*   **`<T_DLY_VCV_CLOSE_ADD>`**: Additional calculated delay time for VCV close.
*   **`<ANG_DLY_VCV_CLOSE_ADD>`**: Additional calculated delay angle for VCV close.
*   **`<ANG_CUR_ON_VCV>`**: Calculated angle at which current is applied to the VCV.
*   **`<LV_VCV_CLOSE_RNG_MIN>`**: Calculated minimum level for the VCV close range.
*   **`<ANG_CUR_OFF_VCV>`**: Calculated angle at which current is switched off for the VCV.

## Logic Flow

The diagram processes inputs through a series of interconnected computational blocks (labeled `CLC_...` or `C_...`), each performing a specific calculation. The "V.6.8" and "V.6.11" symbols act as signal pass-throughs, possibly indicating versioning or validation interfaces.

1.  **Peak Control Duration Calculation (`CLC_T_DUR_VCV_CTL_PEAK`):**
    *   Takes battery voltage (`<VB>`), engine speed (`<N_32>`), VCV close range (`<VCV_CLOSE_RNG>`), and VCV close state (`<STATE_VCV_CLOSE_SL>`) to compute the duration for the VCV's peak actuation phase, outputting `<T_DUR_VCV_CTL_PEAK>`.

2.  **Control Delay Calculation (`CLC_T_DLY_VCV_CTL`):**
    *   Uses the calculated peak duration (`<T_DUR_VCV_CTL_PEAK>`), VCV close state (`<STATE_VCV_CLOSE_SL>`), and adaptive close PWM (`<PWM_VCV_CLOSE_SL_AD>`) to determine the VCV control delay, outputting `<T_DLY_VCV_CTL>`.

3.  **Hold Angle Calculation (`CLC_ANG_VCV_CTL_HOLD`):**
    *   Calculates an angle for holding the VCV, primarily based on engine speed (`<N_32>`), outputting `<ANG_VCV_CTL_HOLD>`.

4.  **Base PWM and Frequency Calculation (`CLC_PWM_VCV_CTL_0`):**
    *   Processes battery voltage (`<VB>`) and fuel pressure actuator temperature (`<TFPA>`) to derive the base PWM duty cycle (`<PWM_VCV_CTL_0_SL>`) and its frequency (`<FRQ_PWM_VCV_CTL_0_SL>`) for VCV control.

5.  **Peak Current Calculation (`CLC_CUR_VCV_CTL_PEAK`):**
    *   Inputs include battery voltage (`<VB>`), engine speed (`<N_32>`), and the existing (or feedback) peak current (`<CUR_VCV_CTL_PEAK>`) to compute raw (`<CUR_VCV_CTL_PEAK_RAW>`) and processed (`<CUR_VCV_CTL_PEAK>`) peak current values.

6.  **Hold Current (`C_CUR_VCV_CTL_HOLD`):**
    *   This appears to be a label for an output signal `<CUR_VCV_CTL_HOLD>`, which represents the hold current for the VCV. The block generating it isn't fully shown or it might be an output derived elsewhere.

7.  **Additional Close Delay/Angle Calculation (`CLC_ANG_DLY_VCV_CTL`):**
    *   A comprehensive block that uses many inputs: VCV close range (`<VCV_CLOSE_RNG>`), authorized adaptive level (`<LV_VCV_CLOSE_SL_AD_AUTH>`), VCV close state (`<STATE_VCV_CLOSE_SL>`), battery voltage (`<VB>`), engine speed (`<N_32>`), fuel pressure actuator temperature (`<TFPA>`), adaptive end PWM (`<PWM_VCV_CLOSE_SL_AD_END>`), and adaptive end duration (`<T_DUR_VCV_CLOSE_SL_AD_END>`). It outputs an additional delay time (`<T_DLY_VCV_CLOSE_ADD>`) and an additional delay angle (`<ANG_DLY_VCV_CLOSE_ADD>`) for VCV closing.

8.  **Current On Angle Calculation (`CLC_ANG_CUR_ON_VCV`):**
    *   Takes the additional delay angle (`<ANG_DLY_VCV_CLOSE_ADD>`) and VCV close range (`<VCV_CLOSE_RNG>`) to determine the angle at which current should be applied to the VCV (`<ANG_CUR_ON_VCV>`). It also calculates a minimum level for the VCV close range (`<LV_VCV_CLOSE_RNG_MIN>`).

9.  **Current Off Angle Calculation (`CLC_ANG_CUR_OFF_VCV`):**
    *   This final calculation block uses the current on angle (`[ANG_CUR_ON_VCV]`), hold angle (`[ANG_VCV_CTL_HOLD]`), peak duration (`[T_DUR_VCV_CTL_PEAK]`), control delay (`[T_DLY_VCV_CTL]`), VCV close state (`<STATE_VCV_CLOSE_SL>`), and engine speed (`<N_32>`) to compute the angle at which current should be switched off for the VCV (`<ANG_CUR_OFF_VCV>`). This output is critical for the precise timing of VCV de-actuation.

The entire flow aims to translate various operational parameters and desired VCV states into a set of precise control signals for voltage, current, duration, and angular timing, facilitating closed-loop control of the fuel pressure VCV.


--- Page 234 ---

This page contains two Simulink-like diagrams. I will analyze each diagram separately as they describe distinct but related functionalities.

---

## Analysis of Figure 43.15.53: Duration for pull-in phase during VCV closing

### Primary Function
This diagram calculates `T_DUR_VCV_CTL_PEAK`, which represents the required duration for the "pull-in" or "peak current" phase of a Valve Control Valve (VCV) during its closing operation. This duration is determined based on various operational parameters, including battery voltage, engine speed, and VCV closing range, and is subject to conditions related to the VCV's closing state and PWM input.

### Inputs
*   **<STATE_VCV_CLOSE_SL>**: A boolean or enumerated signal indicating the current sliding state of the VCV closing process.
*   **AD_PWM**: An analog-to-digital value representing a PWM signal, likely a reference or commanded value.
*   **STATE_VCV_CLOSE_SL (input to comparison)**: Potentially a threshold or reference value for the VCV closing state.
*   **<VB>**: Represents the vehicle's battery voltage, used as an independent variable (X-axis) for a 1D lookup table.
*   **<N_32>**: Represents an engine speed or rotational speed, used as an independent variable (X-axis) for a 2D lookup table.
*   **<VCV_CLOSE_RNG>**: Represents a range or specific parameter related to VCV closing, used as a dependent variable (Y-axis) for a 2D lookup table.

### Outputs
*   **<T_DUR_VCV_CTL_PEAK>**: The calculated duration for the peak control phase of the VCV, likely in milliseconds or seconds.

### Logic Flow
1.  **VCV State and PWM Condition Check (Top Path):**
    *   The `AD_PWM` signal and `STATE_VCV_CLOSE_SL` (the reference/threshold) are fed into a comparison block (symbol `>=` or similar, labeled V.6.6). This block evaluates a condition, likely checking if the current PWM exceeds a certain threshold or if the VCV closing state meets a specific criterion. The output of this comparison (e.g., a boolean true/false or a numeric value) acts as a control signal for the final output stage.

2.  **Voltage-Dependent Base Duration Lookup (Middle Path):**
    *   The `<VB>` (battery voltage) input is used as the x-axis (`x_val`) for a 1D lookup table named `IP_T_DUR_VCV_CTL_PEAK_SL` (V.7.11). This table outputs an `IP_val`, which represents a base duration or a scaling factor for the peak control phase, adjusted for voltage variations.

3.  **Speed/Range-Dependent Factor Lookup (Bottom Path):**
    *   The `<N_32>` (engine speed) input is used as the x-axis (`x_val`) and `<VCV_CLOSE_RNG>` (VCV closing range) is used as the y-axis (`y_val`) for a 2D lookup table named `IP_FAC_T_DUR_VCV_CTL_PEAK` (V.7.11). This table outputs another `IP_val`, representing a multiplicative factor or adjustment for the peak control phase based on engine operating conditions.

4.  **Combined Duration Calculation:**
    *   The `IP_val` from the voltage-dependent lookup table and the `IP_val` from the speed/range-dependent lookup table are multiplied together using a multiplication block (`X`, V.7.8). This step combines the base duration (or factor) with an operational adjustment factor, resulting in a preliminary duration value.

5.  **Final Output Conditioning:**
    *   The result of the multiplication block (the preliminary duration), along with the output from the top-path condition check, are fed into a final conditioning block (labeled "Check ~= 0", V.6.10). This block likely functions as a selector, limiter, or override. It might select the calculated duration if the initial condition is met, or apply a default/minimum value if the condition is not met, potentially ensuring a valid duration is always output. The ultimate output of this block is the final `<T_DUR_VCV_CTL_PEAK>`.

---

## Analysis of Figure 43.15.54: Delay time during soft closing of VCV

### Primary Function
This diagram calculates `T_DLY_VCV_CTL`, which represents a specific delay time required during the "soft closing" phase of the Valve Control Valve (VCV). This delay is determined by the VCV's PWM signal for soft closing, VCV state, a general PWM signal, and the previously calculated peak control duration.

### Inputs
*   **<STATE_VCV_CLOSE_SL>**: A boolean or enumerated signal indicating the current sliding state of the VCV closing process.
*   **PWM_VCV_CLOSE_SL_AD**: An analog-to-digital value representing the specific PWM signal used for the VCV's soft closing.
*   **AD_PWM**: A general analog-to-digital PWM value or reference.
*   **STATE_VCV_CLOSE_SL (input to comparison)**: Potentially a threshold or reference value for the VCV closing state.
*   **<T_DUR_VCV_CTL_PEAK>**: The output duration from the previous calculation (Figure 43.15.53), representing the pull-in phase duration.

### Outputs
*   **<T_DLY_VCV_CTL>**: The calculated delay time for VCV control during the soft closing phase, likely in milliseconds or seconds.

### Logic Flow
1.  **VCV State and PWM Condition Check (Top Path):**
    *   The `AD_PWM` signal and `STATE_VCV_CLOSE_SL` (the reference/threshold) are fed into a comparison block (symbol `>=` or similar, labeled V.6.6). This is identical to the first diagram's condition check, evaluating a condition related to the general PWM and VCV closing state. The output (e.g., boolean) acts as a control signal for the final output stage.

2.  **Soft Closing PWM-Dependent Delay Lookup (Middle Path):**
    *   The `PWM_VCV_CLOSE_SL_AD` input (the specific soft closing PWM) is used as the x-axis (`x_val`) for a 1D lookup table named `IP_T_DLY_VCV_CTL_SL` (V.7.11). This table outputs an `IP_val`, which represents a base delay time or a scaling factor for the soft closing delay, specifically adjusted based on the soft closing PWM signal.

3.  **Final Output Conditioning:**
    *   The `IP_val` from the soft closing PWM lookup table, the output from the top-path condition check, and the previously calculated `<T_DUR_VCV_CTL_PEAK>` are all fed into a final conditioning block (labeled "Check ~= 0", V.6.10). This block, similar to the first diagram, likely functions as a selector, limiter, or adder. It might combine the base delay from the lookup table, the result of the condition check, and potentially incorporate or use the `<T_DUR_VCV_CTL_PEAK>` (perhaps as a minimum delay, an additive component, or part of a timing sequence) to produce the final delay. The ultimate output of this block is the final `<T_DLY_VCV_CTL>`.


--- Page 235 ---

This page contains three distinct Simulink-style diagrams, each representing a sub-function within a larger "Fuel pressure actuator control" system (FUSL).

## Function
The primary function of these diagrams is to calculate various control parameters for a Volume Control Valve (VCV) within a fuel pressure actuator system. Specifically, they determine:
1.  The VCV's holding angle.
2.  The Pulse Width Modulation (PWM) duty cycle and frequency for VCV actuation during specific phases (pick-up and soft closing).
3.  A closed-loop current setpoint for the VCV during its peak operating phase, including a raw value and a hysteretically controlled final value.
Collectively, these blocks contribute to the precise electronic control of the VCV, which is critical for fuel pressure regulation.

## Inputs
Across all three diagrams, the key inputs are:
*   `<N_32>`: Likely represents engine speed (e.g., in RPM).
*   `<VB>`: Represents battery voltage.
*   `<TFPA>`: Likely represents Fuel Pressure Actuator Temperature.
*   `<CUR_VCV_CTL_PEAK>`: This is a feedback signal, representing the actual (or previously commanded/smoothed) VCV current during the peak phase, used as an input to the hysteretic controller.

## Outputs
Across all three diagrams, the key outputs are:
*   `<ANG_VCV_CTL_HOLD>`: The calculated holding angle for the VCV.
*   `<PWM_VCV_CTL_0_SL>`: The calculated PWM duty cycle for VCV actuation.
*   `<FRQ_PWM_VCV_CTL_0_SL>`: The calculated or configured PWM frequency for VCV actuation.
*   `<CUR_VCV_CTL_PEAK_RAW>`: The raw, map-derived peak current setpoint for the VCV.
*   `<CUR_VCV_CTL_PEAK>`: The final, hysteretically controlled peak current setpoint for the VCV.

## Logic Flow

The logic is distributed across three functional blocks:

### 1. VCV Holding Angle (Figure 43.15.55)
*   **Step 1: Input Acquisition.** The engine speed (`<N_32>`) is acquired.
*   **Step 2: Lookup Table Processing.** This `<N_32>` value serves as the input ('x_val') to a 1-dimensional lookup table (or calibration map) named "IP_ANG_VCV_CTL_HOLD" (version V.7.11). This map contains predefined angle values corresponding to different engine speeds.
*   **Step 3: Output Generation.** The output of the lookup table ('IP_val') is directly assigned as the VCV holding angle (`<ANG_VCV_CTL_HOLD>`).

### 2. Duty Cycle for VCV Actuation (Figure 43.15.56)
*   **Step 1: Input Acquisition.** Battery voltage (`<VB>`) and Fuel Pressure Actuator Temperature (`<TFPA>`) are acquired.
*   **Step 2: Duty Cycle Lookup Table Processing.** The battery voltage (`<VB>`) acts as the 'x_val' and the temperature (`<TFPA>`) as the 'y_val' for a 2-dimensional lookup table named "IP_PWM_VCV_CTL_0_SL" (version V.7.11). This map determines the appropriate PWM duty cycle based on these two parameters. The output of this map ('IP_val') becomes the calculated PWM duty cycle.
*   **Step 3: Frequency Configuration.** A constant or calibrated parameter "C_FRQ_PWM_VCV_CTL_0_SL" (version V.6.11) is retrieved. This parameter directly defines the PWM frequency.
*   **Step 4: Output Generation.** The calculated PWM duty cycle is output as `<PWM_VCV_CTL_0_SL>`, and the configured frequency is output as `<FRQ_PWM_VCV_CTL_0_SL>`.

### 3. Set Point for VCV Current Closed Loop Control (Figure 43.15.57)
*   **Step 1: Input Acquisition.** Battery voltage (`<VB>`), engine speed (`<N_32>`), and the current feedback signal (`<CUR_VCV_CTL_PEAK>`) are acquired.
*   **Step 2: Raw Current Setpoint Lookup.** Battery voltage (`<VB>`) serves as 'x_val' and engine speed (`<N_32>`) as 'y_val' for a 2-dimensional lookup table "IP_CUR_VCV_CTL_PEAK" (version V.7.11). The output 'IP_val' from this map represents a raw, desired peak current.
*   **Step 3: Raw Setpoint Output.** This 'IP_val' is then passed through an intermediate block labeled "V.6.8" (likely a scaling factor, gain, or simple function) and output as the raw peak current setpoint (`<CUR_VCV_CTL_PEAK_RAW>`).
*   **Step 4: Hysteretic Control.** The 'IP_val' (from the map), the raw setpoint (`<CUR_VCV_CTL_PEAK_RAW>`), and the feedback current (`<CUR_VCV_CTL_PEAK>`) are all fed into a hysteretic control block "CLC_HYS" (version X.2.1.2.2.3.1.2.1.5). This block applies hysteretic logic, which typically helps to stabilize control systems by preventing rapid toggling or oscillation around a setpoint, especially when dealing with noisy feedback or system non-linearities.
*   **Step 5: Final Setpoint Output.** The output of the "CLC_HYS" block is the final, processed peak current setpoint (`<CUR_VCV_CTL_PEAK>`), which would then be sent to a lower-level current driver to control the VCV.


--- Page 236 ---

This page contains two distinct Simulink diagrams, both related to "FUSL, Fuel pressure actuator control," as indicated by the title.

---

## Function

The image displays two Simulink diagrams that implement control logic for a fuel pressure actuator system.

1.  **Top Diagram (Figure 43.15.58): "Hysteresis for current set point during peak phase"**
    This diagram implements a hysteresis function for the VCV (Volume Control Valve) control current peak set point. Its primary function is to smooth and stabilize the target peak current by introducing a deadband or hysteresis, preventing rapid or unnecessary changes based on the raw input and a previous control value, while also enforcing a minimum limit.

2.  **Bottom Diagram (Figure 43.15.59): "Calculation of mechanical delay time and angle between VCV current feed and VCV closing"**
    This diagram calculates an additional mechanical delay time and a corresponding delay angle for the VCV closing operation. These calculations compensate for various system parameters, including PWM signals, operational states, durations, battery voltage, temperature, and engine speed, using a series of look-up tables and arithmetic operations.

---

## Inputs

**For Figure 43.15.58 (Top Diagram):**
*   `<CUR_VCV_CTL_PEAK_RAW>`: Raw current VCV control peak value (green block).
*   `C_CUR_HYS_VCV_CTL_PEAK`: Constant hysteresis current value for the VCV control peak (constant).
*   `_CUR_VCV_CTL_PEAK_AD`: Adjusted/actual (likely feedback of previous output or an internal state) current VCV control peak.
*   `C_CUR_VCV_CTL_PEAK_MIN`: Minimum current VCV control peak (constant).

**For Figure 43.15.59 (Bottom Diagram):**
*   `<VCV_CLOSE_RNG>`: VCV closing range (green block).
*   `<PWM_VCV_CLOSE_SL_AD_END>`: Pulse-Width Modulation value for VCV closing end (slave adjusted) (green block).
*   `<STATE_VCV_CLOSE_SL>`: State of VCV closing (slave) (green block).
*   `AD_PWM`: Analog-to-digital PWM value (green block).
*   `<T_DUR_VCV_CLOSE_SL_AD_END>`: Duration of VCV closing (slave adjusted end) (green block).
*   `<LV_VCV_CLOSE_SL_AD_AUTH>`: Authority for VCV closing (slave adjusted) (green block).
*   `<VB>`: Battery voltage (green block).
*   `<TFPA>`: Fuel pressure actuator temperature (green block).
*   `<N_32>`: Engine speed (or a related 32-bit rotational speed) (green block).
*   `C_T_PLS_DIAG_VCV`: Constant for pulse diagnosis of VCV (constant).

---

## Outputs

**For Figure 43.15.58 (Top Diagram):**
*   `<CUR_VCV_CTL_PEAK>`: Final current VCV control peak value after hysteresis and limiting (blue block).

**For Figure 43.15.59 (Bottom Diagram):**
*   `<T_DLY_VCV_CLOSE_ADD>`: Additional mechanical delay time for VCV closing (blue block).
*   `<ANG_DLY_VCV_CLOSE_ADD>`: Additional mechanical delay angle for VCV closing (blue block).

---

## Logic Flow

**Figure 43.15.58: Hysteresis for current set point during peak phase**

1.  **Define Hysteresis Bands:** The internal signal `_CUR_VCV_CTL_PEAK_AD` (representing the current or previous stable peak current) is used as a reference.
    *   An upper threshold is calculated by adding `C_CUR_HYS_VCV_CTL_PEAK` to `_CUR_VCV_CTL_PEAK_AD`.
    *   A lower threshold is calculated by subtracting `C_CUR_HYS_VCV_CTL_PEAK` from `_CUR_VCV_CTL_PEAK_AD`.
2.  **Compare Raw Input:** The raw input `<CUR_VCV_CTL_PEAK_RAW>` is compared against these thresholds:
    *   It's checked if `<CUR_VCV_CTL_PEAK_RAW>` is less than the upper threshold (`<CUR_VCV_CTL_PEAK_AD + C_CUR_HYS_VCV_CTL_PEAK>`).
    *   It's checked if `<CUR_VCV_CTL_PEAK_RAW>` is greater than the lower threshold (`<CUR_VCV_CTL_PEAK_AD - C_CUR_HYS_VCV_CTL_PEAK>`).
3.  **Hysteresis Implementation:** The results of these comparisons feed into "Check ~= 0" blocks (likely Simulink Hysteresis or Switch blocks combined with a memory element). These blocks ensure that the output `_CUR_VCV_CTL_PEAK_AD` only updates to `<CUR_VCV_CTL_PEAK_RAW>` when the raw value crosses the defined hysteresis bands. If the raw value is within the bands, the output retains its previous value.
4.  **Minimum Limiting:** The output of the hysteresis logic is then compared with `C_CUR_VCV_CTL_PEAK_MIN` using a Minimum block (implied by the converging lines and the context of a limit). The final output `<CUR_VCV_CTL_PEAK>` is the maximum of the hysteresis output and `C_CUR_VCV_CTL_PEAK_MIN`, effectively enforcing a minimum current set point.

**Figure 43.15.59: Calculation of mechanical delay time and angle**

1.  **Delay Time Calculation (`<T_DLY_VCV_CLOSE_ADD>`):**
    *   **Input Processing:**
        *   `<VCV_CLOSE_RNG>` is checked for equality to 0.
        *   `<PWM_VCV_CLOSE_SL_AD_END>` passes through a hysteresis/rate limiter.
        *   `<STATE_VCV_CLOSE_SL>` is compared to `AD_PWM` using a less-than-or-equal-to operator, and the boolean result passes through another hysteresis/rate limiter.
        *   `C_T_PLS_DIAG_VCV` passes through a hysteresis/rate limiter.
    *   **Look-up Table Calculations:** Various look-up tables (`IP_val` blocks, potentially 1D or 2D) are used to determine intermediate delay components:
        *   `IP_T_DLY_VCV_CLOSE_SL_PWM` is derived from `<PWM_VCV_CLOSE_SL_AD_END>`.
        *   `IP_T_DLY_VCV_CLOSE_SL_T_DUR` is derived from `<T_DUR_VCV_CLOSE_SL_AD_END>`.
        *   `IP_FAC_VB_T_DUR_VCV_CTL` is derived from `<LV_VCV_CLOSE_SL_AD_AUTH>` and `<VB>` (likely a 2D look-up table, or two 1D tables multiplied). This value is then further multiplied by a second `IP_FAC_VB_T_DUR_VCV_CTL` (the diagram shows two multiplicative blocks in series, where the second input to the first multiplier and the input to the second multiplier are derived from similar variables, suggesting complex compensation based on voltage and authority).
        *   `IP_FAC_TFU_T_DUR_VCV_CTL` is derived from `<TFPA>`.
        *   `IP_T_DLY_VCV_CLOSE_ADD_3` is derived from `<N_32>` and `<VCV_CLOSE_RNG>` (likely a 2D look-up table).
    *   **Summation and Final Conditioning:** The outputs from the various hysteresis/rate limiters and the look-up table calculations are summed together. This sum then passes through a final hysteresis/rate limiter ("Check ~= 0") to produce `<T_DLY_VCV_CLOSE_ADD>`.

2.  **Delay Angle Calculation (`<ANG_DLY_VCV_CLOSE_ADD>`):**
    *   The calculated delay time `<T_DLY_VCV_CLOSE_ADD>` is multiplied by a constant `0.006`.
    *   This result is then multiplied by the engine speed `<N_32>`.
    *   The final product yields the `<ANG_DLY_VCV_CLOSE_ADD>`, converting the time delay into an angular delay, likely in crankshaft degrees, based on engine rotational speed.


--- Page 237 ---

This page contains two Simulink-like diagrams (Figure 43.15.60 and Figure 43.15.61) related to "FUSL, Fuel pressure actuator control," specifically for a VCV (Volume Control Valve). The diagrams illustrate the calculation of angles for initiating and terminating the current feed to this VCV.

---

## Function

The primary function of these two interconnected diagrams is to calculate the precise crankshaft angles at which the current feed to a Volume Control Valve (VCV) should begin and end. This is crucial for controlling the VCV's operation, likely impacting fuel pressure regulation.
*   **Figure 43.15.60** calculates the angle to begin the VCV current feed (`<ANG_CUR_ON_VCV>`) and a minimum effective range for VCV closing (`<LV_VCV_CLOSE_RNG_MIN>`).
*   **Figure 43.15.61** calculates the angle to end the VCV current feed (`<ANG_CUR_OFF_VCV>`), based on the start angle, control states, hold times, and speed-dependent durations.

## Inputs

**For Figure 43.15.60 (Angle to begin current feed of the VCV):**
*   `<ANG_DLY_VCV_CLOSE_ADD>`: An angle delay or offset value for VCV closing.
*   `<VCV_CLOSE_RNG>`: The target range or duration (in angle units) for the VCV closing event.
*   `C_VCV_CLOSE_RNG_MIN_CLL_CTL`: A constant representing the minimum allowed VCV close range, possibly under current limit control.

**For Figure 43.15.61 (Angle to end current feed of the VCV):**
*   `<STATE_VCV_CLOSE_SL>`: A state variable indicating the VCV closing condition (likely a numerical state or flag).
*   `AD_PWM`: An Analog-to-Digital converted Pulse Width Modulation value, possibly representing a commanded current or position.
*   `<ANG_CUR_ON_VCV>`: The angle at which the VCV current feed began (output from Figure 43.15.60).
*   `<ANG_VCV_CTL_HOLD>`: An angle duration for holding the VCV control.
*   `<T_DLY_VCV_CTL>`: A time delay for the VCV control.
*   `C_T_OFS_VCV_CTL_SL`: A constant time offset for the VCV control.
*   `<T_DUR_VCV_CTL_PEAK>`: The peak duration (time) for VCV control.
*   `<N_32>`: An engine speed-related signal (likely RPM scaled by a factor like 32).
*   `0.006`: A constant scaling factor (e.g., to convert units or apply a time constant).
*   `C_ANG_CUR_OFF_VCV_MIN`: A constant minimum angle for turning off the VCV current.

## Outputs

**From Figure 43.15.60:**
*   `<ANG_CUR_ON_VCV>`: The calculated crankshaft angle at which the current feed to the VCV should begin.
*   `<LV_VCV_CLOSE_RNG_MIN>`: The lower limit or effective minimum of the VCV close range, ensuring it meets a certain threshold.

**From Figure 43.15.61:**
*   `<ANG_CUR_OFF_VCV>`: The calculated crankshaft angle at which the current feed to the VCV should end.

## Logic Flow

**Figure 43.15.60: Angle to begin current feed of the VCV**

1.  **Calculate `<ANG_CUR_ON_VCV>`:**
    *   The input `<ANG_DLY_VCV_CLOSE_ADD>` (an angle delay) and `<VCV_CLOSE_RNG>` (the closing range) are summed together.
    *   The result of this summation directly determines `<ANG_CUR_ON_VCV>`, suggesting the start angle is based on a base angle and the required closing duration.
2.  **Calculate `<LV_VCV_CLOSE_RNG_MIN>`:**
    *   The input `<VCV_CLOSE_RNG>` is compared with the constant `C_VCV_CLOSE_RNG_MIN_CLL_CTL` using a Greater Than (>) block.
    *   This block effectively determines the maximum of the two inputs (`max(<VCV_CLOSE_RNG>, C_VCV_CLOSE_RNG_MIN_CLL_CTL)`). This ensures that the effective VCV close range (`<LV_VCV_CLOSE_RNG_MIN>`) is never below the specified minimum constant, which is likely for current limit control.

**Figure 43.15.61: Angle to end current feed of the VCV**

1.  **Calculate Candidate End Angle (Upper Path):**
    *   The state variable `<STATE_VCV_CLOSE_SL>` is compared with `AD_PWM` (Analog-to-Digital PWM value) using a Greater Than or Equal To (>=) block. The boolean result (true/false, converted to 1 or 0) indicates if the VCV closing state condition is met relative to the PWM.
    *   This boolean result is then added, along with `<ANG_CUR_ON_VCV>` (the start angle from Figure 43.15.60), `<ANG_VCV_CTL_HOLD>` (a control hold angle), and the raw numerical value of `<STATE_VCV_CLOSE_SL>`, in a multi-input Add block.
    *   The sum represents a first candidate for the VCV current-off angle, taking into account the start angle, hold duration, and the influence of the VCV closing state and PWM.

2.  **Calculate Minimum Duration-Based Angle (Lower Path):**
    *   A time sum is calculated by adding `<T_DLY_VCV_CTL>` (time delay) and `C_T_OFS_VCV_CTL_SL` (time offset constant), then adding `<T_DUR_VCV_CTL_PEAK>` (peak duration). This results in a total effective time duration.
    *   A speed-dependent denominator is calculated by multiplying `<N_32>` (engine speed) by the constant `0.006`. The diagram includes a "Check ~= 0" for this result, implying a division-by-zero prevention or specific handling if the denominator is zero.
    *   The total effective time duration is divided by the speed-dependent denominator. This converts the time duration into an equivalent angle based on engine speed.
    *   The result of this division is then compared with the constant `C_ANG_CUR_OFF_VCV_MIN` using a Max block. This ensures that the calculated angle to end current feed (based on duration) is at least the specified minimum angle. This value represents a second candidate for the VCV current-off angle.

3.  **Determine Final `<ANG_CUR_OFF_VCV>`:**
    *   A final Max block takes the two candidate angles (from step 1 and step 2) as inputs.
    *   It outputs the larger of these two values.
    *   This maximum value is assigned to `<ANG_CUR_OFF_VCV>`, effectively setting the VCV current off angle to the latest point determined by either the state-dependent calculation or the minimum duration-based calculation, thus ensuring all critical conditions for VCV operation are met.


--- Page 238 ---

This image contains a Simulink diagram.

## Function
This Simulink diagram's primary function is to compute and manage the Pulse Width Modulation (PWM) and timing parameters for the actuation of a Volume Control Valve (VCV) within a fuel pressure control system. It determines duty cycles, frequencies, and durations for different operational phases (e.g., peak, hold, stationary, freewheeling) based on commanded current setpoints, battery voltage, and various system states and configurable constants. It acts as a closed-loop control component, setting the target actuation signals for the VCV.

## Inputs
*   **Current Setpoints:**
    *   `<CUR_VCV_CTL_PEAK>`: Commanded current for the VCV's peak phase.
    *   `<CUR_VCV_CTL_HOLD>`: Commanded current for the VCV's hold phase.
    *   `<CUR_VCV_CTL_0_SL>`: A default or initial current setpoint.
*   **System States / Feedback:**
    *   `<VB>`: Battery Voltage.
    *   `<STATE_VCV_CLOSE_SL>`: State indicating if the VCV is commanded to be closed.
    *   `<AD_PWM>`: Actual or measured PWM value (feedback or for comparison).
    *   `<CLF_CUR_CTL_MOD_VCV_SL>`: Current control mode for the VCV.
    *   `<TFPA>`: Target Fuel Pressure Actuation (likely a setpoint or status related to fuel pressure).
*   **Default / Configured PWM & Frequency:**
    *   `<PWM_VCV_CTL_0_SL>`: Default PWM duty cycle value.
    *   `<FRQ_PWM_VCV_CTL_0_SL>`: Default PWM frequency value.
*   **Time Parameters:**
    *   `<T_DLY_VCV_CTL>`: Delay time for VCV control.
    *   `<T_DUR_VCV_CTL_PEAK>`: Duration for the VCV's peak phase.
*   **Internal Constants (likely tunable parameters within the system):**
    *   `CLC_IP_PWM_CUR_VCV_REQ`: Request for PWM based on VCV current.
    *   `C_FRQ_PWM_VCV_CTL_PEAK`, `C_FRQ_PWM_VCV_CTL_1`, `C_FRQ_PWM_VCV_CTL_ST`, `C_FRQ_PWM_VCV_CTL_PEAK_ST`: Configured frequencies for various VCV states.
    *   `C_T_DUR_VCV_CTL_FW`: Configured freewheeling duration.
    *   `C_T_OFS_VCV_CTL_SL`: Time offset for VCV control.
    *   `CLF_CUR_CTL_MOD_VCV`: Current control mode constant.
    *   `C_FRQ_PWM_VCV_CTL_0`: Default PWM frequency constant.
    *   `C_CUR_VCV_OPL_CTL_MAX`: Maximum operating current constant.

## Outputs
*   **PWM Duty Cycles:**
    *   `PWM_VCV_CTL_PEAK`: PWM for VCV peak actuation.
    *   `PWM_VCV_CTL_1`: A specific PWM duty cycle for VCV.
    *   `PWM_VCV_CTL_ST`: PWM for VCV stationary/steady state.
    *   `<PWM_VCV_CTL_PEAK_ST>`: PWM for VCV peak stationary state.
    *   `PWM_VCV_CTL_0`: Default or initial VCV PWM.
*   **Frequencies:**
    *   `<FRQ_PWM_VCV_CTL_PEAK>`: Frequency for VCV peak actuation.
    *   `<FRQ_PWM_VCV_CTL_1>`: A specific frequency for VCV.
    *   `<FRQ_PWM_VCV_CTL_ST>`: Frequency for VCV stationary/steady state.
    *   `<FRQ_PWM_VCV_CTL_PEAK_ST>`: Frequency for VCV peak stationary state.
    *   `FRQ_PWM_VCV_CTL_0`: Default or initial VCV frequency.
*   **Durations / Times:**
    *   `<T_VCV_CTL_ST>`: Time duration for VCV stationary state.
    *   `<T_DUR_VCV_CTL_FW>`: Duration for VCV freewheeling.
    *   `T_DUR_VCV_CTL_HOLD_0`: Default or initial duration for VCV hold.
    *   `T_DUR_VCV_CTL_0_FW`: Default or initial duration for VCV freewheeling.
*   **Operational Limits / Modes:**
    *   `LF_CUR_CTL_MOD_VCV`: Active VCV current control mode.
    *   `CUR_VCV_OPL_CTL_MAX`: Maximum operational current for VCV.

## Logic Flow

The diagram processes inputs in parallel streams to derive various VCV control parameters:

1.  **Commanded Current to PWM Conversion:**
    *   The system selects between `<CUR_VCV_CTL_PEAK>` and `<CUR_VCV_CTL_HOLD>` to generate a `cur_vcv` signal. This `cur_vcv` is then mapped through a block (labeled `for {...} <pwm_vcv> / CLC_IP_PWM_CUR_VCV_REQ`) to produce a base PWM duty cycle, `pwm_vcv`.
    *   This `pwm_vcv` is then demultiplexed to generate `PWM_VCV_CTL_PEAK`, `PWM_VCV_CTL_1`, and `PWM_VCV_CTL_ST` outputs.
    *   Other PWM outputs like `<PWM_VCV_CTL_PEAK_ST>` and `<T_VCV_CTL_ST>` appear to be direct pass-throughs or set by other parts of the system (implied by the `<...>` notation).

2.  **Configured Frequencies and Freewheeling Duration:**
    *   A set of constants (`C_FRQ_PWM_VCV_CTL_PEAK`, `C_FRQ_PWM_VCV_CTL_1`, `C_FRQ_PWM_VCV_CTL_ST`, `C_FRQ_PWM_VCV_CTL_PEAK_ST`, `C_T_DUR_VCV_CTL_FW`) are directly outputted as frequencies or freewheeling duration. This suggests these are static, pre-defined configuration values.

3.  **Voltage-Dependent Parameter Calculation (Lookup Tables):**
    *   The battery voltage `<VB>` is used as the `y_val` input for multiple 2D lookup tables.
    *   `<CUR_VCV_CTL_PEAK>` as `x_val` is used to calculate the `IP_T_DUR_VCV_CTL_PEAK_BAS` (Peak Duration).
    *   `<CUR_VCV_CTL_HOLD>` as `x_val` is used to calculate the `IP_T_DUR_VCV_CTL_HOLD_BAS` (Hold Duration).
    *   `<PWM_VCV_CTL_0_SL>` as `x_val` is used to calculate the `IP_T_DUR_VCV_CTL_FW_BAS` (Freewheeling Duration).
    *   `<TFPA>` as `x_val` is used to calculate the `IP_CUR_VCV_OPL_CTL_MAX_BAS` (Maximum Operating Current).
    *   These calculated values (`P_val`) are then channeled into a subsequent selection logic.

4.  **Mode-Dependent Parameter Selection and Combination:**
    *   A comparison block (`>=`) checks if `<AD_PWM>` is greater than or equal to `<STATE_VCV_CLOSE_SL>`. The result, along with `<STATE_VCV_CLOSE_SL>`, feeds into a selection structure (`V.6.12`), which likely influences the activation of certain control paths based on the VCV's closing state.
    *   `<T_DLY_VCV_CTL>` and `<T_DUR_VCV_CTL_PEAK>` are summed (`+` block `V.7.7`) to derive a combined time value.
    *   A large multiplexing and selection network (involving blocks `V.7.7`, `V.7.11`, `V.6.11`) aggregates several inputs:
        *   The summed time parameter.
        *   Inputs like `<CLF_CUR_CTL_MOD_VCV_SL>`, `<PWM_VCV_CTL_0_SL>`, `<FRQ_PWM_VCV_CTL_0_SL>`, `<CUR_VCV_CTL_0_SL>`, `C_T_OFS_VCV_CTL_SL`.
        *   Outputs from the 2D lookup tables (e.g., `IP_T_DUR_VCV_CTL_HOLD_BAS`, `IP_CUR_VCV_OPL_CTL_MAX_BAS`).
        *   Other internal constants (`CLF_CUR_CTL_MOD_VCV`, `C_FRQ_PWM_VCV_CTL_0`, `C_CUR_VCV_OPL_CTL_MAX`).
    *   This section dynamically selects or blends these parameters based on operational logic (implicitly controlled by the connections and block types, even if the exact control signal isn't explicit).

5.  **Output Validation and Assignment:**
    *   The composite signal from the selection network is passed through a "Check ~= 0" block (`V.6.10`), which ensures the input is not zero, potentially for error handling or to prevent invalid states (e.g., division by zero if this leads to further calculations).
    *   Finally, a large demultiplexer (`V.6.8`) distributes these validated and selected parameters to their respective final outputs: `LF_CUR_CTL_MOD_VCV`, `PWM_VCV_CTL_0`, `FRQ_PWM_VCV_CTL_0`, `T_DUR_VCV_CTL_HOLD_0`, `CUR_VCV_OPL_CTL_MAX`, and `T_DUR_VCV_CTL_0_FW`.


--- Page 239 ---

## Function
This Simulink diagram, part of a "Fuel pressure actuator control" system, is designed to calculate the Pulse Width Modulation (PWM) duty cycle required for a Volume Control Valve (VCV). Its primary function is to convert a requested VCV current into a corresponding PWM signal. A key aspect is its adaptability: the calculation is parameterized or switched based on the specific type of fuel pump installed (e.g., Bosch HDP5 or Hitachi), ensuring the correct control for different hardware variants. The core duty cycle calculation structure itself is stated to be consistent across pump types, but it utilizes pump-specific calibrated control parameters.

## Inputs
*   **<cur_vcv>**: This is the primary input signal, representing the commanded or desired current for the Volume Control Valve.
*   **u (from V.7.16)**: A control signal, likely representing the `LC_SWI_VCV_TYP` switch. This input selects the type of fuel pump in use (e.g., an integer value '1' for Bosch HDP5 pump, '2' for Hitachi pump), thereby dictating which set of calibrated control parameters will be applied in the duty cycle calculation.
*   **Lookup Table Data (V.6.16, IP_PWM_CUR_VCV_REQ V.7.11)**: These represent the calibrated data sets (e.g., breakpoints and table values) that define the current-to-PWM mapping characteristics for the VCV. These tables are the source of the pump-specific parameters mentioned in the accompanying text.

## Outputs
*   **<pwm_vcv>**: This is the calculated Pulse Width Modulation (PWM) duty cycle value, which will be used to control the VCV actuator.

## Logic Flow
The logical flow describes the step-by-step process to derive the VCV's PWM duty cycle:

1.  **Input Current Pre-processing (V.6.16 Lookup Table):** The requested VCV current, provided as the `<cur_vcv>` signal, is first fed into a 1-D lookup table (identified as `V.6.16`). This lookup table converts the input current into an intermediate value, `x_val`. This step typically serves to linearize, scale, or preprocess the raw current signal for subsequent calculations.

2.  **Raw PWM Value Determination (IP_PWM_CUR_VCV_REQ V.7.11 Lookup Table):** The `x_val` obtained from the previous step is then used as the input to a second 1-D lookup table, named `IP_PWM_CUR_VCV_REQ` (identified as `V.7.11`). This lookup table outputs `IP_val`, which represents the initial or raw PWM duty cycle value corresponding to the `x_val`. This table embodies the fundamental current-to-PWM characteristic.

3.  **Pump Type Parameter Selection and Final Calculation (V.7.16 & C_0 Blocks):**
    *   The diagram shows a control input `u` connected to the `V.7.16` block. This `u` signal acts as a switch (representing `LC_SWI_VCV_TYP`) that indicates the specific fuel pump type (e.g., Bosch HDP5 or Hitachi).
    *   According to the accompanying text, while the overall "duty cycle calculation for the pumps is the same," the "current control parameters are split into the pump (manufacturer) type." This implies that the `V.7.16` block and the subsequent `C_0` block work together to apply pump-specific parameters to the `IP_val` and `x_val` (and potentially other implicit inputs).
    *   The `Init = zeros(1,2)` on `V.7.16` suggests potential initialization of internal states or specific outputs for this selection logic. The `C_0` block receives `IP_val`, `x_val`, and is influenced by the pump type selected via `V.7.16`. It performs the final calculations, incorporating the pump-specific characteristics to produce the precise duty cycle.

4.  **Output PWM Duty Cycle (<pwm_vcv>):** The final calculated and adjusted PWM duty cycle, derived from the pump-type-dependent logic within the `C_0` and `V.7.16` blocks, is then output as the `<pwm_vcv>` signal. This signal directly controls the Volume Control Valve.

*(Note: The 'For Iterator' block and its 'C_0' output at the beginning of the diagram are present but their direct functional connection to the primary `<cur_vcv>` to `<pwm_vcv>` calculation for a single instance is not explicitly shown in this isolated fragment. It could be part of a higher-level iteration or indexing mechanism.)*


--- Page 240 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink diagram is to calculate and consolidate a comprehensive set of control parameters for a Fuel Pressure Actuator, specifically focusing on the Volume Control Valve (VCV) holding phase. It determines the appropriate Pulse Width Modulation (PWM) duty cycles, frequencies, angular current values, and various timing durations required to operate the VCV, thereby regulating fuel pressure within an automotive system. The system accounts for different operational modes, including Safe-Limp (SL) and normal operation, as well as pick-up and engine start (MFP_START) phases.

## Inputs
The system takes a variety of input signals, including:

*   **VCV State & Authorization:**
    *   `clc_vcv_sl_off_open`: Control signal for VCV in Safe-Limp off/open state.
    *   `STATE_VCV_CLOSE_SL`: VCV close state in Safe-Limp mode.
    *   `LV_VCV_CLOSE_SL_AUTH`: Authorization level for VCV close in Safe-Limp.
    *   `LV_VCV_OPEN_SL_AUTH`: Authorization level for VCV open in Safe-Limp.
    *   `STATE_VCV`: General operational state of the VCV.
    *   `VCV_CLOSE_RNG`: VCV close range parameter.
*   **PWM & Adaptation Parameters:**
    *   `PWM_VCV_CLOSE_SL_AD`: PWM adaptation value for VCV close in Safe-Limp.
    *   `PWM_VCV_CLOSE_SL_AD_END`: End value for PWM adaptation of VCV close in Safe-Limp.
    *   `PWM_VCV_CTL_0_MIN`: Minimum PWM duty cycle for VCV control type 0.
*   **System Measurements & Setpoints:**
    *   `N_32`: Engine speed (e.g., in RPM).
    *   `FUP`: Actual fuel pressure.
    *   `FUP_SP`: Fuel pressure setpoint.
    *   `VB`: Battery voltage.
    *   `TFPA`: Temperature of the fuel pump actuator.
    *   `R_VCV`: Resistance of the VCV.
*   **Timing & Duration Parameters:**
    *   `T_DUR_VCV_CLOSE_SL_AD`: Duration of VCV close in Safe-Limp adaptation.
    *   `T_DUR_VCV_CTL_HOLD_0`: Duration for VCV control hold phase type 0.
    *   `T_DUR_VCV_CTL_FW`: Duration for VCV control forward.
    *   `T_DLY_VCV_CLOSE_ADD`: Additional delay time for VCV close.
    *   `T_FUP_MIN_VCV_LOCK`: Minimum fuel pressure lock time for VCV.
    *   `T_VCV_CTL_ST`: VCV control start time/state.
*   **Control Logic & Calibration:**
    *   `LC_SWI_VCV_TYP`: Logic switch to select between different VCV control types (Type 1 or Type 2).
    *   `VCV_OPEN_ADD`: Additional value for VCV open position.
    *   `C_CUR_VCV_OPL_CTL_MAX`: Calibrated maximum current for VCV operational control.

## Outputs
The system produces a consolidated bus signal named `clc_prm_vcv_act`, which contains the following VCV control parameters:

*   **PWM Duty Cycles:**
    *   `PWM_VCV_CTL_0`: PWM duty cycle for VCV control type 0 (e.g., pick-up, SL, VCV_OPEN, MFP_START).
    *   `PWM_VCV_CTL_1`: PWM duty cycle for VCV control type 1 (e.g., non-SL, normal operation).
    *   `PWM_VCV_CTL_0_MIN`: Minimum PWM duty cycle for VCV control type 0.
    *   `PWM_VCV_CTL_PEAK`: Peak PWM duty cycle for VCV control.
    *   `PWM_VCV_CTL_ST`: Start PWM duty cycle for VCV control.
*   **PWM Frequencies:**
    *   `FRQ_PWM_VCV_CTL_PEAK`: Peak frequency of VCV control PWM.
    *   `FRQ_PWM_VCV_CTL_ST`: Start frequency of VCV control PWM.
    *   `FRQ_PWM_VCV_CTL_1`: Frequency of VCV control PWM type 1.
*   **Current & Modulations:**
    *   `LF_CUR_CTL_MOD_VCV`: Low-frequency current control modulation for VCV.
    *   `ANG_CUR_OFF_VCV`: Angular current when VCV is commanded off.
    *   `ANG_CUR_ON_VCV`: Angular current when VCV is commanded on.
*   **Control Durations:**
    *   `T_DUR_VCV_CTL_PEAK`: Duration for VCV control peak.
    *   `T_DUR_VCV_CTL_HOLD_0`: Duration for VCV control hold phase type 0.
    *   `T_DUR_VCV_CTL_FW`: Duration for VCV control forward.
    *   `T_DLY_VCV_CLOSE_ADD`: Additional delay for VCV close.
    *   `T_FUP_MIN_VCV_LOCK`: Minimum fuel pressure lock time for VCV.
    *   `VCV_OPEN_ADD`: Additional VCV open value.
    *   `T_VCV_CTL_ST`: VCV control start time/state.

## Logic Flow
The diagram illustrates a multi-path calculation process that converges into a single output bus:

1.  **Core PWM and Frequency Calculation (Top Path):**
    *   A function-call subsystem, labeled `CLC_PWM_VCV_CTL` (represented by `f()`), receives various VCV state indicators, authorization flags, PWM adaptation values, battery voltage, VCV resistance, fuel pump temperature, and a minimum PWM duty cycle.
    *   This subsystem computes the fundamental PWM duty cycles (`PWM_VCV_CTL_0`, `PWM_VCV_CTL_1`), their corresponding frequencies, and other PWM-related parameters (e.g., peak, start values, low-frequency current modulation). These calculated values are then passed to a `BusMerge` block.

2.  **Conditional Angular Current and Duration Calculation (Middle Path - If-Else Block):**
    *   An `if-else` block, controlled by the `LC_SWI_VCV_TYP` signal, dynamically selects between two different VCV control strategies or "types". This allows for flexible control logic based on the VCV's operating characteristics or system configuration.
    *   **If `LC_SWI_VCV_TYP` is true (Type 1 selected):** The subsystem `CLC_ANG_T_DUR_VCV_CTL_TYP1` is activated. It takes a wide array of inputs, including PWM minimums, VCV states, authorizations, various duration parameters, engine speed, fuel pressure, battery voltage, and fuel pump temperature. It then calculates specific angular current values (for VCV on/off states) and precise control durations for different VCV phases (e.g., peak, hold, forward, delays, lock times). These outputs are directed to the `BusMerge` block.
    *   **If `LC_SWI_VCV_TYP` is false (Type 2 selected):** The subsystem `CLC_ANG_T_DUR_VCV_CTL_TYP2` is activated. Similar to Type 1, it processes a set of inputs (which may vary slightly from Type 1) and calculates its own set of angular current and duration parameters, also feeding them into the `BusMerge` block.

3.  **Constant Parameter Integration (Bottom Path):**
    *   Several constant values (1, 0) and a calibrated maximum current parameter (`C_CUR_VCV_OPL_CTL_MAX`) are directly fed into the `BusMerge` block. These likely represent fixed operational limits, default states, or reference values for the VCV control.

4.  **Parameter Consolidation and Final Output:**
    *   The `BusMerge` block acts as a central hub, combining all the calculated PWM parameters, frequencies, angular currents, timing durations, and integrated constant values from the preceding paths into a single, structured bus signal.
    *   This consolidated bus, named `clc_prm_vcv_act`, serves as the final output of this subsystem. It encapsulates all necessary control data to drive the VCV actuator in downstream modules, ensuring precise fuel pressure regulation according to current operational conditions and control strategies.


--- Page 242 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink diagram is to calculate the Pulse Width Modulation (PWM) duty cycles and associated frequencies for a Volume Control Valve (VCV), which acts as a fuel pressure actuator. This calculation specifically applies to the "VCV holding phase during normal states," as indicated by the accompanying text. The system considers various operational states, environmental conditions, and calibrated values to determine the appropriate control signals.

## Inputs
1.  `<STATE_VCV>`: The current operational state of the VCV (e.g., VCV_OPEN, MFP_START).
2.  `VCV_OPEN`: A specific state enumeration value for VCV Open.
3.  `MFP_START`: A specific state enumeration value for Main Fuel Pump Start.
4.  `<FUP>`: Actual Fuel Pressure.
5.  `<FUP_SP>`: Fuel Pressure Setpoint.
6.  `cond_if`: A boolean condition input for 'If-Else' blocks.
7.  `<LV_VCV_CLOSE_SL_AUTH>`: Authority status for VCV close (Speed Limiter related).
8.  `<STATE_VCV_CLOSE_SL>`: State of the VCV close speed limitation.
9.  `<PWM_VCV_CLOSE_SL_AD_END>`: PWM value for VCV close speed limit at the end of adjustment.
10. `<VCV_CLOSE_RNG>`: Range for VCV closing.
11. `<N_32>`: Engine speed or a related rotational speed.
12. `<PWM_VCV_CTL_0_MIN>`: Minimum PWM control value for VCV (specific to control path 0).
13. `<TFPA>`: Fuel Pressure Actuator Temperature (or similar temperature sensor).
14. `<PWM_VCV_CLOSE_SL_AD>`: PWM value for VCV close speed limit adjustment.
15. `<VB>`: Battery voltage or vehicle system voltage.
16. `<R_VCV>`: Resistance of the VCV actuator or a reference resistance.
17. `AD_ON`: A specific state enumeration value related to adjustment being ON for VCV close.
18. `C_PWM_MAX_COR_VCV_CTL_1`: Calibration constant for maximum PWM correction for VCV control path 1.
19. `C_FRQ_PWM_VCV_CUR_OPL_CTL`: Calibration constant for the operating PWM frequency for the VCV.

## Outputs
1.  `PWM_VCV_CTL_ST`: Steady-state or current PWM control duty cycle for the VCV.
2.  `PWM_VCV_CTL_0`: PWM control duty cycle for VCV (specific control path 0).
3.  `PWM_VCV_CTL_1`: PWM control duty cycle for VCV (specific control path 1).
4.  `<LF_CUR_CTL_MOD_VCV>`: Control mode of the VCV (fixed to 0 in this diagram).
5.  `<PWM_VCV_CTL_PEAK>`: Peak PWM control value for VCV (fixed to 100 in this diagram).
6.  `<PWM_VCV_CTL_PEAK_ST>`: Steady-state peak PWM control value for VCV (fixed to 100 in this diagram).
7.  `FRQ_PWM_VCV_CTL_ST`: Frequency of the steady-state PWM VCV control.
8.  `FRQ_PWM_VCV_CTL_PEAK`: Frequency of the peak PWM VCV control.
9.  `FRQ_PWM_VCV_CTL_0`: Frequency of the PWM VCV control path 0.
10. `FRQ_PWM_VCV_CTL_1`: Frequency of the PWM VCV control path 1.
11. `FRQ_PWM_VCV_CTL_PEAK_ST`: Frequency of the steady-state peak PWM VCV control.

## Logic Flow
The diagram calculates multiple PWM duty cycles and their corresponding frequencies based on a combination of state machines, logical operations, lookup tables, and arithmetic computations.

1.  **State and Condition Evaluation (Top-Left):**
    *   The diagram begins by evaluating several conditions related to the VCV's state (`<STATE_VCV>`) and fuel pressure.
    *   Comparators (`==`) check if `<STATE_VCV>` matches `VCV_OPEN` or `MFP_START`.
    *   Another comparator (`>`) checks if actual fuel pressure (`<FUP>`) exceeds the setpoint (`<FUP_SP>`).
    *   These comparison results are fed into `OR` and `AND` logical gates to generate intermediate boolean conditions (e.g., `cond_if`), which control downstream `If-Else` blocks.

2.  **`PWM_VCV_CTL_ST` Calculation (Upper Path):**
    *   An `If-Else` block, controlled by one of the `cond_if` signals, selects between two main branches.
    *   **"If" branch:** Involves a 1-D lookup table `IP_PWM_VCV_CTL_PULSE_ST` using `<TFPA>` as input. Its output is then multiplied by a factor determined by the "else" branch of a nested `If-Else` structure (controlled by the other `cond_if`).
    *   **"Else" branch:** Involves a 2-D lookup table `IP_FAC_TFPA_PWM_VCV_CTL_ST` using `<TFPA>` (x-axis) and another variable (likely related to state or condition) (y-axis). The output is multiplied by `<VB>`.
    *   The results from these branches are combined (added) and then passed through a saturation block (`Check >= 0`) to ensure non-negative values before outputting as `PWM_VCV_CTL_ST`.

3.  **`PWM_VCV_CTL_0` and `PWM_VCV_CTL_0_MIN` Calculation (Middle Path):**
    *   A large functional block `CLC_PWM_VCV_CTL_2_OPM` takes a significant number of inputs including various VCV close speed limit parameters, engine speed (`<N_32>`), temperature (`<TFPA>`), voltage (`<VB>`), and VCV resistance (`<R_VCV>`).
    *   This block calculates `PWM_VCV_CTL_0` and outputs a specific `PWM_VCV_CTL_0_MIN`.
    *   The `PWM_VCV_CTL_0` output is also passed through a `Check >= 0` saturation block.

4.  **`PWM_VCV_CTL_1` Calculation (Lower Path):**
    *   This path involves two 2-D lookup tables and a multiplication.
    *   `IP_VCV_BAS` uses an unlabeled input (`x_val`, likely a voltage or current) and `<R_VCV>` (`y_val`) to produce an output.
    *   `IP_FAC_COR_PWM_VCV_CTL_1` uses `<VB>` (`x_val`) and `<R_VCV>` (`y_val`) to produce a correction factor.
    *   These two lookup table outputs are multiplied.
    *   The result is then passed through a `min` block, limiting it by `C_PWM_MAX_COR_VCV_CTL_1`.
    *   A conditional logic based on `<STATE_VCV_CLOSE_SL> == AD_ON` seems to apply, but its direct influence on `PWM_VCV_CTL_1` isn't fully shown at the output. The diagram shows `PWM_VCV_CTL_1` as a direct output of the multiplication/min path.

5.  **Frequency and Fixed Value Outputs (Right Side):**
    *   A single calibration constant `C_FRQ_PWM_VCV_CUR_OPL_CTL` is directly routed to all five PWM frequency outputs: `FRQ_PWM_VCV_CTL_ST`, `FRQ_PWM_VCV_CTL_PEAK`, `FRQ_PWM_VCV_CTL_0`, `FRQ_PWM_VCV_CTL_1`, and `FRQ_PWM_VCV_CTL_PEAK_ST`. This implies a common operating frequency for all PWM signals related to the VCV.
    *   Constants `0` and `100` are directly assigned to `<LF_CUR_CTL_MOD_VCV>`, `<PWM_VCV_CTL_PEAK>`, and `<PWM_VCV_CTL_PEAK_ST>`. This suggests that in the analyzed "holding phase," these specific parameters have fixed, calibrated values.


--- Page 244 ---

This page does indeed contain a Simulink diagram.

## Function
This Simulink diagram's primary function is to calculate and control the Pulse Width Modulation (PWM) signals for a Volume Control Valve (VCV) within a fuel pressure actuator system. It determines a main control PWM value (`PWM_VCV_CTL_0`) and a minimum control PWM value (`PWM_VCV_CTL_0_MIN`) based on various operational states, vehicle parameters (like battery voltage and engine speed), and calibrated values. This control logic likely manages the timing and duration of the VCV actuation cycle.

## Inputs
The system takes the following inputs:
*   `<PWM_VCV_CTL_0_MIN>`: A baseline or initial minimum PWM value.
*   `<PWM_VCV_CLOSE_SL_AD>`: PWM value for VCV close, potentially for a slow adaptation mode.
*   `<PWM_VCV_CLOSE_SL_AD_END>`: End PWM value for VCV close, slow adaptation.
*   `<C_PWM_OFS_VCV_CTL_PULSE_SL_AD>`: An offset PWM value for the VCV control pulse during slow adaptation.
*   `<STATE_VCV_CLOSE_SL>`: A state variable indicating the current state of the VCV close slow adaptation process.
*   `<AD_ON>`: A boolean or flag indicating if adaptation is active/on.
*   `<AD_T_DUR>`: Adaptation time duration (possibly a specific state indicator).
*   `<VB>`: Battery voltage.
*   `<R_VCV>`: Resistance of the VCV, or a related electrical parameter.
*   `<LV_VCV_CLOSE_SL_AUTH>`: Authorization signal for VCV close slow adaptation.
*   `<N_32>`: Engine speed (often represented as 'N' for RPM in automotive systems).
*   `<VCV_CLOSE_RNG>`: A range parameter related to VCV closing.
*   `<TFPA>`: Temperature of the Fuel Pressure Actuator (or related component).
*   `<AD_PWM>`: A PWM value specifically related to adaptation.
*   `x_val`: Input for 1D look-up tables (its source is not directly shown in the visible diagram, but it would be a signal or constant).

## Outputs
The system produces the following outputs:
*   `<PWM_VCV_CTL_0>`: The primary calculated PWM duty cycle for the VCV.
*   `<PWM_VCV_CTL_0_MIN>`: A potentially adjusted or limited minimum PWM duty cycle for the VCV. (Note: An input with the same name exists; this output likely represents the processed/final minimum value for other parts of the system).

## Logic Flow

The logical flow calculates the final PWM values by combining several components, dynamically selected based on adaptation states and operational conditions. The "Check ~= 0" blocks are typically Simulink Switch blocks, where if the control input is non-zero (true), one input passes through, and if zero (false), the other input passes through. The "V.x.x" labels refer to version/module numbers within the Continental system.

1.  **State and Adaptation Condition Evaluation:**
    *   Several equality comparison blocks (`V.6.6`) compare the `STATE_VCV_CLOSE_SL` input with specific values like `AD_ON`, `AD_T_DUR`, and `AD_PWM`. These comparisons determine the active operational mode or adaptation state.
    *   The outputs of these equality checks feed into two OR gates (`V.6.7` and `V.6.8`). These OR gates combine various state conditions to generate control signals for the downstream switch blocks.

2.  **Calculation of PWM Components:**
    *   **Baseline/Offset PWM Path (Top Path):**
        *   `PWM_VCV_CLOSE_SL_AD` is added to `C_PWM_OFS_VCV_CTL_PULSE_SL_AD` (Adder, `V.7.7`).
        *   The output of a 1D Look-Up Table (`_P_PWM_VCV_CTL_PULSE_SL_AD`, `V.7.11`), which takes `x_val` as input, is added to the previous sum (Adder, `V.7.7`).
        *   This result then feeds into a 'Check ~= 0' switch (`V.6.10`), whose selection is controlled by an OR gate output.
    *   **Voltage/Speed Dependent Correction (Middle Path - `IP_VCV_OPEN_ADD`):**
        *   `VB` (battery voltage) and `N_32` (engine speed) are inputs to a 2D Look-Up Table (`IP_PWM_VCV_CTL_PULSE`, `V.7.11`).
        *   The output (`IP_val`) of this LUT is multiplied by `R_VCV` (Multiplier, `V.7.8`).
        *   This product feeds into another 'Check ~= 0' switch (`V.6.10`), controlled by an OR gate output.
    *   **Speed/Range/Temperature Dependent Correction (Lower Path - `IP_FAC_CLOSE_RNG_VCV_OPEN_ADD`):**
        *   `N_32` (engine speed) and `VCV_CLOSE_RNG` are inputs to a 2D Look-Up Table (`IP_FAC_CLOSE_RNG_PWM_VCV_CTL`, `V.7.11`).
        *   The output (`IP_val`) of this LUT is multiplied by `TFPA` (Multiplier, `V.7.8`).
        *   This product feeds into a third 'Check ~= 0' switch (`V.6.10`), controlled by an OR gate output.

3.  **Aggregation of Components for Main PWM Output (`PWM_VCV_CTL_0`):**
    *   The outputs from the three 'Check ~= 0' switches (from the Baseline, Voltage/Speed, and Speed/Range/Temperature paths) are summed together (Adder, `V.7.7`).
    *   This total sum then passes through a final 'Check ~= 0' switch (`V.6.10`), whose selection is controlled by the output of the OR gate `V.6.8`.
    *   The output of this final switch is the primary control signal, `<PWM_VCV_CTL_0>`.

4.  **Derivation of Minimum PWM Output (`PWM_VCV_CTL_0_MIN`):**
    *   The input `<PWM_VCV_CTL_0_MIN>` passes through a 'Check ~= 0' switch (`V.6.10`).
    *   The selection for this switch is determined by the output of an OR gate (`V.6.7`), which itself is fed by various state comparisons involving `STATE_VCV_CLOSE_SL` and `AD_PWM` or `AD_ON`. This suggests that the minimum PWM value might be conditionally passed through or potentially limited based on specific operational states.

In essence, the diagram intelligently combines various calibrated and dynamically calculated PWM components, enabling precise control of the VCV based on the vehicle's operating conditions and adaptation requirements.


--- Page 249 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram is titled "FUSL, Fuel pressure actuator control." Its primary function is to calculate various control parameters for a Fuel Pressure Valve Control Valve (VCV). These parameters include additive terms for valve opening, closing delays, specific phase durations (peak close, steady state, hold), and angular current values for valve actuation, all dynamically adjusted based on engine operating conditions, sensor inputs, and internal states. It also incorporates logic for a fuel pressure minimum lock condition.

## Inputs
The key inputs to this system, represented by green blocks or signal names in brackets, are:

*   **`<TFPA>`**: Turbocharger/Fuel Pump Absolute Pressure (or similar pressure sensor input).
*   **`<VB>`**: Battery Voltage.
*   **`<N_32>`**: Engine Speed (e.g., in RPM).
*   **`<VCV_CLOSE_RNG>`**: A parameter representing the VCV closing range or characteristic.
*   **`<FUP>`**: Current Fuel Pressure.
*   **`<STATE_VCV_CLOSE_SL>`**: The current state of the VCV closing sequence (e.g., `AD_PWM`, `OFF`).
*   **`<LV_VCV_CLOSE_SL_AUTH>`**: A boolean authorization signal for VCV closing.
*   **`<PWM_VCV_CLOSE_SL_END>`**: A Pulse Width Modulation (PWM) signal value associated with the end of VCV closing.
*   **`<PWM_VCV_CTL_0_MIN>`**: Minimum PWM value for VCV control at zero.
*   **`<LV_VCV_OPEN_SL_AUTH>`**: A boolean authorization signal for VCV opening.
*   **`[ang_dly_ofs]`**: An angular delay offset.
*   **Constants/Parameters**: Various `C_...` prefixed values (e.g., `C_FUP_MIN_LOCK_VCV`, `C_T_MAX_FUP_MIN`, `C_T_DUR_VCV_CTL_PEAK_CLOSE_SL`) representing calibrated thresholds, limits, and fixed durations.

## Outputs
The key outputs from this system, represented by blue blocks or signal names in brackets, are:

*   **`<VCV_OPEN_ADD>`**: An additive term used in VCV opening calculations.
*   **`[lv_fup_min_lock]`**: A boolean flag indicating if a fuel pressure minimum lock condition is active.
*   **`<T_FUP_MIN_VCV_LOCK>`**: The current timer value for the fuel pressure minimum lock condition.
*   **`<T_DLY_VCV_CLOSE_ADD>`**: A calculated delay duration for VCV closing.
*   **`<T_DLY_VCV_CLOSE_ADD_2>`**: Another calculated delay duration for VCV closing.
*   **`<T_VCV_CTL_PEAK_CLOSE_SL>`**: The calculated duration for the VCV control's peak close phase.
*   **`<T_VCV_CTL_ST>`**: The calculated duration for the VCV control's steady-state phase.
*   **`<T_DUR_VCV_CTL_HOLD_0>`**: The calculated duration for holding the VCV in a specific position.
*   **`<ANG_CUR_OFF_VCV>`**: An angular current or angle-related parameter for the VCV "off" state.
*   **`<ANG_CUR_ON_VCV>`**: An angular current or angle-related parameter for the VCV "on" state.
*   **`<T_DUR_VCV_CTL_FW>`**: A feed-forward duration for VCV control.

## Logic Flow

The logical flow can be broadly divided into several parallel processing paths that interact to produce the final control parameters. The system operates in a discrete time domain with a sample time `dT = 0.02s` for the timer/integrator blocks.

1.  **VCV Opening Additive Term Calculation:**
    *   Inputs `<TFPA>`, `<VB>`, `<N_32>`, and `<VCV_CLOSE_RNG>` are fed into individual 1D or 2D lookup tables (`IP_FAC_...`).
    *   The outputs of `IP_FAC_TFPA_VCV_OPEN_ADD`, `IP_FAC_VB_VCV_OPEN_ADD`, and `IP_FAC_N32_VCV_OPEN_ADD` are multiplied together.
    *   This product is then summed with the output of `IP_FAC_VCV_CLOSE_RNG_VCV_OPEN_ADD`.
    *   The final sum is output as **`<VCV_OPEN_ADD>`**.

2.  **Fuel Pressure Minimum Lock Logic:**
    *   The input fuel pressure **`<FUP>`** is compared to a calibration constant `C_FUP_MIN_LOCK_VCV`.
    *   If `<FUP>` is less than `C_FUP_MIN_LOCK_VCV`, a timer (`T` block with `dT=0.02s`) starts, capped by `C_T_MAX_FUP_MIN`. This timer's output is **`<T_FUP_MIN_VCV_LOCK>`**.
    *   Another timer (or processing block) takes the output of the first timer and compares it to `C_T_PLS_DIAG_VCV`.
    *   An `AND` gate combines this comparison result with another condition (likely `NOT lv_fup_min_lock_tmp`) to produce the boolean output **`[lv_fup_min_lock]`**. This suggests a diagnostic or protection mechanism where low fuel pressure for a certain duration triggers a lock.

3.  **VCV Closing Delay and Duration Calculations:**
    *   Multiple lookup tables (`IP_T_DLY_VCV_CLOSE_SL_PWM`, `IP_T_DLY_VCV_CLOSE_SL_T_DUR`, `IP_T_DLY_VCV_CLOSE_ADD_3`) use combinations of `<STATE_VCV_CLOSE_SL>`, `<PWM_VCV_CLOSE_SL_END>`, `<N_32>`, and `<VCV_CLOSE_RNG>` to calculate base delay values.
    *   These base delays are then conditioned by "Check ~= 0" blocks (likely saturation or conditional passthrough) and summed, sometimes with literal `0`s or other additive terms, to produce **`<T_DLY_VCV_CLOSE_ADD>`** and **`<T_DLY_VCV_CLOSE_ADD_2>`**.
    *   Further calculations involve `<VB>` and `<TFPA>` through lookup tables (`IP_FAC_VB_T_DUR_VCV_CTL`, `IP_FAC_TFPA_T_DUR_VCV_CTL`) which are then used in conjunction with `C_T_DUR_VCV_CTL_PEAK_CLOSE_SL` to determine **`<T_VCV_CTL_PEAK_CLOSE_SL>`**.
    *   Logic involving `STATE_VCV_CLOSE_SL` comparisons (e.g., to `AD_PWM`, `OFF`), `LV_VCV_CLOSE_SL_AUTH`, and the calculated delays, passed through "Check ~= 0" blocks and `OR` gates, contributes to the **`<T_VCV_CTL_ST>`** (steady-state duration) output.
    *   Offset constants `C_T_DLY_OFS_VCV_CTL_AD_ACT` and `C_T_DLY_OFS_VCV_CTL_AD_ON` are multiplied with small constants and integrated into the delay calculations.

4.  **VCV Hold Duration and Angular Current Calculation:**
    *   `IP_ANG_CUR_OFF_VCV_OPEN_SL` is derived from `<FUP>` and `<VCV_CLOSE_RNG>` via a lookup table.
    *   This value is added with `[ang_dly_ofs]`, the previously calculated `<VCV_OPEN_ADD>`, and `C_ANG_CUR_OFF_VCV_MIN`.
    *   A `max` block ensures the result is not less than `0`. This result, after passing through "Check ~= 0" blocks and adders, becomes **`<T_DUR_VCV_CTL_HOLD_0>`**.
    *   Similarly, **`<ANG_CUR_OFF_VCV>`** is produced through a path involving `[ang_dly_ofs]`, `[VCV_OPEN_ADD]`, and `C_ANG_CUR_OFF_VCV_MIN`.
    *   **`<ANG_CUR_ON_VCV>`** is determined by another lookup table (`IP_ANG_CUR_ON_VCV_OPEN_SL`) based on `<FUP>` and `<VCV_CLOSE_RNG>`, possibly conditioned by `LV_VCV_OPEN_SL_AUTH`.
    *   A separate path processes `C_T_DUR_VCV_CTL_FW` and `LV_VCV_OPEN_SL_AUTH` to derive **`<T_DUR_VCV_CTL_FW>`**.

The system integrates various sensor inputs, calibrated parameters, and operational states through lookup tables, arithmetic operations, comparisons, and timed elements to generate a comprehensive set of control signals and durations for precise management of the fuel pressure actuator (VCV).


--- Page 252 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "FUSL, Fuel pressure actuator control", primarily calculates various timing and angular control parameters for a fuel pressure actuator, likely a Volume Control Valve (VCV). It takes into account system conditions such as voltage, engine speed, fuel pump temperature, and fuel pressure to determine the actuator's behavior, including its operating durations, additive opening/closing values, current on/off angles, and a lock-out mechanism based on low fuel pressure.

## Inputs
The diagram utilizes several input signals (green blocks with `<...>` or constant values) and lookup table definitions:

**Real-time Signals:**
*   `<VB>`: System voltage (e.g., battery voltage).
*   `<N_32>`: Engine speed or a related rotational speed.
*   `<TFPA>`: Fuel pump temperature.
*   `<VCV_CLOSE_RNG>`: A signal indicating a VCV is in a close range or has a specific closing condition.
*   `<FUP>`: Fuel pressure.

**Constants / Parameters (hardcoded values or constant blocks):**
*   `C_T_PLS_DIAG_VCV`: Constant for the duration of a diagnostic pulse for the VCV.
*   `C_N_MAX_ACT_ANG_VCV_OPEN_ADD`: Constant for the maximum active angle addition when opening the VCV.
*   `C_ANG_CUR_OFF_VCV_MIN`: Constant for the minimum current off angle for the VCV.
*   `C_FUP_MIN_LOCK_VCV`: Constant representing the minimum fuel pressure threshold for locking the VCV.
*   `C_T_MAX_FUP_MIN`: Constant representing the maximum time duration for the minimum fuel pressure condition before VCV lock.
*   `0.006`: Multiplier constant.
*   `0.375`: Multiplier constant.
*   `0`: Zero constant (used in comparisons, adders, switches, and 'Check ~= 0' blocks).

**Lookup Tables (Implicit Inputs - the table data itself, indexed by signals):**
*   `IP_T_DUR_VCV_CTL_BAS`: 1D/2D lookup table for base VCV control duration, indexed by `<VB>` and `<N_32>`.
*   `IP_FAC_TFU_T_DUR_VCV_CTL`: 1D lookup table for VCV control duration factor, indexed by `<TFPA>`.
*   `IP_VCV_OPEN_ADD`: 1D/2D lookup table for VCV opening additive value, indexed by `<VB>` and `<N_32>`.
*   `IP_FAC_CLOSE_RNG_VCV_OPEN_ADD`: 1D/2D lookup table for VCV open add factor based on close range, indexed by `<N_32>` and `<VCV_CLOSE_RNG>`.
*   `IP_FAC_TFPA_VCV_OPEN_ADD`: 1D lookup table for VCV open add factor based on TFPA, indexed by `<TFPA>`.
*   `IP_T_VCV_CLOSE_ADD_VB`: 1D/2D lookup table for VCV close additive value based on voltage, indexed by `<VB>` and `<N_32>`.
*   `IP_T_DLY_VCV_CLOSE_ADD`: 1D/2D lookup table for VCV close add delay, indexed by `<N_32>` and `<VCV_CLOSE_RNG>`.
*   `IP_FAC_T_DLY_VCV_CLOSE_ADD_VB`: 1D/2D lookup table for VCV close add delay factor based on voltage, indexed by `<VB>` and `<N_32>`.

## Outputs
The diagram calculates and outputs the following control parameters (blue blocks with `<...>`):

*   `<T_DUR_VCV_CTL_PEAK>`: The peak duration for VCV control.
*   `<T_VCV_CTL_ST>`: The control duration for the VCV's "start" or steady-state phase.
*   `<T_DUR_VCV_CTL_HOLD_0>`: A hold duration for VCV control (appears to often be zero).
*   `<VCV_OPEN_ADD>`: An additive value for VCV opening.
*   `<T_DLY_VCV_CLOSE_ADD>`: A delay additive value for VCV closing.
*   `<T_DUR_VCV_CTL_FW>`: The forward duration for VCV control.
*   `<ANG_CUR_ON_VCV>`: The crank angle at which current to the VCV is switched ON.
*   `<ANG_CUR_OFF_VCV>`: The crank angle at which current to the VCV is switched OFF.
*   `<T_FUP_MIN_VCV_LOCK>`: A boolean flag indicating if the VCV should be locked due to prolonged low fuel pressure.

## Logic Flow

The logical flow can be broken down into several parallel calculation paths:

### 1. VCV Control Duration Calculation (Top Path)
*   A base VCV control duration is determined from `IP_T_DUR_VCV_CTL_BAS` using `<VB>` and `<N_32>`.
*   This base duration is multiplied by a temperature factor from `IP_FAC_TFU_T_DUR_VCV_CTL` (based on `<TFPA>`).
*   A conditional multiplication follows: if `<VCV_CLOSE_RNG>` is 0, the result is multiplied by `C_T_PLS_DIAG_VCV`; otherwise, it's multiplied by 1. This implements a diagnostic pulse override.
*   The result then passes through a "Check ~= 0" block (likely a minimum limiter, ensuring the value is at least 0) to produce `<T_DUR_VCV_CTL_PEAK>`.
*   `<T_VCV_CTL_ST>` is derived from `<T_DUR_VCV_CTL_PEAK>` through a switch, possibly setting it to 0 under certain conditions or applying a further modification (the condition for this switch is not fully visible, but one input is 0).
*   `<T_DUR_VCV_CTL_HOLD_0>` is typically set to 0, originating from `<T_DUR_VCV_CTL_PEAK>` multiplied by 0 and passed through a switch.

### 2. VCV Open Add Calculation (Upper Middle Path)
*   A base VCV open add value is read from `IP_VCV_OPEN_ADD` (using `<VB>` and `<N_32>`).
*   This base value is sequentially multiplied by:
    *   A close range factor from `IP_FAC_CLOSE_RNG_VCV_OPEN_ADD` (based on `<N_32>` and `<VCV_CLOSE_RNG>`).
    *   A temperature factor from `IP_FAC_TFPA_VCV_OPEN_ADD` (based on `<TFPA>`).
    *   A value that is either `0.006 * <N_32>` (if `<N_32> <= C_N_MAX_ACT_ANG_VCV_OPEN_ADD`) or possibly 0. The boolean comparison result likely acts as a 0/1 multiplier.
*   The final product is processed by a "Check ~= 0" block (minimum limiter) to produce `<VCV_OPEN_ADD>`.

### 3. VCV Close Add Delay Calculation (Lower Middle Path)
*   A base VCV close add value is obtained from `IP_T_VCV_CLOSE_ADD_VB` (using `<VB>` and `<N_32>`).
*   This value is multiplied by a close add delay from `IP_T_DLY_VCV_CLOSE_ADD` (using `<N_32>` and `<VCV_CLOSE_RNG>`).
*   The result is further multiplied by a delay factor from `IP_FAC_T_DLY_VCV_CLOSE_ADD_VB` (using `<VB>` and `<N_32>`).
*   The final product is the `<T_DLY_VCV_CLOSE_ADD>` output.

### 4. VCV Forward Duration Calculation (Mid-Bottom Path)
*   The `[T_DLY_VCV_CLOSE_ADD]` signal (from the previous section) is multiplied by `0.375`.
*   A constant `0` is added to this product.
*   The sum passes through a `max` block (with 0 as the other input) to ensure it's non-negative, resulting in `<T_DUR_VCV_CTL_FW>`.

### 5. VCV Current On/Off Angle Calculation (Bottom Path)
*   The constant `C_ANG_CUR_OFF_VCV_MIN` is first ensured to be non-negative using a `max(input, 0)` block.
*   A switch then uses `<VCV_CLOSE_RNG> == 0` as a condition: if true, output 0; otherwise, output the non-negative `C_ANG_CUR_OFF_VCV_MIN`.
*   This switch output is then processed by a "Check ~= 0" block (minimum limiter) to yield `<ANG_CUR_OFF_VCV>`.
*   `<ANG_CUR_ON_VCV>` is calculated by adding the previously calculated `[VCV_OPEN_ADD]` to the value of `<ANG_CUR_OFF_VCV>`.

### 6. Fuel Pressure Minimum VCV Lock Calculation (Bottom-Most Path)
*   The system checks if `<FUP>` is less than `C_FUP_MIN_LOCK_VCV`. This boolean result (`T`) acts as the trigger input to a timer block (`V.7.10`).
*   The timer has an enable input `u` connected to `NOT` its own `y` output, indicating a latching mechanism: once `y` becomes true, `u` becomes false, stopping the timer and locking `y` to true.
*   The timer's `x_in` input (its target duration) is set by `C_T_MAX_FUP_MIN`. The sample time `dT` is `0.02` seconds (20ms).
*   The timer produces two outputs: `y` (a boolean, likely true if the low fuel pressure condition has persisted for `C_T_MAX_FUP_MIN` and is latched) and `x_out` (the elapsed time count).
*   The final output, `<T_FUP_MIN_VCV_LOCK>`, is derived from an `AND` gate, combining the timer's `y` output with the condition `(x_out < C_T_MAX_FUP_MIN)`.
    *   **Note on Ambiguity:** This specific `AND` logic (`y` AND `(x_out < C_T_MAX_FUP_MIN)`) appears contradictory if `y` is interpreted as "elapsed time `x_out` has met or exceeded `C_T_MAX_FUP_MIN`". If `y` is TRUE, then `x_out >= C_T_MAX_FUP_MIN`, which would make `(x_out < C_T_MAX_FUP_MIN)` FALSE, resulting in a perpetually FALSE lock signal. This suggests either a non-standard timer block behavior for `y` (e.g., `y` is true *while* counting but *before* reaching `x_in`), or a specific control logic (e.g., a short pulse, or a potential diagram error in common timer interpretations). Assuming a standard timer and a functional design, `y` might represent the transient condition of low fuel pressure, while the `AND` acts as a guard or to produce a pulse. However, without further context on the specific `V.7.10` block's internal logic, its exact behavior for this output is open to interpretation.


--- Page 254 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram's primary function is to calculate and output the deacceleration parameters for an active "soft landing" sequence during the opening of a Valve Control Valve (VCV) in a fuel pressure actuator control system. It determines the Pulse Width Modulation (PWM) duty cycle, various timing parameters (on, off, freewheeling duration), and associated frequencies required for controlled VCV operation.

## Inputs

1.  **`<LV_VCV_OPEN_SL_AUTH>`**: Authorization signal for VCV opening with "soft landing" (SL). This likely acts as a main enabler for the active calculation path.
2.  **`<clc_vcv_sl_off_open>`**: A state or control flag related to the VCV soft landing being off or open. This input is fed into both the active and inactive calculation blocks.
3.  **`<VB>`**: Battery Voltage. This is a critical input for PWM duty cycle and timing calculations, as indicated by the accompanying text.
4.  **`<R_VCV>`**: VCV Resistance. This input is likely used to compensate for temperature effects on the VCV coil, influencing PWM and timing.
5.  **`<STATE_VCV_CLOSE_SL>`**: The current state of the VCV during its closing "soft landing" phase.
6.  **`<PWM_VCV_CLOSE_SL_AD>`**: Adaptation parameter for the PWM duty cycle during VCV closing soft landing. Used for compensation.
7.  **`<VB_VCV_CLOSE_SL_AD_ST>`**: Battery voltage at the start of the VCV closing soft landing adaptation. Used for compensation.
8.  **`<C_FRQ_PWM_VCV_CUR_OFL_CTL>`**: A constant representing the PWM frequency for VCV current overflow control.

## Outputs

1.  **`<T_DEACC_ON_VCV>`**: Deacceleration "ON" time for the VCV, typically the duration of the hold phase.
2.  **`<T_DEACC_OFF_VCV>`**: Deacceleration "OFF" time for the VCV, typically the start of the PWM duty cycle.
3.  **`<PWM_VCV_CTL_DEACC>`**: Calculated PWM duty cycle value for VCV deacceleration control.
4.  **`<T_DUR_VCV_DEACC_FW>`**: Freewheeling duration for VCV deacceleration.
5.  **`FRQ_PWM_VCV_DEACC_PEAK`**: Peak PWM frequency for VCV deacceleration.
6.  **`FRQ_PWM_VCV_CTL_DEACC`**: Control PWM frequency for VCV deacceleration.
7.  **`clc_vcv_ctl_deacc`**: A bus containing all the above calculated deacceleration control parameters.

## Logic Flow

The logical flow of the diagram is as follows:

1.  **Authorization and Conditional Branching:**
    *   The process begins with a `cond_if` block, which likely acts as a decision point based on the `LV_VCV_OPEN_SL_AUTH` input (Authorization for VCV opening SL).
    *   If `LV_VCV_OPEN_SL_AUTH` is true (or meets the 'if' condition), the system proceeds to calculate parameters for active soft landing.
    *   If `LV_VCV_OPEN_SL_AUTH` is false (or meets the 'else' condition), the system selects default or inactive parameters.

2.  **Active Soft Landing Parameter Calculation (`CLC_VCV_OPEN_SL_ACT`):**
    *   When the 'if' condition is met, the `CLC_VCV_OPEN_SL_ACT` block is effectively activated.
    *   This block takes `clc_vcv_sl_off_open`, `VB`, `R_VCV`, `STATE_VCV_CLOSE_SL`, `PWM_VCV_CLOSE_SL_AD`, and `VB_VCV_CLOSE_SL_AD_ST` as inputs.
    *   Inside this block (likely a function-call subsystem as indicated by `fc()` and the detailed text description), complex calculations are performed:
        *   `T_DEACC_OFF_VCV` is calculated based on a base map, battery voltage, VCV resistance, and an adaptation offset if applicable.
        *   `PWM_VCV_CTL_DEACC` is determined using a base map, battery voltage, VCV resistance, and an adaptation offset if applicable.
        *   `T_DEAC_ON_VCV` is calculated as the PWM duty cycle application time for the hold phase, likely from a calibration map.
        *   `T_DUR_VCV_DEACC_FW` (freewheeling time) is determined from a calibration constant.
    *   These four calculated outputs are then directed towards the `BusMerge` block.

3.  **Inactive Parameter Assignment (`CLC_VCV_OPEN_SL_OFF`):**
    *   When the 'else' condition of `cond_if` is met, the `CLC_VCV_OPEN_SL_OFF` block is effectively activated.
    *   This block takes `clc_vcv_sl_off_open` as an input and outputs constant '0' values for `PWM_VCV_CTL_DEACC`, `T_DEACC_ON_VCV`, `T_DEACC_OFF_VCV`, and `T_DUR_VCV_DEACC_FW`. This signifies that when the VCV opening SL is not authorized or active, these deacceleration parameters are set to zero.
    *   These '0' values are then directed towards the `BusMerge` block. *Note: In a standard Simulink diagram, a Multiport Switch or Merge block would typically select between the 'active' and 'inactive' outputs before they are combined into a bus. The diagram implies that the `cond_if` block directly controls which set of values is effectively passed to the BusMerge.*

4.  **Frequency Calculation:**
    *   Concurrently, the input `C_FRQ_PWM_VCV_CUR_OFL_CTL` is processed to derive `FRQ_PWM_VCV_DEACC_PEAK` and `FRQ_PWM_VCV_CTL_DEACC`. These signals are also routed to the `BusMerge` block.
    *   Additional constant '0' values (V.6.11) are also fed into the `BusMerge`, potentially as default values for other bus elements or placeholders.

5.  **Output Bus Creation:**
    *   Finally, the `BusMerge` block consolidates all the selected/calculated deacceleration parameters and frequencies into a single structured output, `clc_vcv_ctl_deacc`, which serves as the combined control signal for the fuel pressure actuator.


--- Page 255 ---

This page contains two Simulink-like diagrams (Figures 43.15.74 and 43.15.75) related to fuel pressure actuator control. Figure 43.15.74 depicts the primary calculation logic for deceleration parameters during VCV (Valve Control Valve) opening. Figure 43.15.75 illustrates a specific condition where these parameters are set to zero, as explained by the accompanying text "Deacceleration parameters for deactivated soft landing during VCV opening. The actuation parameters are set to zero when the opening SL is not active."

I will describe Figure 43.15.74 as the main functional diagram and incorporate the context of Figure 43.15.75 as a conditional override.

---

## Function
The primary function of this Simulink diagram is to calculate and control several actuation parameters for a VCV (Valve Control Valve) related to fuel pressure, specifically during deceleration phases. These parameters include a Pulse Width Modulation (PWM) value and various timing parameters. The entire calculation and output generation are conditional: the parameters are actively calculated and output only when a specific "soft landing" state (`STATE_VCV_CLOSE_SL`) matches an "AD_ON" reference; otherwise, all output parameters are set to zero. This implies an enabling mechanism for "deceleration soft landing" control.

## Inputs
The system takes the following inputs:

*   **`<VB>`**: Likely battery voltage, used as an input to lookup tables.
*   **`<R_VCV>`**: Resistance of the VCV (or a related electrical parameter), used as an input to lookup tables.
*   **`<PWM_VCV_CLOSE_SL_AD>`**: A PWM value related to VCV closing, soft landing, and adaptation, used as an input to lookup tables.
*   **`<VB_VCV_CLOSE_SL_AD_ST>`**: A voltage value related to VCV closing, soft landing, adaptation, and state, used as an input to lookup tables.
*   **`<STATE_VCV_CLOSE_SL>`**: A system state variable indicating the current state of VCV closing and soft landing. This is a critical input for the conditional activation.
*   **`AD_ON`**: A reference value (likely a constant or a boolean) against which `<STATE_VCV_CLOSE_SL>` is compared to determine if the actuation parameters should be calculated or zeroed out.
*   **`C_T_DUR_VCV_DEACC`**: A constant value representing the deceleration duration of the VCV.
*   **`C_T_DUR_VCV_DEACC_FW`**: A constant value representing the deceleration duration of the VCV for a specific phase (e.g., forward movement).

## Outputs
The system produces the following outputs, which are either calculated values or forced to zero depending on the active state:

*   **`<PWM_VCV_CTL_DEACC>`**: The Pulse Width Modulation (PWM) duty cycle value for controlling the VCV during deceleration.
*   **`<T_DEACC_OFF_VCV>`**: The "off" time parameter for VCV deceleration.
*   **`<T_DEACC_ON_VCV>`**: The "on" time parameter for VCV deceleration.
*   **`<T_DUR_VCV_DEACC_FW>`**: The deceleration duration parameter for the VCV in a specific phase (e.g., forward).

## Logic Flow

The logic flow can be broken down into two main parts: the calculation of base and offset values, and the conditional activation/deactivation of these outputs.

1.  **Lookup Table Calculations (for Active State):**
    *   **PWM Calculation Path:**
        *   Two 2D-lookup tables (indicated by the mesh icon) are used:
            *   One table takes `<VB>` and `<R_VCV>` as inputs to determine `IP_PWM_VCV_CTL_DEACC_BAS` (Base PWM value for VCV deceleration control).
            *   Another table takes `<PWM_VCV_CLOSE_SL_AD>` and `<VB_VCV_CLOSE_SL_AD_ST>` as inputs to determine `IP_PWM_VCV_CTL_DEACC_AD_OFS` (Adaptive Offset PWM value for VCV deceleration control).
        *   These two values (`IP_PWM_VCV_CTL_DEACC_BAS` and `IP_PWM_VCV_CTL_DEACC_AD_OFS`) are summed together.
    *   **"Off Time" Calculation Path:**
        *   Similarly, two other 2D-lookup tables are used:
            *   One table takes `<VB>` and `<R_VCV>` to determine `IP_T_DEACC_OFF_VCV_BAS` (Base "off time" for VCV deceleration).
            *   Another table takes `<PWM_VCV_CLOSE_SL_AD>` and `<VB_VCV_CLOSE_SL_AD_ST>` to determine `IP_T_DEACC_OFF_VCV_AD_OFS` (Adaptive Offset "off time" for VCV deceleration).
        *   These two values (`IP_T_DEACC_OFF_VCV_BAS` and `IP_T_DEACC_OFF_VCV_AD_OFS`) are summed together.
    *   **"On Time" and "FW Duration" Assignments:**
        *   The constant `C_T_DUR_VCV_DEACC` is prepared as a candidate for `<T_DEACC_ON_VCV>`.
        *   The constant `C_T_DUR_VCV_DEACC_FW` is prepared as a candidate for `<T_DUR_VCV_DEACC_FW>`.

2.  **Conditional Output Activation:**
    *   A control signal for four switch blocks is generated based on a comparison:
        *   The input `<STATE_VCV_CLOSE_SL>` is compared with `AD_ON` using an equality block (`==`).
        *   The output of this comparison (a boolean, 1 for true, 0 for false) then feeds into a "Check ~= 0" block, which effectively passes through the boolean value (true if `STATE_VCV_CLOSE_SL == AD_ON`, false otherwise). This acts as the control signal for all subsequent switch blocks.
    *   **Switching Logic:**
        *   For `<PWM_VCV_CTL_DEACC>`: If the control signal is true (i.e., `STATE_VCV_CLOSE_SL == AD_ON`), the summed PWM value from step 1 is passed through. If false, a constant `0` is passed through.
        *   For `<T_DEACC_OFF_VCV>`: If the control signal is true, the summed "off time" value from step 1 is passed through. If false, a constant `0` is passed through.
        *   For `<T_DEACC_ON_VCV>`: If the control signal is true, the `C_T_DUR_VCV_DEACC` constant is passed through. If false, a constant `0` is passed through.
        *   For `<T_DUR_VCV_DEACC_FW>`: If the control signal is true, the `C_T_DUR_VCV_DEACC_FW` constant is passed through. If false, a constant `0` is passed through.

In essence, the system calculates a set of control parameters for the VCV, but these parameters are only applied (passed as non-zero outputs) when the `STATE_VCV_CLOSE_SL` matches the `AD_ON` condition, signifying an active "soft landing" or "deceleration active" state. Otherwise, all these control parameters are explicitly set to zero, disabling this specific control function, as corroborated by Figure 43.15.75.


--- Page 256 ---

This image contains a Simulink diagram titled "Closed loop controlled actuation of VCV" within the context of "Fuel pressure actuator control" for a FUSL (Fuel System) application.

## Function

The primary function of this Simulink diagram is to generate the detailed control parameters and Pulse Width Modulation (PWM) signals required for the closed-loop actuation of a Volume Control Valve (VCV) in a fuel pressure system. It takes high-level control requests and system state variables, processes them through various control logic blocks, and outputs a structured bus containing all the necessary commands and status information to drive the VCV actuator. This represents the actuation stage of a broader fuel pressure control system.

## Inputs

The diagram receives various inputs, which can be categorized as high-level requests, system states, and detailed control parameters:

*   **High-Level & System State Inputs:**
    *   `<input>`: A generic primary control request or state variable.
    *   `<VB>`: System voltage (likely battery voltage).
    *   `<N_32>`: Engine speed.
    *   `<VCV_CLOSE_RNG>`: A signal indicating the VCV closing range or request.

*   **Detailed VCV Control Parameters (Inputs to CLC_VCV_CUR_CLL_CTL_1 & CLC_VCV_CUR_CLL_CTL_2, originating from the `f()` block):**
    *   `<CUR_VCV_CTL_PEAK>`: Requested peak current for VCV control.
    *   `<CUR_VCV_CTL_HOLD>`: Requested hold current for VCV control.
    *   `<FRQ_PWM_VCV_CTL_PEAK>`: PWM frequency for peak current control.
    *   `<FRQ_PWM_VCV_CTL_1>`: A general PWM frequency for VCV control.
    *   `<T_DUR_VCV_CTL_PEAK>`: Duration for the peak current phase.
    *   `<ANG_VCV_CTL>`: A control angle for VCV operation.
    *   `<ANG_CUR_ON_VCV>`: Angle at which VCV current turns on.
    *   `<ANG_DLY_VCV_CLOSE_ADD>`: Additional delay angle for VCV closing.
    *   `<T_DLY_VCV_CLOSE_ADD>`: Additional delay time for VCV closing.
    *   `<ANG_CUR_OFF_VCV>`: Angle at which VCV current turns off.
    *   `<CUR_VCV_CTL_PEAK_ST>`: Status or threshold for VCV peak current control.
    *   `<CUR_VCV_CTL_HOLD_ST>`: Status or threshold for VCV hold current control.
    *   `<FRQ_PWM_VCV_CTL_ST>`: Status or threshold for PWM frequency.
    *   `<T_DUR_VCV_CTL_PEAK_ST>`: Status or threshold for peak current duration.
    *   `<LV_VCV_CLOSE_RNG_MIN>`: Minimum VCV closing range value.
    *   `<T_VCV_CTL_ST>`: Status or threshold time for VCV control.

## Outputs

The system outputs a single, structured bus containing a comprehensive set of VCV control and status signals:

*   **Output Bus:** `vcv_cur_cll_ctl_typ_2`

*   **Contents of the Output Bus (from BusMerge):**
    *   `CUR_VCV_CTL_PEAK`: Final commanded peak current.
    *   `CUR_VCV_CTL_HOLD`: Final commanded hold current.
    *   `FRQ_PWM_VCV_CTL_PEAK`: Processed PWM frequency for peak current.
    *   `FRQ_PWM_VCV_CTL_1`: Processed general PWM frequency.
    *   `T_DUR_VCV_CTL_PEAK`: Processed duration for peak current.
    *   `ANG_VCV_CTL`: Processed VCV control angle.
    *   `ANG_CUR_ON_VCV`: Processed current-on angle.
    *   `ANG_DLY_VCV_CLOSE_ADD`: Processed additional delay angle for closing.
    *   `T_DLY_VCV_CLOSE_ADD`: Processed additional delay time for closing.
    *   `ANG_CUR_OFF_VCV`: Processed current-off angle.
    *   `CUR_VCV_CTL_PEAK_ST`: Final VCV peak current status.
    *   `CUR_VCV_CTL_HOLD_ST`: Final VCV hold current status.
    *   `FRQ_PWM_VCV_CTL_ST`: Final PWM frequency status.
    *   `T_DUR_VCV_CTL_PEAK_ST`: Final peak duration status.
    *   `LV_VCV_CLOSE_RNG_MIN`: Final minimum VCV closing range.
    *   `T_VCV_CTL_ST`: Final VCV control status time.
    *   `PWM_VCV_CTL_PEAK`: PWM duty cycle or signal for peak current actuation.
    *   `PWM_VCV_CTL_1`: A general PWM duty cycle or signal.
    *   `PWM_VCV_CTL_PEAK_ST`: PWM status for peak current.
    *   `PWM_VCV_CTL_ST`: General PWM status.
    *   `T_DUR_VCV_CTL_HOLD_0`: Duration for VCV hold at zero current.
    *   `PWM_VCV_CTL_0`: PWM signal for VCV at zero current.
    *   `T_DUR_VCV_CTL_FW`: Forward duration for VCV control.
    *   `LF_CUR_CTL_MOD_VCV`: Current control mode for VCV (e.g., open loop, closed loop).
    *   `FRQ_PWM_VCV_CTL_0`: PWM frequency at zero current.
    *   `CUR_VCV_OPL_CTL_MAX`: Maximum current for VCV open-loop control.
    *   `T_DUR_VCV_CTL_0_FW`: Forward duration for VCV control at zero current.

## Logic Flow

The logical flow describes how the inputs are processed to generate the outputs for VCV actuation:

1.  **High-Level Parameter Generation (f() block):** The process begins with the `f()` block, likely a Simulink Function or Subsystem. It takes high-level inputs such as a general control request (`<input>`), system voltage (`<VB>`), engine speed (`<N_32>`), and VCV closing range (`<VCV_CLOSE_RNG>`). Based on these inputs, this block calculates and outputs a comprehensive set of raw or preliminary VCV control parameters, including peak/hold current requests, various PWM frequencies, durations, and angular control parameters. This block acts as the initial parameter calculation stage from system-level inputs.

2.  **Detailed Parameter Refinement (CLC_VCV_CUR_CLL_CTL_1):** The first set of detailed control parameters (e.g., `<CUR_VCV_CTL_PEAK>`, `<CUR_VCV_CTL_HOLD>`, `<FRQ_PWM_VCV_CTL_PEAK>`, etc.) generated by the `f()` block are fed into the `CLC_VCV_CUR_CLL_CTL_1` subsystem. This subsystem likely performs further processing, such as applying limits, calibration, filtering, or selecting between different operational modes, to refine these control parameters. The outputs of this block, which share similar names with its inputs, represent the final, validated, or adjusted versions of these parameters.

3.  **PWM Signal Generation (CLC_VCV_CUR_CLL_CTL_2):** A second set of critical control parameters, primarily the requested peak and hold currents and their associated status signals (e.g., `<CUR_VCV_CTL_PEAK>`, `<CUR_VCV_CTL_HOLD>`, `<CUR_VCV_CTL_PEAK_ST>`, `<CUR_VCV_CTL_HOLD_ST>`), are sent to the `CLC_VCV_CUR_CLL_CTL_2` subsystem. This block is responsible for translating these current commands into the actual physical PWM drive signals required by the VCV actuator. It generates outputs such as `PWM_VCV_CTL_PEAK`, `PWM_VCV_CTL_1`, `PWM_VCV_CTL_0`, along with various timing parameters (`T_DUR_VCV_CTL_HOLD_0`, `T_DUR_VCV_CTL_FW`) and the current control mode (`LF_CUR_CTL_MOD_VCV`). This block essentially generates the direct commands for the actuator driver.

4.  **Output Bus Consolidation (BusMerge):** Finally, the refined control parameters from `CLC_VCV_CUR_CLL_CTL_1` and the generated PWM and timing signals from `CLC_VCV_CUR_CLL_CTL_2` are merged together using two BusMerge blocks. These merged signals form a single, comprehensive output bus named `vcv_cur_cll_ctl_typ_2`. This bus provides all the necessary information to a downstream component, likely the hardware driver for the VCV actuator, to execute the closed-loop fuel pressure control strategy.


--- Page 257 ---

This page contains a Simulink-style block diagram, characteristic of model-based design in automotive embedded systems.

## Function
The primary function of this Simulink diagram is to implement a closed-loop control strategy for the actuation of a Valve Control Valve (VCV), likely a fuel pressure actuator, as indicated by the title "FUSL, Fuel pressure actuator control" and "Closed loop controlled actuation of VCV (Part 1)". It computes various control parameters such as current levels (peak and hold), PWM frequencies, control durations, and specific angles (on/off, delay) required to precisely actuate the VCV. The "Part 1" in the title suggests this is one part of a larger control system.

## Inputs
*   `<VB>`: A common input used across multiple calculation blocks, likely representing system voltage, a general enable signal, or a reference.
*   `<N_32>`: An input used in angle and duration calculations, potentially representing engine speed or another RPM-related signal.
*   `<VCV_CLOSE_RNG>`: A parameter defining the range or conditions for VCV closing.
*   `<ANG_CUR_ON_VCV>`: An input representing a pre-existing or desired angle for current activation on the VCV.
*   `<ANG_VCV_CTL>`: An input representing a pre-existing or desired overall control angle for the VCV.

## Outputs
*   `<CUR_VCV_CTL_PEAK>`: The calculated peak current for VCV control.
*   `<FRQ_PWM_VCV_CTL_PEAK>`: The calculated PWM frequency for the peak VCV control current.
*   `<CUR_VCV_CTL_HOLD>`: The calculated hold current for VCV control.
*   `<FRQ_PWM_VCV_CTL_1>`: A calculated PWM frequency for VCV control (possibly for the hold phase or a specific mode).
*   `<T_DUR_VCV_CTL_PEAK>`: The calculated peak control duration for the VCV.
*   `<ANG_VCV_CTL>`: The processed or selected VCV control angle.
*   `<CUR_VCV_CTL_PEAK_ST>`: The calculated "staged" or "static" peak current for VCV control.
*   `<FRQ_PWM_VCV_CTL_PEAK_ST>`: The calculated "staged" PWM frequency for the peak VCV control current.
*   `<CUR_VCV_CTL_HOLD_ST>`: The calculated "staged" hold current for VCV control.
*   `<FRQ_PWM_VCV_CTL_ST>`: The calculated "staged" PWM frequency for VCV control.
*   `<T_DUR_VCV_CTL_PEAK_ST>`: The calculated "staged" peak control duration for the VCV.
*   `<T_VCV_CTL_ST>`: The calculated "staged" VCV control duration.
*   `<T_DLY_VCV_CLOSE_ADD>`: An additional time delay for VCV closing.
*   `<ANG_DLY_VCV_CLOSE_ADD>`: An additional angle delay for VCV closing.
*   `<ANG_CUR_ON_VCV>`: The processed or selected angle for VCV current activation.
*   `<LV_VCV_CLOSE_RNG_MIN>`: The minimum level for the VCV closing range.
*   `<ANG_CUR_OFF_VCV>`: The calculated angle for VCV current deactivation.

## Logic Flow
The diagram illustrates a modular and parallel processing structure, with several independent or semi-independent paths calculating different control parameters:

1.  **Peak/Hold Current and Frequency Calculation (CLC_CUR_VCV_CTL):**
    *   The input `<VB>` feeds into the block `CLC_CUR_VCV_CTL` (X.2.1.2.2.3.1.5.1.1).
    *   This block calculates the main peak current (`<CUR_VCV_CTL_PEAK>`), its associated PWM frequency (`<FRQ_PWM_VCV_CTL_PEAK>`), the hold current (`<CUR_VCV_CTL_HOLD>`), and another PWM frequency (`<FRQ_PWM_VCV_CTL_1>`). These are direct outputs of the diagram.

2.  **Peak Duration Calculation (CLC_T_DUR_VCV_CTL_PEAK):**
    *   Inputs `<VB>` and `<N_32>` feed into the block `CLC_T_DUR_VCV_CTL_PEAK` (X.2.1.2.2.3.1.5.1.2).
    *   This block calculates the peak duration control for the VCV (`<T_DUR_VCV_CTL_PEAK>`), which is a direct output.

3.  **VCV Control Angle Calculation (CLC_ANG_VCV_CTL):**
    *   Inputs `<N_32>` and `<VB>` feed into the block `CLC_ANG_VCV_CTL` (X.2.1.2.2.3.1.5.1.3).
    *   This block calculates an intermediate VCV control angle.
    *   This angle then passes through a variant control block `[ANG_VCV_CTL]` (V.6.8), which likely selects or modifies the angle based on specific system conditions or configuration, before being output as `<ANG_VCV_CTL>`.

4.  **Staged Peak/Hold Current and Frequency Calculation (CLC_CUR_VCV_CTL_ST):**
    *   The input `<VB>` feeds into the block `CLC_CUR_VCV_CTL_ST` (X.2.1.2.2.3.1.5.1.4).
    *   This block calculates "staged" versions of the peak current (`<CUR_VCV_CTL_PEAK_ST>`), its PWM frequency (`<FRQ_PWM_VCV_CTL_PEAK_ST>`), the hold current (`<CUR_VCV_CTL_HOLD_ST>`), and its PWM frequency (`<FRQ_PWM_VCV_CTL_ST>`). These are direct outputs.

5.  **Staged Duration Calculation (CLC_T_DUR_VCV_CTL_PEAK_ST):**
    *   The input `<VB>` feeds into the block `CLC_T_DUR_VCV_CTL_PEAK_ST` (X.2.1.2.2.3.1.5.1.5).
    *   This block calculates the "staged" peak duration (`<T_DUR_VCV_CTL_PEAK_ST>`) and a general "staged" VCV control duration (`<T_VCV_CTL_ST>`). Both are direct outputs.

6.  **VCV Close Delay Angle Calculation (CLC_ANG_DLY_VCV_CTL):**
    *   Inputs `<VCV_CLOSE_RNG>` and `<VB>` feed into the block `CLC_ANG_DLY_VCV_CTL` (X.2.1.2.2.3.1.5.1.6).
    *   This block calculates an additional time delay for VCV closing (`<T_DLY_VCV_CLOSE_ADD>`) and an additional angle delay for VCV closing (`<ANG_DLY_VCV_CLOSE_ADD>`). The time delay is a direct output, while the angle delay feeds into the next block.

7.  **Current ON Angle Calculation (CLC_ANG_CUR_ON_VCV):**
    *   Inputs `<N_32>`, `<ANG_DLY_VCV_CLOSE_ADD>` (from the previous block), and `<VCV_CLOSE_RNG>` feed into `CLC_ANG_CUR_ON_VCV` (X.2.1.2.2.3.1.5.1.7).
    *   This block calculates the current ON angle for the VCV and a minimum VCV close range level (`<LV_VCV_CLOSE_RNG_MIN>`). The minimum close range level is a direct output.
    *   The calculated current ON angle then passes through a variant control block `[ANG_CUR_ON_VCV]` (V.6.8) before being output as `<ANG_CUR_ON_VCV>`.

8.  **Current OFF Angle Calculation (CLC_ANG_CUR_OFF_VCV):**
    *   The processed current ON angle (`<ANG_CUR_ON_VCV>`) and the processed VCV control angle (`<ANG_VCV_CTL>`) along with `<VB>` feed into `CLC_ANG_CUR_OFF_VCV` (X.2.1.2.2.3.1.5.1.8).
    *   This block calculates the angle for VCV current deactivation (`<ANG_CUR_OFF_VCV>`), which is the final output of this path.

In summary, the system takes various sensor inputs or system states (like voltage, engine speed, VCV range) to compute a comprehensive set of parameters (currents, frequencies, durations, angles) required for precise, closed-loop actuation of a VCV, likely a solenoid or similar electromechanical device in a fuel pressure system. The use of "Part 1" and the detailed numbering suggest this is a subsystem within a larger, highly structured control architecture.


--- Page 258 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, part of a "Fuel pressure actuator control" system (FUSL), performs two primary functions related to a Volume Control Valve (VCV):
1.  **Set point determination for VCV current closed loop control during the peak phase:** It calculates the target current and PWM frequency for both the peak (initial actuation) and hold phases of the VCV's operation, primarily as a function of an input voltage.
2.  **Duration calculation for the pull-in phase during VCV closing:** It determines the required duration for the VCV's pull-in (or peak) phase by applying a voltage-dependent correction factor to an engine speed-dependent base duration.

## Inputs
**Common Inputs for both sections:**
*   **<VB>**: Likely representing battery voltage or another relevant system voltage. Used as an independent variable for several lookup tables.

**Specific Input for Duration Calculation:**
*   **<N_32>**: Represents engine speed (e.g., RPM). Used as an independent variable for a lookup table determining base duration.

## Outputs
**Outputs for Set Point Determination:**
*   **<CUR_VCV_CTL_PEAK>**: Target current set point for the VCV during its peak actuation phase.
*   **<FRQ_PWM_VCV_CTL_PEAK>**: Target PWM frequency set point for VCV control during its peak actuation phase.
*   **<CUR_VCV_CTL_HOLD>**: Target current set point for the VCV during its hold phase.
*   **<FRQ_PWM_VCV_CTL_1>**: Target PWM frequency set point for VCV control during its hold phase.

**Output for Duration Calculation:**
*   **<T_DUR_VCV_CTL_PEAK>**: Calculated duration for the VCV's pull-in/peak phase.

## Logic Flow

The diagram is structured into two independent logical sections:

### Section 1: Set point for VCV current closed loop control during peak phase (Figure 43.15.78)

1.  **Voltage Input:** The input signal **<VB>** (voltage) is supplied as the independent variable (`x_val`) to four separate 1-D lookup tables.
2.  **Peak Current Lookup:** The lookup table `IP_CUR_VCV_CTL_PEAK_TYP_2` uses **<VB>** to determine an interpolated value (`IP_val`) which represents the target current for the VCV's peak phase. This value is output as **<CUR_VCV_CTL_PEAK>**.
3.  **Peak PWM Frequency Lookup:** The lookup table `IP_FRQ_PWM_VCV_CTL_PEAK_TYP_2` uses **<VB>** to determine an interpolated value (`IP_val`) which represents the target PWM frequency for the VCV's peak phase. This value is output as **<FRQ_PWM_VCV_CTL_PEAK>**.
4.  **Hold Current Lookup:** The lookup table `IP_CUR_VCV_CTL_HOLD_TYP_2` uses **<VB>** to determine an interpolated value (`IP_val`) which represents the target current for the VCV's hold phase. This value is output as **<CUR_VCV_CTL_HOLD>**.
5.  **Hold PWM Frequency Lookup:** The lookup table `IP_FRQ_PWM_VCV_CTL_HOLD_TYP_2` uses **<VB>** to determine an interpolated value (`IP_val`) which represents the target PWM frequency for the VCV's hold phase. This value is output as **<FRQ_PWM_VCV_CTL_1>**.

*In summary, this section uses the battery voltage to look up four characteristic values (peak current, peak frequency, hold current, hold frequency) for the VCV control.*

### Section 2: Duration for pull-in phase during VCV closing (Figure 43.15.79)

1.  **Base Duration Lookup:** The input signal **<N_32>** (engine speed) is supplied as the independent variable (`x_val`) to the lookup table `IP_T_DUR_VCV_CTL_PEAK_BAS_TYP_2`. This table determines a base duration (`IP_val`) for the VCV's pull-in phase, likely calibrated based on engine operating conditions.
2.  **Correction Factor Lookup:** The input signal **<VB>** (voltage) is supplied as the independent variable (`x_val`) to the lookup table `IP_FAC_T_DUR_VCV_CTL_PEAK_TYP_2`. This table determines a correction factor (`IP_val`) for the VCV's pull-in phase duration, likely compensating for voltage variations affecting valve response.
3.  **Multiplication:** The base duration from the first lookup table and the correction factor from the second lookup table are multiplied together using a multiplication block (denoted by 'X').
4.  **Output Duration:** The product of this multiplication is the final calculated duration for the VCV's peak/pull-in phase, which is output as **<T_DUR_VCV_CTL_PEAK>**.

*In summary, this section calculates the VCV pull-in duration by multiplying an engine speed-dependent base value with a voltage-dependent correction factor.*


--- Page 259 ---

This page contains a Simulink-style diagram.

## Function

The primary function of this Simulink diagram is to calculate the **Volume Control Valve (VCV) holding angle** (`<ANG_VCV_CTL>`) for a fuel pressure actuator control system. It does this by taking two input parameters (likely engine speed and battery voltage), processing them through respective 1D lookup tables, and then multiplying the results to determine the final VCV angle.

## Inputs

*   **`<N_32>`**: This input typically represents an engine speed or a rotational speed, often in RPM. It serves as the independent variable for the first lookup table.
*   **`<VB>`**: This input likely represents the battery voltage. It serves as the independent variable for the second lookup table.

## Outputs

*   **`<ANG_VCV_CTL>`**: This is the calculated control angle for the Volume Control Valve. This output would be fed to an actuator or another control module to regulate fuel pressure.

## Logic Flow

1.  **Receive Inputs**: The system receives two input signals: `<N_32>` and `<VB>`.

2.  **Base Angle Determination (Lookup Table 1)**:
    *   The `<N_32>` input is fed into the "IP_ANG_VCV_CTL_BAS_TYP_2" lookup table.
    *   This lookup table, likely a 1D table, uses `<N_32>` as its independent variable (x-axis) to interpolate and determine a "base" VCV control angle (`IP_val`). The name suggests this provides a fundamental control angle based on engine speed.

3.  **Correction Factor Determination (Lookup Table 2)**:
    *   Concurrently, the `<VB>` input is fed into the "IP_FAC_ANG_VCV_CTL_TYP_2" lookup table.
    *   This lookup table, also likely a 1D table, uses `<VB>` as its independent variable (x-axis) to interpolate and determine a "factor" or "correction" value (`IP_val`). The name indicates this value modifies the VCV angle, potentially to compensate for voltage variations affecting actuator performance.

4.  **Final Angle Calculation (Multiplication)**:
    *   The interpolated base angle from the first lookup table and the interpolated correction factor from the second lookup table are then multiplied together by the "V.7.8" multiplication block.
    *   This multiplication operation combines the engine-speed-dependent base angle with the voltage-dependent correction factor.

5.  **Output VCV Holding Angle**:
    *   The product of the multiplication is the final calculated `<ANG_VCV_CTL>`, which represents the commanded VCV holding angle for the fuel pressure actuator.


--- Page 260 ---

This image contains two Simulink diagram sections, related to Fuel Pressure Actuator (FUSL) control, specifically for a Volume Control Valve (VCV).

## Function
The primary function of these Simulink diagrams is to calculate various setpoints (current, PWM frequency) for the Volume Control Valve (VCV) during its "peak" and "hold" operational phases, as well as to determine the duration for the VCV's "pull-in" or "peak" phase. These calculations are performed using 1D lookup tables and basic arithmetic operations, dependent on a common input variable.

## Inputs
1.  **`<VB>`**: A common input variable, likely representing an operating condition such as engine speed, fuel pressure, or temperature. This variable serves as the independent axis (`x_val`) for all 1D lookup tables in both diagrams.
2.  **`C_T_VCV_CTL_ST`**: A calibration constant or another input signal representing a base time or factor for the VCV control duration.

## Outputs
From Figure 43.15.81 (Set point for VCV current closed loop control during peak phase):
1.  **`<CUR_VCV_CTL_PEAK_ST>`**: The current setpoint for the VCV during its peak operational phase.
2.  **`<FRQ_PWM_VCV_CTL_PEAK_ST>`**: The PWM frequency setpoint for the VCV during its peak operational phase.
3.  **`<CUR_VCV_CTL_HOLD_ST>`**: The current setpoint for the VCV during its hold operational phase.
4.  **`<FRQ_PWM_VCV_CTL_ST>`**: The PWM frequency setpoint for the VCV during its hold operational phase (inferred from the lookup table name `IP_FRQ_PWM_VCV_HOLD_ST_TYP_2`).

From Figure 43.15.82 (Duration for pull-in phase during VCV closing):
1.  **`<DUR_VCV_CTL_PEAK_ST>`**: The calculated duration for the VCV's pull-in or peak phase during closing.
2.  **`T_VCV_CTL_ST`**: A processed or designated VCV control duration/time value.

## Logic Flow

The diagrams consist of two independent calculation paths:

**Figure 43.15.81: Set point for VCV current closed loop control during peak phase**

This section calculates four independent setpoints based on the common input `<VB>`:

1.  **Peak Phase Current Setpoint:**
    *   The input `<VB>` is fed into the 1D lookup table named `IP_CUR_VCV_CTL_PEAK_ST_TYP_2`.
    *   This lookup table interpolates a corresponding `IP_val` (interpolated value) based on the input `<VB>`.
    *   The resulting `IP_val` is output as `<CUR_VCV_CTL_PEAK_ST>`.

2.  **Peak Phase PWM Frequency Setpoint:**
    *   The input `<VB>` is fed into the 1D lookup table named `IP_FRQ_PWM_VCV_PEAK_ST_TYP_2`.
    *   This lookup table interpolates a corresponding `IP_val` based on the input `<VB>`.
    *   The resulting `IP_val` is output as `<FRQ_PWM_VCV_CTL_PEAK_ST>`.

3.  **Hold Phase Current Setpoint:**
    *   The input `<VB>` is fed into the 1D lookup table named `IP_CUR_VCV_CTL_HOLD_ST_TYP_2`.
    *   This lookup table interpolates a corresponding `IP_val` based on the input `<VB>`.
    *   The resulting `IP_val` is output as `<CUR_VCV_CTL_HOLD_ST>`.

4.  **Hold Phase PWM Frequency Setpoint:**
    *   The input `<VB>` is fed into the 1D lookup table named `IP_FRQ_PWM_VCV_HOLD_ST_TYP_2`.
    *   This lookup table interpolates a corresponding `IP_val` based on the input `<VB>`.
    *   The resulting `IP_val` is output as `<FRQ_PWM_VCV_CTL_ST>`.

**Figure 43.15.82: Duration for pull-in phase during VCV closing**

This section calculates two duration-related outputs:

1.  **Duration Factor Calculation:**
    *   The input `<VB>` is fed into the 1D lookup table named `IP_FAC_T_DUR_VCV_PEAK_ST_TYP_2`.
    *   This lookup table interpolates a `IP_val` (duration factor) based on the input `<VB>`.

2.  **Peak Duration Calculation:**
    *   The interpolated `IP_val` (duration factor) is then multiplied by the input `C_T_VCV_CTL_ST` using a multiplication block.
    *   The result of this multiplication is directly output as `<DUR_VCV_CTL_PEAK_ST>`.

3.  **Processed Duration Output:**
    *   The result of the multiplication is also fed into a block labeled `T_VCV_CTL_ST` (version V.6.8). This block then outputs the signal `T_VCV_CTL_ST`, potentially applying further processing, scaling, or simply denoting it as a specific time value in the system.


--- Page 261 ---

This page contains two Simulink-style diagrams, which are commonly used in automotive embedded software development for model-based design.

## Function

The primary function of these diagrams is to calculate specific timing and angle parameters related to the operation of a Volume Control Valve (VCV) in a fuel pressure actuator control system (FUSL).

**Figure 43.15.83** calculates two compensation values:
1.  An additional mechanical delay time for VCV closing.
2.  An additional mechanical delay angle between the VCV current feed and VCV closing.

**Figure 43.15.84** then uses the results from Figure 43.15.83, along with the VCV closing range, to determine:
1.  The specific angle at which to begin current feed to the VCV.
2.  A logical flag indicating if the VCV closing range is above a minimum threshold (zero).

## Inputs

**Common Inputs to both diagrams:**
*   `<N_32>`: Engine speed (rpm or similar unit).
*   `<VCV_CLOSE_RNG>`: VCV closing range (an angle or position value).

**Specific Inputs to Figure 43.15.83:**
*   `<VB>`: Battery voltage.
*   `IP_T_DLY_VCV_CLOSE_ADD_3`: A 2D look-up table (map) that provides additional delay time based on engine speed and VCV closing range.
*   `IP_FAC_T_VCV_CLOSE_ADD_TYP_2`: A 2D look-up table (map) that provides a scaling factor based on engine speed and battery voltage.
*   `0.006`: A constant scaling factor.

**Specific Inputs to Figure 43.15.84:**
*   `<ANG_DLY_VCV_CLOSE_ADD>`: The calculated additional mechanical delay angle (output from Figure 43.15.83).
*   `0`: A constant value used for comparison.

## Outputs

**Outputs from Figure 43.15.83:**
*   `<T_DLY_VCV_CLOSE_ADD>`: Calculated additional mechanical delay time for VCV closing.
*   `<ANG_DLY_VCV_CLOSE_ADD>`: Calculated additional mechanical delay angle for VCV closing.

**Outputs from Figure 43.15.84:**
*   `<ANG_CUR_ON_VCV>`: The calculated angle at which to begin current feed for the VCV.
*   `<LV_VCV_CLOSE_RNG_MIN>`: A boolean flag, true if `<VCV_CLOSE_RNG>` is greater than 0, false otherwise.

## Logic Flow

### Figure 43.15.83: Calculation of mechanical delay time and angle

1.  **Calculate Additional Delay Time (`<T_DLY_VCV_CLOSE_ADD>`):**
    *   The engine speed (`<N_32>`) is used as the x-axis input (`x_val`), and the VCV closing range (`<VCV_CLOSE_RNG>`) is used as the y-axis input (`y_val`) for the 2D look-up table `IP_T_DLY_VCV_CLOSE_ADD_3`.
    *   The look-up table outputs an interpolated `P_val`.
    *   This `P_val` is then fed into a multiplication block (V.7.8). Assuming the other input to this multiplication block is an implicit '1' or a parameter not explicitly shown (a common simplification), its output represents a scaled value.
    *   This scaled value then passes through a gain block (V.6.8, triangular symbol).
    *   The final result from the gain block is the additional mechanical delay time, `<T_DLY_VCV_CLOSE_ADD>`.

2.  **Calculate Additional Delay Angle (`<ANG_DLY_VCV_CLOSE_ADD>`):**
    *   The engine speed (`<N_32>`) is used as the x-axis input (`x_val`), and battery voltage (`<VB>`) is used as the y-axis input (`y_val`) for the second 2D look-up table `IP_FAC_T_VCV_CLOSE_ADD_TYP_2`.
    *   This look-up table outputs an interpolated `P_val` (a factor).
    *   This factor `P_val` is multiplied by the constant `0.006` (from block V.6.11) using a multiplication block (V.7.8). Let's call this intermediate result `Factor_A`.
    *   The output from the first V.7.8 block in the delay time calculation path (the scaled `P_val` from `IP_T_DLY_VCV_CLOSE_ADD_3`, *before* the V.6.8 gain) is taken as a second input for another multiplication block (V.7.8). Let's call this `Factor_B`.
    *   `Factor_A` is multiplied by `Factor_B` in this final multiplication block (V.7.8).
    *   The result of this multiplication is the additional mechanical delay angle, `<ANG_DLY_VCV_CLOSE_ADD>`.

### Figure 43.15.84: Angle to begin current feed of the VCV

1.  **Calculate Angle for Current Feed (`<ANG_CUR_ON_VCV>`):**
    *   The calculated additional mechanical delay angle (`<ANG_DLY_VCV_CLOSE_ADD>`) is added to the VCV closing range (`<VCV_CLOSE_RNG>`) using an addition block (V.7.7).
    *   The sum of these two values is the angle at which to begin current feed for the VCV, `<ANG_CUR_ON_VCV>`.

2.  **Check Minimum VCV Closing Range (`<LV_VCV_CLOSE_RNG_MIN>`):**
    *   The VCV closing range (`<VCV_CLOSE_RNG>`) is compared to the constant value `0` (from block V.6.11) using a "greater than" comparison block (V.6.6).
    *   If `<VCV_CLOSE_RNG>` is greater than `0`, the output `<LV_VCV_CLOSE_RNG_MIN>` is true (or 1); otherwise, it is false (or 0).


--- Page 262 ---

This page contains Simulink-like block diagrams representing control logic within an automotive system.

## Function

This Simulink diagram describes a sub-system for **Fuel Pressure Actuator Control (FUSL)**, specifically related to the **Voltage Control Valve (VCV)**. It is divided into two parts:

1.  **Angle to End Current Feed of the VCV (Figure 43.15.85):** This part calculates a minimum "angle current off" value for the VCV, which likely serves as a lower current limit or a shutdown current based on a given angle, a control current, and the system's battery voltage. This is crucial for precise VCV operation and potentially for fuel pump efficiency or safety.
2.  **Closed Loop Controlled Actuation of VCV (Part 2) (Figure 43.15.86):** This part focuses on the actual actuation of the VCV. It takes commanded peak and hold current setpoints and their respective states, then processes them through a closed-loop controller to generate the necessary Pulse Width Modulation (PWM) signals and related timing/mode parameters for precise VCV current control.

Overall, the diagram outlines logic for managing the VCV's current draw and generating its control signals to achieve desired fuel pressure regulation.

## Inputs

**From Figure 43.15.85:**

*   `<ANG_CUR_ON_VCV>`: Angle-dependent "current on" value for the VCV.
*   `<ANG_VCV_CTL>`: Angle-dependent VCV control input (e.g., a commanded angle or an angle-derived control signal).
*   `<VB>`: System voltage, likely the battery voltage, influencing voltage-dependent characteristics.

**From Figure 43.15.86:**

*   `<CUR_VCV_CTL_PEAK>`: Desired peak current setpoint for VCV actuation.
*   `<CUR_VCV_CTL_HOLD>`: Desired hold current setpoint for VCV actuation.
*   `<CUR_VCV_CTL_PEAK_ST>`: State or status signal indicating if peak current control is active.
*   `<CUR_VCV_CTL_HOLD_ST>`: State or status signal indicating if hold current control is active.
*   `C_T_DUR_VCV_CTL_FW`: Constant for the forward duration of the VCV control.
*   `CLF_CUR_CTL_MOD_VCV`: Constant for the current control mode of the VCV.
*   `C_FRQ_PWM_VCV_CTL_0`: Constant for the frequency of PWM control 0 for the VCV.
*   `C_CUR_VCV_OPL_CTL_MAX`: Constant for the maximum operational current for the VCV.

## Outputs

**From Figure 43.15.85:**

*   `<ANG_CUR_OFF_VCV>`: The calculated angle-dependent "current off" value for the VCV.

**From Figure 43.15.86:**

*   `PWM_VCV_CTL_PEAK`: Calculated PWM duty cycle or value for the VCV's peak current phase.
*   `PWM_VCV_CTL_1`: A general calculated PWM duty cycle or value for VCV control.
*   `PWM_VCV_CTL_PEAK_ST`: Output state for VCV peak current control (likely reflecting the active state of the PWM output).
*   `PWM_VCV_CTL_ST`: General output state for VCV control (likely reflecting the active state of the PWM output).
*   `<T_DUR_VCV_CTL_FW>`: Output value for VCV control forward duration (either the constant `C_T_DUR_VCV_CTL_FW` or a default value, possibly 0).
*   `<LF_CUR_CTL_MOD_VCV>`: Output value for VCV current control mode (either the constant `CLF_CUR_CTL_MOD_VCV` or a default value, possibly 0).
*   `<PWM_VCV_CTL_0>`: Output PWM control value 0 for the VCV (either derived from `C_FRQ_PWM_VCV_CTL_0` or a default, possibly 0).
*   `<FRQ_PWM_VCV_CTL_0>`: Output frequency for PWM control 0 for the VCV (either derived from `C_FRQ_PWM_VCV_CTL_0` or a default, possibly 0).
*   `<T_DUR_VCV_CTL_HOLD_0>`: Output hold duration 0 for VCV control (either a constant or a default, possibly 0).
*   `<CUR_VCV_OPL_CTL_MAX>`: Output maximum operational VCV current (either the constant `C_CUR_VCV_OPL_CTL_MAX` or a default, possibly 0).
*   `<T_DUR_VCV_CTL_0_FW>`: Output forward duration 0 for VCV control (either a constant or a default, possibly 0).

## Logic Flow

**Part 1: Angle to end current feed of the VCV (Figure 43.15.85)**

1.  **Current Difference Calculation:** The input `<ANG_CUR_ON_VCV>` and `<ANG_VCV_CTL>` are fed into a summation block (V.7.7). One input is added, and the other is subtracted (indicated by `+` and `-`), calculating a difference or an adjusted current value based on the angle inputs.
2.  **Voltage Compensation (Lookup Table):** The system voltage `<VB>` is used as the input (`x_val`) to a 1D lookup table or characteristic curve block (`IP_ANG_CUR_OFF_VCV_MIN`, V.7.11). This block determines a voltage-dependent minimum `IP_val` (Interpolated Value), which could be a minimum current or an offset, to compensate for voltage fluctuations.
3.  **Maximum Selection:** The output of the summation block and the `IP_val` from the lookup table are then compared by a `max` block (V.6.11). This block selects the higher of the two values.
4.  **Final Output:** The selected maximum value becomes the final output, `<ANG_CUR_OFF_VCV>`, representing a robust "current off" value that accounts for both angular control and voltage compensation.

**Part 2: Closed loop controlled actuation of VCV (Part 2) (Figure 43.15.86)**

1.  **Current Demand Aggregation:** The four input signals defining the desired VCV current and its operational mode (`<CUR_VCV_CTL_PEAK>`, `<CUR_VCV_CTL_HOLD>`, `<CUR_VCV_CTL_PEAK_ST>`, `<CUR_VCV_CTL_HOLD_ST>`) are combined into a single composite signal labeled `<cur_vcv>`. This acts as a consolidated current demand and status input for the control logic.
2.  **Closed-Loop Control Logic:** The `<cur_vcv>` signal is fed into the central control block `CLC_IP_PWM_CUR_VCV_REQ` (X.2.1.2.2.3.1.5.2.1). This block, denoted "for {...} <pwm_vcv>", is the core of the VCV actuation. It performs closed-loop current control, likely using a controller (e.g., PID) and state machine logic, to generate the appropriate PWM signals (`<pwm_vcv>`) needed to drive the VCV to achieve the commanded peak and hold current setpoints.
3.  **PWM Signal Generation:** The output `<pwm_vcv>` from the central control block is then de-multiplexed or routed to produce several specific PWM-related outputs: `PWM_VCV_CTL_PEAK`, `PWM_VCV_CTL_1`, `PWM_VCV_CTL_PEAK_ST`, and `PWM_VCV_CTL_ST`. These are the final control signals delivered to the VCV's driver.
4.  **Configuration Parameter Routing:** Various constant parameters (e.g., `C_T_DUR_VCV_CTL_FW`, `CLF_CUR_CTL_MOD_VCV`, etc.) are shown as inputs that are also presented as outputs. The diagram indicates a potential selection with a '0' input for each, implying that the output is either the configured constant value or a default value (0) if the constant is not actively selected or present. These outputs make the current configuration for VCV timing, mode, frequency, and operational limits available to subsequent modules.


--- Page 263 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram is designed for **Actuator Calculation for a Currentless Close VCV (Volume Control Valve)** within a **Fuel Pressure Actuator Control (FUSL)** system. Its primary function is to compute the Pulse Width Modulation (PWM) signal required to control the VCV based on an input VCV current or desired state, likely mapping a functional requirement to a physical actuator command. The "currentless close" aspect implies a specific operational characteristic of the valve where it closes without an applied current, and the control logic needs to account for this behavior.

## Inputs
*   **`<cur_vcv>`**: This is the main input signal, likely representing the commanded VCV current, position, or desired state.
*   **For Iterator (0:N-1)**: Provides an iteration index or loop control signal, implicitly feeding into the control flow and potentially the `C0` input of the `V.7.16` block. This suggests the calculation might be performed iteratively or for a sequence of values.
*   **`Init = zeros(1,4)`**: An initialization parameter for the `V.7.16` block, likely used to set initial internal states or constants for its calculation.
*   **`1` and `z`**: These appear to be constant or parameterized inputs to the `V.7.16` block, possibly representing selection flags, scaling factors, or control mode parameters.

## Outputs
*   **`<pwm_vcv>`**: The final output of the diagram, representing the calculated Pulse Width Modulation signal to drive the VCV actuator. This signal will typically dictate the duty cycle of the electrical power supplied to the valve.

## Logic Flow
1.  **Iteration Control:** The "For Iterator" block indicates that the subsequent calculations are performed within a loop, from index 0 to N-1. This is common for processing arrays of data, sequential control logic, or simulating time-series behavior. It provides an implicit loop variable and an explicit `C0` signal which is fed into block `V.7.16`.
2.  **VCV Input Processing:** The input signal `<cur_vcv>` is fed into a block labeled "V.6.16". This block likely performs initial processing steps such as scaling, unit conversion, filtering, or basic state derivation from the raw VCV input. The output of this block is labeled `x_val`.
3.  **PWM Request Mapping:** The `x_val` is then used as the input to a 1-D Lookup Table block named "IP_PWM_CUR_VCV_REQ" (Injected Pulse Width Modulation Current for VCV Request). This lookup table translates the processed VCV state (`x_val`) into an intermediate requested PWM value, `IP_val`. This mapping is typically derived from empirical characterization data of the VCV actuator's response.
4.  **Actuator Control Logic:** The `IP_val` (requested PWM from the lookup table) and another output from the "V.6.16" block (the second input to V.7.16 from the left) are fed into a more complex block labeled "V.7.16". This block also receives `C0` from the "For Iterator" and additional inputs '1' and 'z'. The "Init = zeros(1,4)" property suggests that this block is stateful and likely implements advanced control logic, filtering, dynamic compensation, or a state machine to refine the PWM signal. Given the context of "actuator calculation," this block likely incorporates the specific characteristics and control strategy for the currentless close VCV to ensure proper fuel pressure regulation.
5.  **Final PWM Output:** The output of the "V.7.16" block is the final `<pwm_vcv>` signal. This signal is the precise PWM command that will be sent to the VCV driver hardware to control the valve's operation.


--- Page 264 ---

This page contains a Simulink-like diagram, representing a functional block or subsystem.

## Function
The primary function of this module, titled "FUSL, Fuel pressure actuator control" and specifically detailed as calculating "Control angles and time durations for currentless closed VCV", is to determine and provide a comprehensive set of actuation and control parameters for a Volume Control Valve (VCV) operating in a "currentless closed" mode within a fuel pressure actuator system. It translates high-level operational states and conditions into precise, time-sensitive control signals required to manage the VCV's behavior, including its opening, closing, and intermediate phases.

## Inputs
The module takes the following key inputs:

*   **`<STATE_VCV>`**: Represents the current operating state or mode of the VCV (e.g., active, inactive, opening, closing).
*   **`<VCV_CLOSE_RNG>`**: Indicates a specific range or condition related to the closing operation of the VCV.
*   **`<input>`**: A generic input, likely representing a bundle of other essential system variables such as engine speed, battery voltage, or target fuel pressure, which are necessary for calculating the control parameters.

## Outputs
The module produces a single bundled output signal named `clc_prm_vcv_act_off_close`, which contains numerous calculated parameters crucial for controlling the VCV. These parameters are:

*   **`ANG_CUR_OFF_VCV`**: Angle at which current is turned off for the VCV.
*   **`ANG_CUR_ON_VCV`**: Crank angle at which current is turned on for the VCV, from the point where active current in the coil is applied up to the pump TDC. This value is derived from a calibration map (IP_VCV_OPEN_ADD) and depends on battery voltage and engine speed.
*   **`T_DUR_VCV_CTL_PEAK`**: The duration of peak current during the VCV's pull-in phase. This is calculated using a base calibration map and is dependent on VCV closing angle and engine speed.
*   **`T_DUR_VCV_CTL_HOLD_0`**: A duration for a hold current (not explicitly used according to the description).
*   **`T_DUR_VCV_CTL_FW`**: Forward current duration for VCV control.
*   **`PWM_VCV_CTL_0`**: Pulse Width Modulation (PWM) control value 0 for VCV actuation.
*   **`PWM_VCV_CTL_1`**: Pulse Width Modulation (PWM) control value 1 for VCV actuation.
*   **`T_FUP_MIN_VCV_LOCK`**: Minimum lock-up time for the VCV (possibly related to fuel pump operation).
*   **`T_DLY_VCV_CLOSE_ADD`**: An additional delay time between the deactivation of the VCV current feed and the mechanical closing of the VCV. It's calculated via a base calibration map (IP_T_DLY_VCV_CLOSE_ADD_3) and depends on VCV closing angle and engine speed.
*   **`VCV_OPEN_ADD`**: An additive value related to VCV opening.
*   **`T_VCV_CTL_ST`**: Start time for VCV control.
*   **`PWM_VCV_CTL_ST`**: PWM control start value for VCV actuation.
*   **`LF_CUR_CTL_MOD_VCV`**: Current control mode for the VCV.
*   **`FRQ_PWM_VCV_CTL_PEAK`**: PWM frequency for the peak current phase.
*   **`FRQ_PWM_VCV_CTL_0`**: PWM frequency control value 0.
*   **`FRQ_PWM_VCV_CTL_1`**: PWM frequency control value 1.
*   **`FRQ_PWM_VCV_DEACC_PEAK`**: PWM frequency for the deactivation peak.
*   **`FRQ_PWM_VCV_CTL_DEACC`**: PWM frequency for deactivation.
*   **`FRQ_PWM_VCV_CTL_PEAK_ST`**: PWM frequency for the peak start phase.
*   **`FRQ_PWM_VCV_CTL_ST`**: PWM frequency for the start phase.
*   **`PWM_VCV_CTL_PEAK`**: PWM control peak value.
*   **`PWM_VCV_CTL_PEAK_ST`**: PWM control peak start value.
*   **`T_DUR_VCV_CTL_DEACC`**: Deactivation duration for VCV control.
*   **`PWM_VCV_DEACC_PEAK`**: PWM deactivation peak value.
*   **`LV_VCV_CLOSE_RNG_MIN`**: Minimum VCV close range.
*   **`T_DUR_VCV_CTL_0_FW`**: Forward duration for VCV control.
*   **`CUR_VCV_OPL_CTL_MAX`**: Maximum operating current for VCV control.

## Logic Flow

1.  **Input Reception**: The `CLC_PRM_VCV_ACT_OFF_CLOSE` module (the main functional block) receives three primary input signals: `<STATE_VCV>`, `<VCV_CLOSE_RNG>`, and a generic `<input>` bundle. These signals provide the necessary context and demand information for the VCV's operation.

2.  **Internal Processing and Parameter Calculation**:
    *   Within the `CLC_PRM_VCV_ACT_OFF_CLOSE` block, a functional logic (represented by `f()`) takes these inputs and processes them.
    *   This processing involves complex calculations based on the current VCV state (`<STATE_VCV>`), the VCV closing range (`<VCV_CLOSE_RNG>`), and other implicit system variables bundled within `<input>` (e.g., engine speed, battery voltage).
    *   The module utilizes various calibration maps (e.g., `IP_VCV_OPEN_ADD`, `IP_T_DUR_VCV_CTL_1`, `IP_T_DLY_VCV_CLOSE_ADD_3`) to determine the precise values for actuation angles, current durations, and PWM signals. For example:
        *   `ANG_CUR_ON_VCV` is calculated from a calibration map based on VCV open add, battery voltage, and engine speed.
        *   `T_DUR_VCV_CTL_PEAK` is derived from a calibration map, considering VCV closing angle and engine speed during the pull-in phase.
        *   `T_DLY_VCV_CLOSE_ADD` is calculated from a calibration map, considering the delay between current deactivation and mechanical closing, dependent on VCV closing angle and engine speed.
    *   The logic also determines appropriate PWM frequencies and values for different operational phases (peak, start, deactivation) to ensure effective and controlled VCV actuation.

3.  **Output Bundling**: All the individually calculated actuation and control parameters are collected and bundled together into a single composite signal.

4.  **Output Generation**: The bundled signal, named `clc_prm_vcv_act_off_close`, is then output from the module. This output provides all the necessary detailed control commands to the downstream control units or actuator drivers for precise management of the fuel pressure VCV.


--- Page 266 ---

This page contains a Simulink diagram.

## Function

The primary function of this Simulink diagram is to calculate and output various control parameters for a **Fuel Pressure Actuator**, likely a Volume Control Valve (VCV) or similar electro-mechanical component in a fuel system. The calculations involve Pulse Width Modulation (PWM) signals, time durations (`T_DUR`), time delays (`T_DLY`), angular current (`ANG_CUR`), and frequencies (`FRQ_PWM`). It integrates lookup table mappings, conditional logic, and basic arithmetic operations to determine the appropriate control signals based on the VCV's state and other operating conditions. The title "FUSL, Fuel pressure actuator control" explicitly states this purpose.

## Inputs

The key inputs to this system are:

*   **`<STATE_VCV>`**: An input representing the current operating state of the VCV (e.g., active, inactive, specific mode).
*   **`<VCV_CLOSE_RNG>`**: An input likely indicating a closing range or state for the VCV.
*   **`x_val`**: An independent variable for various 2D lookup tables, often representing an engine operating parameter like engine speed or fuel pressure.
*   **`y_val`**: Another independent variable for the 2D lookup tables, often representing an engine operating parameter like engine load, injection quantity, or another pressure value.
*   **`<input>` (generic)**: Several generic input blocks are present, suggesting further unnamed system variables or sensor readings.
*   **`C_FRQ_PWM_VCV_CUR_OPL_CTL`**: A parameter or constant related to the frequency of the PWM current for VCV operation.

## Outputs

The system generates a comprehensive set of control parameters and status signals, including:

*   **`PWM_VCV_CTL_0`, `PWM_VCV_CTL_1`, `PWM_VCV_CTL_ST`**: PWM control signals or status for the VCV.
*   **`ANG_CUR_ON_VCV`**: Angular current value for VCV activation.
*   **`VCV_OPEN_ADD`**: An additional opening value for the VCV.
*   **`T_DUR_VCV_CTL_PEAK`**: Peak duration for VCV control.
*   **`T_DLY_VCV_CTL_HOLD_0`**: Hold delay duration for VCV control.
*   **`T_DLY_VCV_CLOSE_ADD`**: Additional closing delay duration for the VCV.
*   **`ANG_CUR_OFF_VCV`**: Angular current value for VCV deactivation.
*   **`LFUP_MIN_VCV_LOCK`**: A minimum lock value for the VCV fuel pressure.
*   **`T_DUR_VCV_CTL_FW`**: Forward duration for VCV control.
*   **`<T_VCV_CTL_ST>`**: VCV control status duration.
*   **`<LF_CUR_CTL_MOD_VCV>`**: Current control mode for the VCV.
*   **`<PWM_VCV_CTL_PEAK>`**: Peak PWM control value for the VCV.
*   **`<PWM_VCV_CTL_PEAK_ST>`**: Peak PWM control status for the VCV.
*   **`FRQ_PWM_VCV_CTL_ST`**: Frequency of PWM for VCV control status.
*   **`FRQ_PWM_VCV_CTL_PEAK`**: Peak frequency of PWM for VCV control.
*   **`FRQ_PWM_VCV_CTL_0`, `FRQ_PWM_VCV_CTL_1`**: Specific frequency values for VCV control.
*   **`FRQ_PWM_VCV_DEACC_PEAK`**: Peak deactivation frequency for VCV PWM.
*   **`FRQ_PWM_VCV_CTL_DEACC`**: Deactivation frequency for VCV PWM control.
*   **`FRQ_PWM_VCV_CTL_PEAK_ST`**: Peak deactivation frequency status for VCV PWM.
*   **`<T_DUR_VCV_DEACC>`**: Deactivation duration for the VCV.
*   **`<PWM_VCV_DEACC_PEAK>`**: Peak deactivation PWM value for the VCV.
*   **`<LV_VCV_CLOSE_RNG_MIN>`**: Minimum VCV close range level.
*   **`<T_DUR_VCV_CTL_0_FW>`**: Forward duration for VCV control (version 0).
*   **`<CUR_VCV_OPL_CTL_MAX>`**: Maximum operating current for VCV control.

## Logic Flow

The logical flow can be broadly categorized into several parallel processing paths, often converging or influencing each other:

1.  **Initial VCV State and Range Processing:**
    *   The `CLC_PWM_VCV_CTL` (possibly "Calculated PWM VCV Control") block takes `<STATE_VCV>` and `<VCV_CLOSE_RNG>` as inputs to directly determine `PWM_VCV_CTL_0`, `PWM_VCV_CTL_1`, and `PWM_VCV_CTL_ST`. This suggests a state-dependent initial setup for the PWM control.

2.  **VCV Opening and Angular Current Calculation:**
    *   The `IP_VCV_OPEN_ADD` (Interpolated Parameter VCV Open Add) 2D lookup table uses `x_val` and `y_val` to output a `P_val`.
    *   This `P_val` is then used to calculate `ANG_CUR_ON_VCV` (through a gain block) and `VCV_OPEN_ADD` (directly assigned). This path likely determines the initial activation current and an additional opening value based on operating conditions.

3.  **Duration and Delay Parameter Calculation:**
    *   Several 2D lookup tables (`IP_T_DUR_VCV_CTL_1`, `IP_T_DLY_VCV_CLOSE_ADD_3`, `IP_VCV_OPEN_LIM_3`, etc.) are used. Each takes `x_val` and `y_val` as inputs to determine various `P_val` outputs.
    *   These `P_val` outputs are then processed through gain blocks (triangle symbol) or directly assigned to outputs like `T_DUR_VCV_CTL_PEAK`, `T_DLY_VCV_CTL_HOLD_0`, `T_DLY_VCV_CLOSE_ADD`. These determine timing aspects of the VCV operation.

4.  **Angular Delay Compensation:**
    *   An input `ang_dly_vcv` (possibly an angular delay) is multiplied by a constant `0.006`.
    *   This adjusted value (`[ang_dly_vcv]`) is then used in an arithmetic block with an equality check `== 0` and an adder, suggesting a compensation or adjustment mechanism. The output of this path likely feeds into other calculations, influencing final timing or current values. For instance, it's summed with a value from `IP_VCV_OPEN_LIM_3` to produce `ANG_CUR_OFF_VCV` after a `max` function with 0.

5.  **Forward/Lock VCV Control Parameters:**
    *   A block labeled `C_T_DUR_VCV_CTL_FW` (Constant Time Duration VCV Control Forward) directly outputs `T_DUR_VCV_CTL_FW`.
    *   Inputs `x_val`, `y_val` feed into `IP_VCV_OPEN_LIM_3` to determine `P_val`. This `P_val` is combined with the compensated `ang_dly_vcv` and possibly other inputs (e.g., `0`) through an adder and a `max` block to derive `ANG_CUR_OFF_VCV`, `LFUP_MIN_VCV_LOCK`. Other outputs like `T_VCV_CTL_ST`, `LF_CUR_CTL_MOD_VCV`, `PWM_VCV_CTL_PEAK`, `PWM_VCV_CTL_PEAK_ST` are also derived in this section, often directly from constants or simple assignments, or via gains.

6.  **Frequency and Deactivation PWM Control:**
    *   A significant part of the diagram focuses on `FRQ_PWM_VCV_CUR_OPL_CTL` (Frequency PWM VCV Current Open Loop Control). This input is fed through multiple gain blocks to generate various frequency-related outputs: `FRQ_PWM_VCV_CTL_ST`, `FRQ_PWM_VCV_CTL_PEAK`, `FRQ_PWM_VCV_CTL_0`, `FRQ_PWM_VCV_CTL_1`, `FRQ_PWM_VCV_DEACC_PEAK`, `FRQ_PWM_VCV_CTL_DEACC`, `FRQ_PWM_VCV_CTL_PEAK_ST`. This suggests detailed control over the PWM frequency for different operating states (e.g., peak, deactivation, standard).
    *   Outputs like `T_DUR_VCV_DEACC` and `PWM_VCV_DEACC_PEAK` are also derived in this section, often from direct constants or simple assignments.

7.  **Final Constant/Parameter Outputs:**
    *   Outputs such as `LV_VCV_CLOSE_RNG_MIN`, `T_DUR_VCV_CTL_0_FW`, and `CUR_VCV_OPL_CTL_MAX` are directly assigned from constant values (0, 1, 100) or specific parameter blocks, indicating fixed or configuration-dependent values.

In summary, the diagram orchestrates a complex control strategy for a fuel pressure actuator by mapping operating conditions via lookup tables, adjusting parameters with arithmetic and logical blocks, and outputting a comprehensive set of PWM, duration, delay, current, and frequency values to precisely manage the actuator's behavior.


--- Page 267 ---

This page contains a Simulink-like block diagram.

## Function
The primary function of this Simulink diagram is to calculate the Pulse Width Modulation (PWM) duty cycle for a Volume Control Valve (VCV) in a fuel pressure actuator control system, specifically during its "holding phase." It determines the appropriate duty cycles (`PWM_VCV_CTL_0`, `PWM_VCV_CTL_1`, `PWM_VCV_CTL_ST`) based on various operating conditions, including engine start, maximum delivery, and normal operation, incorporating corrections for battery voltage, VCV closing angle, engine speed, and VCV coil temperature.

## Inputs
*   **STATE_VCV:** Current operating state of the VCV (e.g., MFP_MAX, MFP_START).
*   **MFP_MAX:** Reference signal or constant indicating the maximum fuel delivery state.
*   **MFP_START:** Reference signal or constant indicating the engine start phase.
*   **<FUP>:** Current Fuel Pressure.
*   **<FUP_SP>:** Fuel Pressure Setpoint.
*   **<VB>:** Battery Voltage.
*   **<VCV_CLOSE_RNG>:** VCV Closing Angle.
*   **<N_32>:** Engine Speed.
*   **<TFPA>:** VCV Coil Temperature.

## Outputs
*   **PWM_VCV_CTL_0:** Calculated PWM duty cycle for VCV control (output 0).
*   **PWM_VCV_CTL_1:** Calculated PWM duty cycle for VCV control (output 1).
*   **PWM_VCV_CTL_ST:** Calculated PWM duty cycle for VCV control (status/main output).

## Logic Flow

The logical flow determines the VCV PWM duty cycles through a series of conditional evaluations and calculations:

1.  **State-Dependent Condition Evaluation:**
    *   **Condition A:** `STATE_VCV == MFP_MAX` (Is the VCV in maximum fuel delivery state?)
    *   **Condition B:** `STATE_VCV == MFP_START` AND `FUP < FUP_SP` (Is it engine start AND fuel pressure is below setpoint?)
    *   **Condition C:** `STATE_VCV == MFP_START` (Is it engine start?)

2.  **Primary Conditional Logic (If-Else Structure):**
    *   **If (Condition A OR Condition B) is TRUE:**
        *   This indicates a "maximum delivery" mode or an "engine start with low fuel pressure" scenario. According to the accompanying text, "maximum delivery mode is considered and no current feed is applied." This path provides specific values for `PWM_VCV_CTL_0`, `PWM_VCV_CTL_1`, and `PWM_VCV_CTL_ST` (likely zero duty cycle or a fixed value for max opening by suction).
    *   **ELSE IF (Condition C is TRUE):**
        *   This specifically handles the `MFP_START` phase when the previous `OR` condition was false (implying `FUP >= FUP_SP` during start). In this case, `PWM_VCV_CTL_ST` is explicitly set to `0`. The behavior of `PWM_VCV_CTL_0` and `PWM_VCV_CTL_1` for this specific sub-case isn't directly shown as `0` from this branch, suggesting they might be calculated differently or maintain values from the "normal" path if not explicitly overridden.
    *   **ELSE (Normal Operating Condition):**
        *   If none of the above specific high-priority conditions are met, the system proceeds with calculations for normal VCV operation.
        *   **Base Duty Cycle for `PWM_VCV_CTL_ST`:** A base value (`IP_val`) is determined by a 1D lookup table named `IP_PWM_VCV_CTL_PULSE_ST`. The primary input to this lookup table is `<VB>` (Battery Voltage). This `IP_val` is then an input to the merge block for `PWM_VCV_CTL_ST`.
        *   **Corrected Duty Cycles for `PWM_VCV_CTL_0`, `PWM_VCV_CTL_1` (and potentially `PWM_VCV_CTL_ST`):** A function block `CLC_PWM_VCV_CTL_2_OPM` performs further calculations. It takes `VCV_CLOSE_RNG` (VCV closing angle), `N_32` (Engine speed), `TFPA` (VCV coil temperature), and `<VB>` (Battery Voltage) as inputs. This block likely applies various correction factors or performs complex map-based interpolations. Its outputs are `PWM_VCV_CTL_0` and `PWM_VCV_CTL_1` (and another signal labeled `<clc_pwm_vcv_ctl_1_opm>`, potentially a refined `PWM_VCV_CTL_ST`). These calculated values are then fed into the respective merge blocks.

3.  **Output Merging:**
    *   Finally, "Merge" blocks select the appropriate duty cycle values for `PWM_VCV_CTL_0`, `PWM_VCV_CTL_1`, and `PWM_VCV_CTL_ST` based on which conditional path was active.
    *   `PWM_VCV_CTL_ST` will be either `0` (during a specific `MFP_START` condition), `IP_val` (during normal operation), or a specific value from the (Condition A OR B) path.
    *   `PWM_VCV_CTL_0` and `PWM_VCV_CTL_1` will be either specific values from the (Condition A OR B) path or the calculated outputs from the `CLC_PWM_VCV_CTL_2_OPM` function block during normal operation.


--- Page 268 ---

This page contains two Simulink diagrams that are part of a fuel pressure actuator control system.

## Function
The primary function of these diagrams is to calculate open-loop control values for a Variable/Volume Control Valve (VCV) used in fuel pressure management. Specifically, one diagram calculates the Pulse Width Modulation (PWM) duty cycle for the VCV based on various operating conditions and demand, while the other determines a current setpoint for the VCV in open-loop mode. These calculations contribute to regulating fuel pressure or flow by controlling the VCV.

## Inputs
1.  **`<VB>`**: Battery voltage or system voltage, likely used as an independent variable for lookup tables.
2.  **`<N_32>` / `<N_val>`**: Engine speed (RPM) or a similar engine operational parameter, serving as an independent variable for multiple lookup tables. The two different labels might indicate distinct ranges or purposes, or simply slightly different naming conventions.
3.  **`<VCV_CLOSE_RNG>`**: A parameter or signal indicating a specific operating range or condition for the VCV, such as a "close range" or a low flow requirement.
4.  **`<TFPA>`**: Throttle or Fuel Pedal Angle, representing driver demand or engine load.
5.  **`<CUR_VCV_OPL_CTL_MAX>`**: The maximum permissible current setpoint for the VCV when operating in open-loop control.
6.  **`<PWM_VCV_OPL_CTL_MAX>`**: A maximum PWM value or scaling factor for open-loop VCV control.

## Outputs
1.  **`<clc_pwm_vcv_ctl_1_opm>`**: The calculated Pulse Width Modulation (PWM) signal (e.g., duty cycle) for controlling the VCV in open-loop mode. This is the main control output from the first diagram.
2.  **`<clc_aux>`**: An auxiliary calculated value, representing an open-loop current setpoint or a related scaled current for the VCV from the second diagram.

## Logic Flow

The diagrams represent two distinct calculation paths:

**1. Calculation of Open-Loop PWM Control (Figure 43.15.92 - Top Diagram)**

*   **Step 1: Base PWM Determination**
    *   The input `<VB>` (e.g., battery voltage) and `<N_32>` (e.g., engine speed) are fed into the `IP_PWM_VCV_CTL_PULSE` 2D lookup table. This table interpolates to provide a base PWM pulse value for the VCV, likely compensating for voltage variations and engine speed.
*   **Step 2: Close Range Factor Application**
    *   The input `<N_32>` and `<VCV_CLOSE_RNG>` are used as inputs for the `IP_FAC_CLOSE_RNG_PWM_VCV_CTL` 2D lookup table. This table outputs a scaling factor related to the VCV operating in a specific "close range."
    *   The base PWM value from Step 1 is then combined (likely multiplied, indicated by 'x' in `V.7.8` block) with this close range factor.
*   **Step 3: Driver Demand Factor Application**
    *   The input `<N_32>` and `<TFPA>` (throttle/fuel pedal angle) are fed into the `IP_FAC_TFPA` 2D lookup table. This table provides another scaling factor based on engine speed and driver demand.
    *   The result from Step 2 is then combined (likely multiplied, indicated by 'x' in the second `V.7.8` block) with the TFPA factor.
*   **Step 4: Output PWM Signal**
    *   The final combined value is output as `<clc_pwm_vcv_ctl_1_opm>`, which is the calculated open-loop PWM control signal for the VCV.

**2. Calculation of Set Point During Open Loop VCV Current Control (Figure 43.15.93 - Bottom Diagram)**

*   **Step 1: Requested Current Lookup**
    *   The input `<N_val>` (e.g., engine speed) and `<CUR_VCV_OPL_CTL_MAX>` (maximum VCV open-loop current) are fed into the `IP_PWM_CUR_VCV_REQ` 2D lookup table. This table determines a requested VCV current value based on these two parameters.
*   **Step 2: Current Scaling**
    *   The requested current value from Step 1 is then combined (likely multiplied, indicated by 'x' in `V.7.11` block) with the input `<PWM_VCV_OPL_CTL_MAX>`. This further scales the requested current, possibly to respect an overall PWM-related maximum.
*   **Step 3: Output Auxiliary Value**
    *   The resulting scaled current value is output as `<clc_aux>`, which represents an auxiliary calculated value for the open-loop VCV current setpoint.


--- Page 269 ---

This image does contain a Simulink diagram.

## Function

This Simulink diagram implements a conditional control logic for a fuel pressure actuator, likely a Volume Control Valve (VCV), as part of a fuel system control module (indicated by "FUSL, Fuel pressure actuator control"). Its primary function is to select between two distinct operational modes: "Time Mode" (`CLC_TIME_MODE`) and "Cranking Mode" (`CLC_CRK_MODE`), based on a set of input conditions. Once a mode is selected, it triggers the corresponding control sub-logic and outputs a consolidated set of control actions (`clc_action`) appropriate for the active mode. The "FUSL" prefix suggests an adherence to functional safety standards in its design.

## Inputs

The diagram receives numerous inputs, which primarily drive the mode selection and provide operational parameters for the chosen control mode.
*   **Mode Selection Conditions:**
    *   `<MFP_START>`: A flag or state indicating the main fuel pump start condition.
    *   `<STATE_VCV>`: The current operational state of the Volume Control Valve.
    *   `<LV_INH_VCV>`: A boolean signal indicating if the VCV control is inhibited (Level Inhibit VCV).
    *   `<LV_VCV_CLOSE_RNG_MIN>`: A boolean signal related to a minimum closing range for the VCV.
*   **Parameters/Actions for CLC_TIME_MODE (when active):**
    *   `<ACTION_INFR_MflDisable_T3>`
    *   `<ACTION_INFR_MflStart_T3>`
    *   `<ACTION_INFR_SetCurCtlModeVcv_T3>`
    *   `<ACTION_INFR_MflUpdate_T3>`
    *   `<FRQ_PWM_VCV_CTL_ST>` (Frequency PWM VCV Control Start)
    *   `<LF_CUR_CTL_MOD_VCV>` (Low-Frequency Current Control Mode VCV)
    *   `<LV_VCV_STOP_REQ>` (Level VCV Stop Request)
    *   `<PUMP_NR>` (Pump Number)
    *   `<PWM_VCV_CTL_PEAK_ST>` (PWM VCV Control Peak Start)
    *   `<PWM_VCV_CTL_ST>` (PWM VCV Control Start)
    *   `<T_DUR_VCV_CTL_FW>` (Time Duration VCV Control Forward)
    *   `<T_VCV_CTL_ST>` (Time VCV Control Start)
*   **Parameters/Actions for CLC_CRK_MODE (when active):**
    *   `<ACTION_INFR_MflEnable_T3>`
    *   `<ACTION_INFR_MflSetVcvCtlPls_T3>` (VCV Control Pulse Setting)
    *   `<ACTION_INFR_MflSetVcvDeaccPls_T3>` (VCV Deacceleration Pulse Setting)
    *   `<ACTION_INFR_MflUpdate_T3>`
    *   `<ACTION_INFR_SetCurCtlModeVcv_T3>`
    *   `<ANG_CUR_OFF_VCV>` (Angle Current Off VCV)
    *   `<ANG_CUR_ON_VCV>` (Angle Current On VCV)
    *   `<ANG_REF_VCV>` (Angle Reference VCV)
    *   `<FRQ_PWM_VCV_CTL_0>` (Frequency PWM VCV Control 0)
    *   `<FRQ_PWM_VCV_CTL_1>` (Frequency PWM VCV Control 1)
    *   `<FRQ_PWM_VCV_CTL_DEACC>` (Frequency PWM VCV Control Deacceleration)
    *   `<FRQ_PWM_VCV_CTL_PEAK>` (Frequency PWM VCV Control Peak)
    *   `<FRQ_PWM_VCV_DEACC_PEAK>` (Frequency PWM VCV Deacceleration Peak)
    *   `<LF_CUR_CTL_MOD_VCV>`
    *   `<LV_VCV_OPEN_SL_AUTH>` (Level VCV Open Safety Limit Authorization)
    *   `<LV_VCV_STOP_REQ>`
    *   `<PUMP_NR>`
    *   `<PWM_VCV_CTL_0>`
    *   `<PWM_VCV_CTL_1>`
    *   `<PWM_VCV_CTL_DEACC>`
    *   `<PWM_VCV_CTL_PEAK>`
    *   `<PWM_VCV_DEACC_PEAK>`
    *   `<PWM_VCV_OPL_CTL_MAX>` (PWM VCV Open Position Limit Control Max)
    *   `<T_DEACC_OFF_VCV>` (Time Deacceleration Off VCV)
    *   `<T_DEACC_ON_VCV>` (Time Deacceleration On VCV)
    *   `<T_DUR_VCV_CTL_0_FW>` (Time Duration VCV Control 0 Forward)
    *   `<T_DUR_VCV_CTL_DEACC>` (Time Duration VCV Control Deacceleration)
    *   `<T_DUR_VCV_CTL_FW>`
    *   `<T_DUR_VCV_CTL_HOLD_0>` (Time Duration VCV Control Hold 0)
    *   `<T_DUR_VCV_CTL_PEAK>` (Time Duration VCV Control Peak)
    *   `<T_DUR_VCV_DEACC_FW>` (Time Duration VCV Deacceleration Forward)

## Outputs

The outputs represent the activated control mode and the resulting actions/parameters for the fuel pressure actuator.
*   `clc_action`: A bundled output (likely a bus or structure) containing the specific control commands, states, or parameters determined by the active mode (`CLC_TIME_MODE` or `CLC_CRK_MODE`) to control the VCV.
*   `fc_clc_time_mode`: A function-call trigger signal, activated when the "Time Mode" is selected. This likely triggers a separate subsystem or function implementing the time-based control.
*   `fc_clc_crk_mode`: A function-call trigger signal, activated when the "Cranking Mode" is selected. This likely triggers a separate subsystem or function for VCV control during engine cranking.

## Logic Flow

1.  **VCV State and Start Condition Check:** The logic first compares the current VCV state (`<STATE_VCV>`) with a `MFP_START` condition using an equality block (`==`). If they are equal, this comparison yields `true`.
2.  **VCV Inhibition Check:** The `<LV_INH_VCV>` signal, which indicates VCV inhibition, is logically inverted by a `NOT` block. If the VCV is *not* inhibited, this results in `true`.
3.  **Mode Selection Pre-condition:** The output of the `STATE_VCV == MFP_START` comparison, the inverted `LV_INH_VCV` signal, and the `<LV_VCV_CLOSE_RNG_MIN>` signal are fed into an `OR` block.
    *   If *any* of these three conditions are `true`, the `OR` block's output, labeled `cond_if`, becomes `true`. This `cond_if` signal acts as the primary decision variable for the subsequent conditional execution.
4.  **Conditional Mode Execution (If-Else Block):** An "If" block uses the `cond_if` signal to select one of two execution paths:
    *   **If `cond_if` is `true` (the "if" branch is taken):**
        *   The `fc_clc_time_mode` trigger signal is activated.
        *   The `CLC_TIME_MODE` subsystem (X.2.1.2.2.5.1) is enabled. This subsystem processes a specific set of input parameters (e.g., `ACTION_INFR_MflDisable_T3`, `FRQ_PWM_VCV_CTL_ST`, etc.) relevant for VCV control in "Time Mode" operation.
    *   **Else (`cond_if` is `false`, the "else" branch is taken):**
        *   The `fc_clc_crk_mode` trigger signal is activated.
        *   The `CLC_CRK_MODE` subsystem (X.2.1.2.2.5.2) is enabled. This subsystem processes a different set of input parameters (e.g., `ACTION_INFR_MflEnable_T3`, `ANG_CUR_ON_VCV`, `PWM_VCV_CTL_DEACC`, etc.) tailored for VCV control during the engine "Cranking Mode".
5.  **Output Merging and Final Action:** The control actions generated by the *currently active* mode subsystem (`CLC_TIME_MODE` or `CLC_CRK_MODE`) are passed to a `Merge` block. This `Merge` block combines the outputs from the mutually exclusive paths into a single `clc_action` output. This `clc_action` then represents the final commands and parameters to be used by downstream components to control the fuel pressure actuator.


--- Page 271 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, titled "FUSL, Fuel pressure actuator control", primarily functions as a hierarchical control logic for a Fuel Pump Volume Control Valve (VCV). It orchestrates the starting, updating, and disabling of the VCV's operation based on several input conditions, likely to manage fuel pressure and flow within an automotive fuel system. The core logic decides whether to activate a "start" sequence (potentially different modes: `MflStart_1`, `MflStart_2`, `MflStart_3`) or a "disable" sequence (`MflDisable`).

## Inputs

The key inputs, represented by green blocks, are:

*   `<LV_VCV_STOP_REQ>`: A logical flag indicating a request to stop the VCV.
*   `<PWM_VCV_CTL_ST>`: The status of the VCV's Pulse Width Modulation (PWM) control.
*   `<LV_VCV_PUMP_ENG_MIN>`: A logical flag indicating if the pump engine speed is at or above a minimum threshold.
*   `<ACTION_INFR_SetCurCtlModeVcv_T3>`: A trigger or parameter for setting the VCV current control mode.
*   `<PUMP_NR>`: The identifier or number of the fuel pump.
*   `<LF_CUR_CTL_MOD_VCV>`: The requested current control mode for the VCV.
*   `<ACTION_INFR_MflUpdate_T3>`: A trigger or parameter for the Mfl update function.
*   `<ACTION_INFR_MflStart_T3>`: A trigger or parameter for the Mfl start function.
*   `<T_VCV_CTL_ST>`: VCV control status time.
*   `<PWM_VCV_CTL_PEAK_ST>`: Peak PWM control value for the VCV status.
*   `<FRQ_PWM_VCV_CTL_PEAK_ST>`: Peak PWM control frequency for the VCV status.
*   `<FRQ_PWM_VCV_CTL_ST>`: PWM control frequency for the VCV status.
*   `<C_T_DUR_MAX>`: Maximum duration constant.
*   `<T_DUR_VCV_CTL_FW>`: VCV control duration time for forward operation.
*   `<ACTION_INFR_MflDisable_T3>`: A trigger or parameter for the Mfl disable function.
*   `<LC_VCV_DI_MOD>`: VCV diagnostic mode.

## Outputs

The main outputs are the triggered function calls and their respective parameters, as well as one explicit output signal:

*   **Function Calls:**
    *   `fcn_call(ACTION_INFR_SetCurCtlModeVcv)`: Sets the current control mode of the VCV.
    *   `fcn_call(ACTION_INFR_MflUpdate)`: Updates internal states or parameters related to Mfl.
    *   `fcn_call(ACTION_INFR_MflStart)`: Initiates or fully controls the VCV with detailed timing and PWM parameters.
    *   `fcn_call(ACTION_INFR_MflDisable)`: Disables or puts the VCV into a safe state.
*   **Explicit Output Signal:**
    *   `<LV_VCV_STOP_REQ_DISABLE_MODE>`: A logical signal indicating a stop request in disable mode.

## Logic Flow

The logical flow of the diagram proceeds as follows:

1.  **Main Control Decision (Enable/Disable Mfl):**
    *   The diagram begins with a primary `if-else` condition (`cond_if`). This condition determines whether to activate the "MflDisable" logic (the `if` path) or one of the "MflStart" logics (the `else` path).
    *   The `if` path (triggering `fc_MflDisable`) is activated if the `OR` condition connected to `cond_if` is true.
    *   The `OR` condition evaluates three inputs:
        *   `(<LV_VCV_STOP_REQ> == 0)`: True if there is no VCV stop request (assuming 0 means no request, and 1 means request).
        *   `NOT(<LV_VCV_PUMP_ENG_MIN>)`: True if the pump engine speed is *not* at or above the minimum required threshold.
        *   `<PWM_VCV_CTL_ST>`: True if the PWM control status for the VCV is active (assuming non-zero means true).
    *   Therefore, `fc_MflDisable` is active if *any* of these three conditions are met.

2.  **MflStart Mode Selection:**
    *   If the `OR` condition (for `fc_MflDisable`) is false, the `else` path of the `cond_if` block is taken.
    *   This path feeds into a MUX block which selects one of three "MflStart" triggers: `fc_MflStart_1`, `fc_MflStart_2`, or `fc_MflStart_3`.
    *   The selection input to the MUX (`V.6.5`) is not explicitly shown but would typically be an internal state or mode selector determining which specific start sequence is required.

3.  **Function Execution based on Active Trigger:**
    *   **If `fc_MflStart_1` is active:** The function `ACTION_INFR_SetCurCtlModeVcv` is called. It takes inputs `ACTION_INFR_SetCurCtlModeVcv_T3`, `PUMP_NR`, and `LF_CUR_CTL_MOD_VCV` to configure the VCV's current control mode.
    *   **If `fc_MflStart_2` is active:** The function `ACTION_INFR_MflUpdate` is called. It takes `ACTION_INFR_MflUpdate_T3` and `PUMP_NR` as inputs, likely to update parameters or states related to the VCV's operation.
    *   **If `fc_MflStart_3` is active:** The function `ACTION_INFR_MflStart` is called. This function appears to be the most comprehensive "start" routine, receiving numerous parameters including `ACTION_INFR_MflStart_T3`, `PUMP_NR`, `T_VCV_CTL_ST`, `PWM_VCV_CTL_PEAK_ST`, `FRQ_PWM_VCV_CTL_PEAK_ST`, `PWM_VCV_CTL_ST`, `FRQ_PWM_VCV_CTL_ST`, `C_T_DUR_MAX`, and `T_DUR_VCV_CTL_FW` to precisely control the VCV's operation.
    *   **If `fc_MflDisable` is active:** The function `ACTION_INFR_MflDisable` is called. It receives inputs `ACTION_INFR_MflDisable_T3`, `PUMP_NR`, `LV_VCV_STOP_REQ`, and `LC_VCV_DI_MOD`. This function also produces an output signal, `LV_VCV_STOP_REQ_DISABLE_MODE`, indicating the stop request status within the disable mode.

In summary, the diagram implements a conditional execution of different VCV control actions (setting mode, updating, starting, or disabling) based on a high-level `if-else` decision that prioritizes the disable condition. The specific "start" mode is further selected by an internal mechanism.


--- Page 272 ---

This page contains two Simulink diagrams, one providing an overview and the other detailing specific logic for actuator control.

## Function

This Simulink diagram's primary function is to control a Volume Control Valve (VCV), likely associated with fuel pressure actuation (as indicated by "FUSL, Fuel pressure actuator control"). It dynamically switches the VCV's operational mode between an "actuator test mode" and a default "VCV open mode." Based on the active mode, it calculates and outputs the necessary Pulse Width Modulation (PWM) control signals, along with various status flags and operational parameters for the VCV. The actuator test mode likely involves precise timing and voltage-dependent corrections for diagnostic or calibration purposes.

## Inputs

Based on the detailed diagram (Figure 43.15.97):

*   **LV_ACR_VCV_TEST_REQ**: A boolean signal that acts as the primary switch to request or activate the actuator test mode.
*   **T_VCV_ACR_ACT**: An input parameter, likely representing a reference time or temperature, used within the actuator test mode calculations.
*   **VB**: System battery voltage, used for voltage-dependent corrections in actuator control.
*   **LV_VCV_ST_REQ**: A VCV state request signal, which appears to be passed through directly to the output.

*(Note: The overview diagram (Figure 43.15.96) shows additional inputs such as `LV_FUP_LIH_DPS_DI`, `ACTION_INFR_...`, `PUMP_NR`, and `LV_VCV_STOP_REQ`. These are likely internal inputs to the `CLC_VCV_ACR_TEST_1` subsystem, whose detailed logic is not fully shown in Figure 43.15.97 beyond the mode switching.)*

## Outputs

Based on the detailed diagram (Figure 43.15.97):

*   **LV_INH_VCV**: A boolean flag indicating whether the VCV operation is inhibited.
*   **LV_VCV_ACR_ACT**: A boolean flag indicating that the VCV actuator is currently active.
*   **PWM_VCV_CTL_1**: The Pulse Width Modulation control signal, which directly drives the VCV actuator.
*   **STATE_VCV**: A signal representing the current operational state of the VCV (e.g., test mode, open mode).
*   **T_VCV_ACR_ACT**: An output value representing the (potentially calculated or current) temperature or time of the VCV actuator, originating from the active operational mode.
*   **LV_VCV_ST_REQ**: The VCV state request signal, relayed from the input.

## Logic Flow

The logical flow, as depicted in Figure 43.15.97, focuses on mode selection and subsequent control signal generation:

1.  **Mode Selection (If-Else Condition):**
    *   The `cond_if` block (V.6.4) evaluates the boolean input signal `LV_ACR_VCV_TEST_REQ`. This signal is the central determinant for the VCV's operating mode.

2.  **Actuator Test Mode Activation (If `LV_ACR_VCV_TEST_REQ` is true):**
    *   If `LV_ACR_VCV_TEST_REQ` is true (indicating an actuator test is requested or active), the "if" branch is activated.
    *   This branch executes the `fc()` block named `CLC_VCV_ACR_ACT` (X.2.1.3.1.1).
    *   This function block receives `LV_ACR_VCV_TEST_REQ` (as true), the input `T_VCV_ACR_ACT`, and `VB` (battery voltage) as its inputs.
    *   Inside `CLC_VCV_ACR_ACT`, internal calculations occur, which, according to the accompanying text, include determining "pull-in time," "maximum pulse duration," and "free-wheel time," potentially with "voltage-dependent correction."
    *   The block then outputs specific values for `T_VCV_ACR_ACT` (the calculated test duration/parameter), `LV_INH_VCV`, `STATE_VCV`, `PWM_VCV_CTL_1` (the test-specific PWM signal), and `LV_VCV_ACR_ACT` relevant to the actuator test.

3.  **VCV Open/Default Mode Activation (If `LV_ACR_VCV_TEST_REQ` is false):**
    *   If `LV_ACR_VCV_TEST_REQ` is false (meaning no actuator test is requested), the "else" branch is activated.
    *   This branch executes the `fc()` block named `CLC_VCV_OPEN` (X.2.1.3.1.2).
    *   This function block receives `LV_ACR_VCV_TEST_REQ` (as false), `VB` (battery voltage), and a constant `0` (V.6.11, possibly a default or reset value).
    *   `CLC_VCV_OPEN` calculates and outputs the necessary control and status signals when the VCV is in its default "open" operational state. These outputs include `LV_INH_VCV`, `PWM_VCV_CTL_1` (the PWM signal for open mode), `T_VCV_ACR_ACT` (a default or calculated value for open mode), `LV_VCV_ACR_ACT`, and `STATE_VCV`.

4.  **Output Aggregation:**
    *   The specific outputs from the active `fc()` block (either `CLC_VCV_ACR_ACT` or `CLC_VCV_OPEN`) are collected.
    *   These signals (`LV_INH_VCV`, `LV_VCV_ACR_ACT`, `PWM_VCV_CTL_1`, `STATE_VCV`, `T_VCV_ACR_ACT`) are then fed into a `BusMerge` block (V.6.6), which consolidates them into a single structured bus.
    *   Concurrently, the input signal `LV_VCV_ST_REQ` bypasses the mode-switching logic and is directly routed to an output port.

5.  **Final Output:**
    *   The consolidated bus from the `BusMerge` block and the directly routed `LV_VCV_ST_REQ` signal are then presented as the final outputs of the subsystem, to be utilized by other components of the overall automotive system.


--- Page 273 ---

This page contains two Simulink diagram snippets related to Fuel Pressure Actuator Control, specifically for a VCV (Volume Control Valve) test mode. I will analyze the first, more detailed diagram (Figure 43.15.98) as the primary focus, and briefly touch upon the second (Figure 43.15.99) as a related mode.

## Function

The primary function of the first Simulink diagram (Figure 43.15.98) is to calculate and generate control signals for a Volume Control Valve (VCV) when it is in an "active actuator test mode". This involves generating a Pulse Width Modulated (PWM) signal with a 1-second period, where the duty cycle is dynamically determined based on battery voltage using a calibratable lookup table. It also computes flags to indicate the VCV's active state and an inhibition state based on a calibratable active duration.

The second diagram (Figure 43.15.99) appears to be a reset or initialization block for parameters when entering or exiting the `VCV_OPEN` mode, setting various output flags and control values to default states (e.g., inactive, inhibited, no PWM).

## Inputs

Based on Figure 43.15.98:
*   **`<T_VCV_ACR_ACT>`**: A time or duration parameter related to VCV active operation. It appears as both an input to a subsystem and an output, suggesting it might be an internal state variable.
*   **`<VB>`**: Battery voltage, used as an input to determine the PWM duty cycle.
*   **`C_T_VCV_ACR_ACT`**: A calibratable time constant or duration that defines how long the VCV should be actively actuated within the 1-second period.
*   **`VCV_OPEN`**: (Input to the `VCV_OPEN` block) Likely a signal indicating the VCV is in an "open" state or this specific mode is active.
*   **`STATE_VCV`**: (Input to the `VCV_OPEN` block) Represents the current operational state of the VCV.
*   **`LV_ACR_VCV_TEST_REQ`**: (Implied from the text description "During active actuator test mode (LV_ACR_VCV_TEST_REQ = 1)") - This signal likely enables the entire logic block, although it is not explicitly shown as a block input.

## Outputs

Based on Figure 43.15.98:
*   **`<STATE_VCV>`**: The updated operational state of the VCV.
*   **`<T_VCV_ACR_ACT>`**: The updated time or duration parameter for VCV active operation.
*   **`<LV_VCV_ACR_ACT>`**: A boolean flag (logical high/low) indicating whether the VCV is currently in its active actuation phase within the 1-second cycle.
*   **`<LV_INH_VCV>`**: A boolean flag indicating whether the VCV actuation is inhibited.
*   **`<PWM_VCV_CTL_1>`**: The Pulse Width Modulated (PWM) control signal for the VCV actuator.

## Logic Flow

The logical flow of the main diagram (Figure 43.15.98) can be broken down as follows:

1.  **1-Second Period Timer and Reset:**
    *   An integrator accumulates a value (`x_out`) over time.
    *   The output of this integrator (`x_out`) is compared against a constant value of `1 s` (1 second).
    *   When `x_out` reaches or exceeds `1 s`, a `reset` signal is generated. This `reset` signal is fed back to the integrator, causing it to reset its accumulated value to 0.
    *   This mechanism effectively creates a free-running timer that counts from 0 to 1 (or slightly less than 1) and resets every 1 second, establishing the 1 Hz frequency for the VCV pulses as described in the text.

2.  **VCV Active State Determination (`<LV_VCV_ACR_ACT>`):**
    *   The current value of the 1-second timer (`x_out`) is compared with `C_T_VCV_ACR_ACT`, which is a calibratable time duration.
    *   If `x_out` is less than `C_T_VCV_ACR_ACT`, a logical `true` signal (labeled `V.6.6`) is generated. This signal directly forms the output `<LV_VCV_ACR_ACT>`.
    *   Therefore, `<LV_VCV_ACR_ACT>` is true when the VCV is within its defined active duration `C_T_VCV_ACR_ACT` of the 1-second cycle.

3.  **VCV Inhibition Determination (`<LV_INH_VCV>`):**
    *   The signal `V.6.6` (which is true when `x_out < C_T_VCV_ACR_ACT`) is passed through a `NOT` gate.
    *   The output of the `NOT` gate becomes `<LV_INH_VCV>`.
    *   This means the VCV is inhibited (`<LV_INH_VCV>` is true) when `x_out` is greater than or equal to `C_T_VCV_ACR_ACT`, indicating that the active actuation phase for the current 1-second period has elapsed.

4.  **PWM Duty Cycle Calculation and Output (`<PWM_VCV_CTL_1>`):**
    *   The battery voltage `<VB>` is fed into a 1D lookup table named `IP_PWM_VCV_CTL_PULSE_ST`. This table maps the battery voltage (`x_val`) to a specific `IP_val`. According to the text, this table determines the duty cycle based on battery voltage.
    *   The calculated `IP_val` (the desired duty cycle, likely a fraction between 0 and 1) is then compared with the current value of the 1-second timer (`x_out`).
    *   If `x_out` is less than `IP_val`, a logical `true` signal (labeled `V.6.8`) is generated. This signal directly forms the PWM output `<PWM_VCV_CTL_1>`.
    *   Since `x_out` ramps from 0 to 1 over 1 second, comparing it to `IP_val` effectively generates a pulse whose width is proportional to `IP_val`. For example, if `IP_val` is 0.5, the output is high for the first 0.5 seconds of the 1-second period, resulting in a 50% duty cycle.

5.  **VCV Open Mode and State Management (`VCV_OPEN` block):**
    *   A block labeled `VCV_OPEN` takes `x_out` (1-second timer), `<T_VCV_ACR_ACT>`, and `STATE_VCV` as inputs.
    *   It outputs updated values for `<STATE_VCV>` and `<T_VCV_ACR_ACT>`. The exact internal logic of this block is not detailed but implies state machine or logical operations to manage the overall VCV operational mode and timing parameters within the test.

In summary, the system uses a 1 Hz internal timer to synchronize operations. Within each 1-second period, it generates a PWM signal for the VCV actuator whose duty cycle is calibrated based on battery voltage, and it provides status flags indicating if the VCV is actively actuated or inhibited, based on a calibratable duration.


--- Page 274 ---

This page contains two distinct Simulink-like diagrams related to automotive control systems, specifically for "Fuel pressure actuator control" (FUSL). Both diagrams implement timer logic for different purposes.

---

## Diagram 1: Component protection timer calculation (Figure 43.15.100)

### Function
This diagram calculates a component protection timer, `opm_10ms`, which operates at a 10ms interval. Its primary purpose is to prevent overheating of the VCV (Valve Control Valve, likely within the fuel pressure actuator system) during the engine's start phase. The timer accumulates time when a specific condition related to the VCV and MFP (Main Fuel Pump) start state is met.

### Inputs
*   **`<feedback>`**: A general feedback signal or bus, from which other internal signals might be extracted.
*   **`STATE_VCV` (V.6.12)**: The current operating state of the VCV.
*   **`MFP_START` (V.6.12)**: A signal indicating the start phase of the MFP.
*   **`x_in` (V.7.12)**: The previous output value of the timer, used for continuous accumulation.

### Outputs
*   **`opm_10ms`**: The accumulated value of the component protection timer.

### Logic Flow
1.  The system takes `STATE_VCV` and `MFP_START` as inputs.
2.  An equality comparison block (labeled V.6.6) checks if `STATE_VCV` is equal to `MFP_START`. The output of this comparison is a boolean signal.
3.  This boolean signal acts as the 'E' (Enable) input for a timer block (labeled V.7.12).
4.  The timer block (V.7.12) receives its previous output (`x_out`) as its current `x_in` input, forming a feedback loop. This configuration indicates an accumulating timer or an up-counter.
5.  When the enable input 'E' (i.e., `STATE_VCV == MFP_START`) is true, the timer (V.7.12) increments its internal value. The name `opm_10ms` and the description "calculation occurs at 10ms" imply that it increments based on a 10ms time base.
6.  The accumulated value `x_out` from the timer block is then output as `opm_10ms`.
In essence, this timer counts up as long as the VCV is in the "start" state (as defined by `MFP_START`).

---

## Diagram 2: Calculation of adaptation timer with 1s recurrence (Figure 43.15.101)

### Function
This diagram calculates an adaptation timer, `opm_1s`, with a 1-second recurrence. This timer is used to trigger a periodic re-adaptation cycle for the Short-Term/Self-Learning (SL) adaptation of the VCV, specifically for its closing operation.

### Inputs
*   **`<feedback>`**: A general feedback signal or bus, from which other internal signals might be extracted.
*   **`<T_VCV_CLOSE_SL_AD_VLD>`**: A signal (likely boolean or a count) indicating the validity of the VCV close SL adaptation.
*   **`<LV_VCV_CLOSE_SL_AD_END>`**: A signal (likely boolean) indicating the end of the VCV close SL adaptation.
*   **Constant `1` (V.6.11)**: Used for addition, potentially representing an increment.
*   **Constant `0` (V.6.11)**: Used for comparison.
*   **`x_in` (V.6.10)**: The previous output value of the timer, used for continuous accumulation.

### Outputs
*   **`opm_1s`**: The accumulated value of the adaptation timer.

### Logic Flow
1.  The system receives `<T_VCV_CLOSE_SL_AD_VLD>` as an input.
2.  An `ADD` block (V.7.7) adds a constant value of `1` to the `<T_VCV_CLOSE_SL_AD_VLD>` signal. The result of this addition acts as the 'E' (Enable) input for a timer block (labeled V.6.10). This setup suggests that when `<T_VCV_CLOSE_SL_AD_VLD>` meets a certain criterion (e.g., becomes 0, and thus the sum becomes 1, enabling the timer, or if `<T_VCV_CLOSE_SL_AD_VLD>` is 1, it results in 2, enabling the timer - specific interpretation depends on how `E` handles values >1). Assuming `E` is active when its input is non-zero, the timer is enabled when `T_VCV_CLOSE_SL_AD_VLD + 1` is non-zero.
3.  Concurrently, the signal `<LV_VCV_CLOSE_SL_AD_END>` is checked to see if it's not equal to `0` using a "Check ~= 0" block (V.6.11). If `<LV_VCV_CLOSE_SL_AD_END>` is true (i.e., not zero), the output of this block is true.
4.  The output of "Check ~= 0" acts as a reset signal for the timer block (V.6.10). This means the timer resets whenever `LV_VCV_CLOSE_SL_AD_END` is active (i.e., the adaptation cycle has ended).
5.  The timer block (V.6.10) is an accumulating timer, with its previous output (`x_out`) fed back as its current `x_in`. It increments when enabled ('E' is active) and is reset when the reset signal is active. The `opm_1s` name implies it measures or counts time in seconds.
6.  The accumulated value `x_out` from the timer block is then output as `opm_1s`.
In summary, this timer accumulates time as long as the VCV close SL adaptation is valid (as determined by the `ADD` operation) and resets each time an adaptation cycle ends. This creates a periodic counting mechanism that can trigger subsequent re-adaptation cycles.


--- Page 276 ---

This page contains two Simulink-like block diagrams (Figure 43.16.1 and Figure 43.16.2), which depict a system for fuel pressure actuator control.

## Function

The primary function of this system is "FUSL, Fuel pressure actuator control". It manages the operation of a fuel pressure actuator, likely a high-pressure fuel pump or a fuel metering valve, by handling initialization, executing operational logic, and monitoring camshaft-related positions to ensure accurate fuel delivery. Specifically, Figure 43.16.1 outlines the overall control flow with initialization and operational modes, while Figure 43.16.2 details the determination of the high-pressure pump's position on the camshaft, which is a critical input or state for the main control.

## Inputs

The system receives various inputs to control its behavior and perform calculations:

*   **Control & Mode Signals:**
    *   `FUSL M904R RST`: A reset signal, likely for system initialization.
    *   `FUSL M904R SEG`: A segment control signal, indicating operation segment activation/deactivation.
    *   `<LV_ES>`: An external state or enable signal that dictates the activation (`LV_ES==0`) and deactivation (`LV_ES==1`) of the operational segment.
*   **Camshaft Position & Feedback Signals:**
    *   `<PSN_CAM_EX>`: Position sensor input for the exhaust camshaft.
    *   `<PSN_CAM_IN>`: Position sensor input for the intake camshaft.
    *   `<NC_NR_CAM_CBK>`: Camshaft callback number, likely a feedback or current count related to cam events.
    *   `C_STATE_CAM_CBK_HPP` (V.6.4): Current state value for the camshaft callback specifically for the High-Pressure Pump, used for position determination.

## Outputs

The system generates several outputs to control the fuel pressure actuator and indicate its operational status:

*   **Internal Control Flags/Signals:**
    *   `fc_INI`: An internal flag or signal indicating an initialization request is active.
    *   `fc_OPM_SEG`: An internal flag or signal indicating the operational segment is active.
*   **Fuel Actuator Control:**
    *   `<CAM_FUEL_PUMP>` (also `CAM_FUEL_PUMP: O V`): Output control signal (e.g., voltage or duty cycle) for the camshaft-driven fuel pump.
    *   `<LV_VCV_OPEN_EXT_REQ>` (also `LV_VCV_OPEN_EXT_REQ: O V`): An external request to open the Volume Control Valve (VCV), likely controlling fuel flow or pressure.
*   **Camshaft State & Derived Values:**
    *   `STATE_CAM_CBK_HPP`: The processed state of the camshaft callback for the High-Pressure Pump.
    *   `CAM_NR_CBK`: Camshaft number callback, derived from `STATE_CAM_CBK_HPP`.
    *   `CAM_NR_GES`: Camshaft number (possibly "Gesamtwert" - total/overall value), also derived from `STATE_CAM_CBK_HPP`.

## Logic Flow

The system operates in distinct phases (Initialization and Operational) and incorporates a sub-function for camshaft position determination:

### Figure 43.16.1: Overall Fuel Pressure Actuator Control

1.  **System Reset and Segment Control:**
    *   A `FUSL M904R RST` signal triggers the `fc_INI` flag, initiating the initialization sequence.
    *   The `FUSL M904R SEG` signal, in conjunction with the external state `<LV_ES>`, controls the `fc_OPM_SEG` flag. `LV_ES==0` activates the operational segment (`fc_OPM_SEG`), while `LV_ES==1` deactivates it.
2.  **Initialization Block (`INI` X.1):**
    *   When `fc_INI` is active, the `INI` block (X.1) executes.
    *   It receives camshaft position inputs (`<PSN_CAM_EX>`, `<PSN_CAM_IN>`) and performs necessary initialization routines (e.g., setting initial states, calibrating sensors).
    *   The output of the `INI` block feeds into the `OPM` block, likely providing initial conditions or parameters.
3.  **Operational Block (`OPM` X.2):**
    *   The `OPM` block (X.2) represents the main operational logic, active when `fc_OPM_SEG` allows.
    *   It takes inputs from the `INI` block, continuous camshaft position signals (`<PSN_CAM_EX>`, `<PSN_CAM_IN>`), and camshaft callback numbers (`<NC_NR_CAM_CBK>`).
    *   It processes these inputs to calculate the required control actions for the fuel pump and VCV.
    *   It generates a `feedback` signal, suggesting a closed-loop control mechanism.
4.  **Output Aggregation (V.6.4 Block):**
    *   The outputs of the `OPM` block, including `CAM_FUEL_PUMP`, `LV_VCV_OPEN_EXT_REQ`, `CAM_NR_CBK`, `CAM_NR_GES`, and `STATE_CAM_CBK_HPP`, are aggregated and made available to other parts of the system.

### Figure 43.16.2: Determination of High Pressure Pump Position on Camshaft

This sub-function likely runs either during initialization or continuously during operation to provide precise camshaft-related information.

1.  **Input of High-Pressure Pump Cam State:**
    *   The process begins with `C_STATE_CAM_CBK_HPP` (V.6.4), which is a multi-bit input representing the current state or raw data related to the camshaft callback for the high-pressure pump.
2.  **Bit Extraction for Camshaft Values:**
    *   `C_STATE_CAM_CBK_HPP` acts as the `num_dec` input to two `GET BIT` blocks (V.7.0).
    *   The first `GET BIT` block, configured with `bit_sel = 0` (index base 0), extracts the 0th bit (least significant bit) from the `num_dec` input. This extracted bit forms the `CAM_NR_CBK` output.
    *   The second `GET BIT` block, configured with `bit_sel = 1` (index base 0), extracts the 1st bit from the `num_dec` input. This extracted bit forms the `CAM_NR_GES` output.
3.  **State Output:**
    *   The `STATE_CAM_CBK_HPP` output directly reflects the `C_STATE_CAM_CBK_HPP` input, possibly as a direct pass-through or a confirmed state, making the detailed bit values available as `CAM_NR_CBK` and `CAM_NR_GES`.


--- Page 277 ---

This page contains two Simulink-like diagrams (Figure 43.16.3 and Figure 43.16.4) related to fuel pressure actuator control. Both diagrams are structurally almost identical, suggesting they represent the same core calculation, possibly for different phases (initialization vs. continuous calculation) or minor version differences (indicated by V.6.9 vs V.6.12). I will describe the more detailed "Calculation" diagram, Figure 43.16.4.

## Function

The primary function of this Simulink diagram is to calculate the reference camshaft angle for a single piston fuel pump. This calculated angle, `<CAM_FUEL_PUMP>`, is derived from either the exhaust or intake camshaft position, adjusted by a constant offset. This angle is critical for precisely timing the fuel pump's operation within the overall fuel pressure actuator control system. Additionally, it explicitly sets an external request for the Volume Control Valve (VCV) to an inactive state (0).

## Inputs

*   **<CAM_NR_CBK>**: Camshaft Number Callback. This input likely provides a status or identifier related to the camshaft (e.g., its operational state or a counter). It's used for both exhaust and intake cam position processing.
*   **<PSN_CAM_EX>**: Camshaft Exhaust Position. Represents the current angular position of the exhaust camshaft.
*   **<PSN_CAM_IN>**: Camshaft Intake Position. Represents the current angular position of the intake camshaft.
*   **<CAM_NR_GES>**: Camshaft Global Number/Status. This input acts as a selector or condition for choosing between the processed exhaust and intake camshaft positions.

## Outputs

*   **<CAM_FUEL_PUMP>**: Camshaft Fuel Pump Reference Angle. This is the calculated target camshaft angle for controlling the single piston fuel pump.
*   **<LV_VCV_OPEN_EXT_REQ>**: Volume Control Valve Open External Request. This output is a boolean or integer signal indicating an external request to open the VCV. In this diagram, it is explicitly set to 0, implying no external open request is made by this function.

## Logic Flow (Figure 43.16.4)

1.  **Exhaust Camshaft Position Processing:**
    *   The input `<CAM_NR_CBK>` and `<PSN_CAM_EX>` are fed into a custom subsystem block (labeled `C0`, `[...]`, version V.6.12).
    *   This block likely performs some form of signal conditioning, scaling, lookup, or filtering on the exhaust camshaft position, possibly using the `<CAM_NR_CBK>` as a control parameter or for fault detection. The `[...]` typically indicates an array or complex internal logic.
    *   The output of this block is a processed exhaust camshaft position signal.

2.  **Intake Camshaft Position Processing:**
    *   In parallel, the input `<CAM_NR_CBK>` and `<PSN_CAM_IN>` are fed into an identical custom subsystem block (labeled `C0`, `[...]`, version V.6.12).
    *   Similar to the exhaust path, this block processes the intake camshaft position, producing a conditioned intake camshaft position signal.

3.  **Camshaft Position Selection:**
    *   The processed exhaust and intake camshaft positions, along with `<CAM_NR_GES>`, are fed into a "Check ~= 0" block (version V.6.6).
    *   This block acts as a selector or conditional switch. Based on the value of `<CAM_NR_GES>`, it chooses between the processed exhaust or intake camshaft position. For example, if `<CAM_NR_GES>` is non-zero, it might select the exhaust position; otherwise, it might select the intake position (or vice-versa, or use `<CAM_NR_GES>` as an index for more complex selection). The selected camshaft position is then passed to the next stage.

4.  **Reference Angle Calculation:**
    *   The selected camshaft position from the "Check ~= 0" block is then summed with a constant value, `C_OFS_CAM_REF_VCV` (version V.6.4), using a summation block (version V.7.2).
    *   `C_OFS_CAM_REF_VCV` represents a fixed offset applied to the camshaft position to determine the final reference angle for the fuel pump.
    *   The result of this summation is the final `<CAM_FUEL_PUMP>` output, which is the calculated camshaft reference angle for the single piston fuel pump.

5.  **VCV External Request Output:**
    *   A constant value `0` (version V.6.4) is directly assigned to the output `<LV_VCV_OPEN_EXT_REQ>`. This indicates that this specific calculation routine does not issue a request to open the Volume Control Valve (VCV) externally; the request is explicitly set to inactive or false.


--- Page 280 ---

This page contains two Simulink-style diagrams, referred to as Figure 43.17.1 and Figure 43.17.2, along with explanatory text.

## Function

The primary function of this system is to **calculate and manage the coil temperature of the Fuel Pressure Actuator (TFPA)**. This involves initializing the temperature at ECU reset, continuously calculating temperature differences arising from various heat sources (electrical self-heating, engine heat, fuel heat), and then deriving the current TFPA value, which can be provided in both high-resolution (for internal calculations) and low-resolution (for output) forms.

## Inputs

Based on Figure 43.17.1 (the top-level calculation) and the supporting text, the key inputs are:

*   **`fc_OPM`**: A control signal for the Fuel Pressure Actuator Coil Temperature calculation (likely enabling/disabling or specific modes).
*   **Initialization Signals**: Implied by "Init: RST" and "Activation: always", though not explicitly shown as an input port on the OPM block beyond `fc_OPM` for `ini`.
*   **Vehicle/Engine Operating Parameters (bundled into `<input>` for OPM):**
    *   `<LV_VAR_HPP>`
    *   `<N_32>` (likely engine speed)
    *   `<STATE_VCV>`
    *   `<TCO>` (Coolant Temperature, used for initialization)
    *   `<TFU_HPP>` (Fuel Temperature)
    *   `<TIA>` (Intake Air Temperature)
    *   `<VFF_HPP>`
    *   `<VS>`
*   **Calibration Parameters (from Figure 43.17.2):**
    *   `C_CRLC_TFPA_H`: A constant/coefficient for scaling TFPA\_DIF.
    *   `C_TFPA_H_MAX`: Maximum limit for TFPA\_H.
    *   `C_TFPA_H_MIN`: Minimum limit for TFPA\_H.

## Outputs

The primary outputs derived from the calculation, as seen in Figure 43.17.1:

*   **`<TFPA>`**: The main fuel pressure actuator coil temperature, likely the "low (for output variable) resolution value".
*   **Intermediate/Detailed Temperature Components (bundled from `opm` output):**
    *   `TFPA_O_V`
    *   `TFPA_DIF_V`: Temperature difference.
    *   `TFPA_EL_V`: Temperature contribution from electrical self-heating.
    *   `TFPA_ENG_V`: Temperature contribution from engine heat dissipation.
    *   `TFPA_FUEL_V`: Temperature contribution from fuel heat dissipation.
    *   `TFPA_H_V`: High-resolution TFPA, used for internal calculations.

## Logic Flow

The system operates in a scheduled, stateful manner, performing calculations periodically and handling initialization.

1.  **Initialization at ECU Reset (Implied by 43.17.1 text):**
    *   Upon a long engine shut-off period or ECU reset, the `TFPA` is initialized, typically to the coolant temperature (`TCO`). This is handled by the `OPM` block when it receives the initialization signal (`ini` port, likely triggered by `fc_OPM`).

2.  **Primary TFPA Calculation (Figure 43.17.1):**
    *   The main `OPM` (Operating Point Model) block, labeled `X.2`, executes every 1 second ("Recurrence: 1S").
    *   It receives a bundle of current vehicle/engine operating parameters (e.g., temperatures, speeds) through its `<input>` port.
    *   A `<feedback>` signal is fed back into the `OPM` block, indicating that the current calculation depends on its previous state or output, suggesting a dynamic, time-dependent model (e.g., a thermal model with inertia).

3.  **Temperature Difference Calculation (Detailed in Figure 43.17.2, conceptually part of OPM):**
    *   Within the overall `OPM` logic, a sub-component named `CLC_TFPA_DIF` (labeled `X.2.1`) calculates the temperature difference (`TFPA_DIF`). This block also receives its own `<input>` and `<feedback>` signals.
    *   The text "43.17.2.1 Calculation of temperature difference" specifies that `TFPA_DIF` accounts for `TFPA_EL` (electrical self-heating), `TFPA_ENG` (engine heat), and `TFPA_FUEL` (fuel heat).
    *   The `clc_tfpa_dif` output from this block is then scaled by multiplying it with the calibration parameter `C_CRLC_TFPA_H` (V.7.3).
    *   This scaled temperature difference is added (V.7.2) to another input signal (which likely represents the current or previous TFPA value, effectively integrating the temperature change).
    *   The sum is then passed through a limiter (V.6.8) that constrains its value between `C_TFPA_H_MIN` and `C_TFPA_H_MAX`, ensuring the calculated temperature remains within physical bounds.
    *   The output of this limiter is identified as `TFPA_H` (High-resolution TFPA), which is used for internal calculations.

4.  **Output Generation and Resolution (Figure 43.17.1 & 43.17.2):**
    *   The `OPM` block internally processes `TFPA_H` and other calculated temperature components.
    *   The `opm` output from the `OPM` block provides a bundle of various calculated temperatures and differences (`TFPA_O_V`, `TFPA_DIF_V`, `TFPA_EL_V`, `TFPA_ENG_V`, `TFPA_FUEL_V`, `TFPA_H_V`).
    *   Finally, the main output `<TFPA>` is derived from this bundle. The text implies `TFPA` is a "low (for output variable) resolution value", which likely means it's a filtered or rounded version of `TFPA_H` suitable for external use or other system components.


--- Page 281 ---

This page contains two Simulink diagrams, Figure 43.17.3 and Figure 43.17.4, which are part of a fuel supply system temperature management system.

---

## Analysis of Figure 43.17.3

### Function
This diagram's primary function is to calculate a combined temperature difference (`TFPA_DIF`) for the fuel pressure actuator (TFPA) by aggregating temperature effects from electrical heating, engine operation, and fuel, and then comparing this sum to a reference or feedback value.

### Inputs
*   **For `CLC_TFPA_EL` subsystem:**
    *   `<LV_VAR_HPP>`: Low-pressure variable of the high-pressure pump.
    *   `<STATE_VCV>`: State of the VCV (Volume Control Valve).
    *   `<N_32>`: Engine speed.
*   **For `CLC_TFPA_ENG` subsystem:**
    *   `<TIA>`: Intake air temperature.
    *   `<TCO>`: Coolant temperature.
    *   `<VS>`: Vehicle speed.
    *   `<TFPA_H>`: Fuel pressure actuator housing temperature (feedback or measurement).
*   **For `CLC_TFPA_FUEL` subsystem:**
    *   `<TFU_HPP>`: Fuel temperature at the high-pressure pump.
    *   `<VFF_HPP>`: Fuel flow at the high-pressure pump.
    *   `<TFPA_H>`: Fuel pressure actuator housing temperature.
*   **Feedback/Reference Input:**
    *   `[clc_tfpa_dif]`: A calculated or commanded temperature difference (likely a feedback term for a control loop).

### Outputs
*   `<TFPA_DIF>`: The final calculated fuel pressure actuator temperature difference.

### Logic Flow
1.  **Subsystem Calculations:**
    *   The `CLC_TFPA_EL` subsystem (X.2.1.1) takes `<LV_VAR_HPP>`, `<STATE_VCV>`, and `<N_32>` as inputs to calculate `<TFPA_EL>` (electric coil heating effect on TFPA temperature).
    *   The `CLC_TFPA_ENG` subsystem (X.2.1.2) takes `<TIA>`, `<TCO>`, `<VS>`, and `<TFPA_H>` as inputs to calculate `<TFPA_ENG>` (engine-related effects on TFPA temperature).
    *   The `CLC_TFPA_FUEL` subsystem (X.2.1.3) takes `<TFU_HPP>`, `<VFF_HPP>`, and `<TFPA_H>` as inputs to calculate `<TFPA_FUEL>` (fuel-related effects on TFPA temperature).
2.  **Summation of Temperature Effects:** The three calculated temperatures, `<TFPA_EL>`, `<TFPA_ENG>`, and `<TFPA_FUEL>`, are summed together using two cascaded "Add" blocks (V.7.2). This results in a total predicted or estimated TFPA temperature effect from these sources.
3.  **Difference Calculation:** The sum from step 2 is then combined with `[clc_tfpa_dif]` in another "Add" block (V.7.2), which appears to be configured to subtract `[clc_tfpa_dif]` from the sum. This calculates the difference between the aggregated temperature effects and the `[clc_tfpa_dif]` value.
4.  **Final Output:** The result of this difference calculation is output as `<TFPA_DIF>`. This `TFPA_DIF` likely represents an error signal or a deviation from a target `clc_tfpa_dif`, used in a larger control strategy.

---

## Analysis of Figure 43.17.4

### Function
This diagram's primary function is to calculate the `TFPA_EL` (Temperature difference for electric coil heating) value, which represents the temperature contribution from the electric coil heating of the fuel pressure actuator. It incorporates conditional logic to set this value to zero under specific operating conditions, particularly "shut off" states. This diagram details the internal logic of the `CLC_TFPA_EL` subsystem seen in Figure 43.17.3.

### Inputs
*   `<STATE_VCV>`: State of the VCV (Volume Control Valve).
*   `<LV_VAR_HPP>`: Low-pressure variable of the high-pressure pump.
*   `<N_32>`: Engine speed.

### Outputs
*   `<TFPA_EL>`: Temperature difference for electric coil heating.

### Logic Flow
1.  **Lookup Table for N_32:** The engine speed `<N_32>` is fed into a 1D lookup table (`IP_N_32_x_val`, V.7.3) to determine an `x_val`.
2.  **Lookup Table for LV_VAR_HPP:** The low-pressure variable `<LV_VAR_HPP>` is fed into another 1D lookup table (`IP_LV_VAR_HPP_IP_val`, V.7.3) to determine an `IP_val`.
3.  **2D Lookup Table Calculation:** The `x_val` and `IP_val` are then used as inputs to a 2D lookup table (`IP_TFPA_EL_RATIO`, V.7.3) to compute a base `IP_TFPA_EL_RATIO`. This ratio likely represents a core temperature difference calculation based on engine speed and pump state.
4.  **Conditional Check for `VCV_OPEN` State:**
    *   `<STATE_VCV>` is compared for equality with `VCV_OPEN` (Equality block V.6.2).
    *   The result of this comparison feeds into the control port of a "Switch" block (V.6.6, labeled "Check ~= 0").
    *   If `STATE_VCV == VCV_OPEN` (i.e., the check condition `~= 0` is true), the switch selects a constant value of `0` (Constant block V.6.4).
    *   If `STATE_VCV != VCV_OPEN`, the switch passes through the output of the next conditional check.
5.  **Conditional Check for `MFP_MAX` State:**
    *   `<STATE_VCV>` is compared for equality with `MFP_MAX` (Equality block V.6.2).
    *   The result feeds into the control port of a second "Switch" block (V.6.6, labeled "Check ~= 0").
    *   If `STATE_VCV == MFP_MAX` (i.e., the check condition `~= 0` is true), this switch selects a constant value of `0` (Constant block V.6.4).
    *   If `STATE_VCV != MFP_MAX`, this switch selects the `IP_TFPA_EL_RATIO` calculated in step 3.
6.  **Final Output `TFPA_EL`:** The output of the top-level switch (from step 4) is assigned to `<TFPA_EL>`. This means `TFPA_EL` will be `0` if `STATE_VCV` is either `VCV_OPEN` or `MFP_MAX`, otherwise, it will be the calculated `IP_TFPA_EL_RATIO`. This logic aligns with the description that the temperature difference is set to zero in case of "current feed shut off".


--- Page 282 ---

This page contains two Simulink-like diagrams (Figure 43.17.5 and Figure 43.17.6) which are used for calculating temperature differences within a fuel supply system.

## Function

The primary function of these diagrams, in the context of "FUSL, Fuel supply system temperatures," is to calculate specific temperature differences contributing to the overall fuel temperature model, particularly around a high-pressure fuel actuator (`<TFPA_H>`).

1.  **Figure 43.17.5:** Calculates the temperature difference impacting the fuel actuator due to **engine heat dissipation**. This includes heat transfer from ambient airflow and from the engine block.
2.  **Figure 43.17.6:** Calculates the temperature difference impacting the fuel actuator due to **fuel heat dissipation** as fuel flows through the high-pressure pump.

These calculated temperature differences (outputs `<TFPA_ENG>` and `<TFPA_FUEL>`) would likely be combined elsewhere in the system to determine the final fuel temperature or a correction factor for it.

## Inputs

**For Figure 43.17.5 (Engine Heat Dissipation):**
*   **`<TIA>`**: Ambient temperature.
*   **`<TFPA_H>`**: High-pressure actuator temperature.
*   **`<VS>`**: Engine speed.
*   **`<TCO>`**: Coolant water temperature (representing engine block temperature).

**For Figure 43.17.6 (Fuel Heat Dissipation):**
*   **`<TFU_HPP>`**: Fuel temperature at the high-pressure pump.
*   **`<TFPA_H>`**: High-pressure actuator temperature.
*   **`<VFF_HPP>`**: Volume fuel flow through the high-pressure pump.

## Outputs

**From Figure 43.17.5 (Engine Heat Dissipation):**
*   **`<TFPA_ENG>`**: Total temperature difference caused by engine heat dissipation (combining airflow and engine block heat effects) at the fuel pressure actuator.

**From Figure 43.17.6 (Fuel Heat Dissipation):**
*   **`<TFPA_FUEL>`**: Temperature difference caused by fuel heat dissipation (from fuel flow through the high-pressure pump) at the fuel pressure actuator.

## Logic Flow

The logical flow for each diagram is as follows:

### Figure 43.17.5: Calculation of temperature difference from engine heat dissipation

This diagram calculates two components of engine heat dissipation and then sums them up:

1.  **Airflow-dependent temperature difference (Upper path):**
    *   The difference between ambient temperature (`<TIA>`) and the high-pressure actuator temperature (`<TFPA_H>`) is calculated using a "Sum" block (performing `<TIA> - <TFPA_H>`). This result serves as the `x_val` input to a 2D look-up table.
    *   Engine speed (`<VS>`) serves as the `y_val` input to the same 2D look-up table.
    *   The "IP_TFPA_ENG_AIR" 2D look-up table uses these `x_val` and `y_val` inputs to determine an output `IP_val`, representing the temperature difference contribution due to airflow.

2.  **Engine block heat-dependent temperature difference (Lower path):**
    *   The difference between coolant water temperature (`<TCO>`, representing engine block temperature) and the high-pressure actuator temperature (`<TFPA_H>`) is calculated using a "Sum" block (performing `<TCO> - <TFPA_H>`). This result serves as the `x_val` input to a second 2D look-up table.
    *   Engine speed (`<VS>`) also serves as the `y_val` input to this second 2D look-up table.
    *   The "IP_TFPA_ENG_HEAT" 2D look-up table uses these `x_val` and `y_val` inputs to determine an output `IP_val`, representing the temperature difference contribution due to engine block heat.

3.  **Total Engine Heat Dissipation Temperature Difference:**
    *   The two `IP_val` outputs from the "IP_TFPA_ENG_AIR" and "IP_TFPA_ENG_HEAT" look-up tables are added together by a final "Sum" block.
    *   The sum represents the total temperature difference from engine heat dissipation, which is output as `<TFPA_ENG>`.

### Figure 43.17.6: Calculation of temperature difference from fuel heat dissipation

This diagram calculates the temperature difference caused by fuel flow through the high-pressure pump:

1.  **Temperature Difference Calculation:**
    *   The difference between the fuel temperature at the high-pressure pump (`<TFU_HPP>`) and the high-pressure actuator temperature (`<TFPA_H>`) is calculated using a "Sum" block (performing `<TFU_HPP> - <TFPA_H>`). This result serves as the `x_val` input to a 2D look-up table.

2.  **Fuel Flow Parameter:**
    *   The volume fuel flow through the high-pressure pump (`<VFF_HPP>`) serves as the `y_val` input to the same 2D look-up table.

3.  **Fuel Heat Dissipation Look-up:**
    *   The "IP_TFPA_FUEL" 2D look-up table uses the calculated temperature difference (`x_val`) and the fuel flow (`y_val`) to determine an output `IP_val`.

4.  **Output:**
    *   The `IP_val` from the "IP_TFPA_FUEL" look-up table is directly passed as the output `<TFPA_FUEL>`, representing the temperature difference from fuel heat dissipation.


--- Page 292 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, titled "FUSL, Fuel pump low pressure control coordination", primarily functions to orchestrate the control logic for an automotive low-pressure fuel pump. It integrates a wide array of vehicle system states and conditions, manages periodic operational tasks, handles non-volatile memory interactions, and generates coordinated output signals to control or reflect the status of the fuel pump system. It acts as a central coordination unit for various inputs impacting fuel pump operation, ensuring proper activation, deactivation, and fault management.

## Inputs

The system receives a comprehensive set of inputs, categorized as follows:

**1. System Status and Vehicle Conditions (Left-most column, 57 signals):**
These signals provide information on various vehicle subsystems and operating conditions, many of which are boolean flags (indicated by 'B_'):
*   **Brake System:** BKS_SY, E_erdbksy, E_edbks, E_ebks, B_tmbkser, dmkrhdev_w
*   **Engine/Motor/Hybrid Status:** SY_STASTO, SY_HEV, B_stendz, B_nmot, nmot_w, vdaavst_w, dmkrhdef_w, B_msvkma, ubsq
*   **Power Supply/Ignition:** B_kl15
*   **Safety Systems:** B_airbag, B_sa
*   **Fuel Pump Specific:** pbksaw_w, ptbksoilmod_w, pu_w, B_tfstok, AuxHtg_bFIPmpReq, pbksadr_w, pksbksr_w, tktm, B_ekp, prist_w, pbkist_w, B_tal, tmst, B_rqtbks, arqtbks_w, B_wuc, Dspl_bDrvOprn, dmkrmpi_w
*   **General Vehicle/Driver:** tfst, B_hdnd, prsolind_w, SY_SGANZ, prdiff_w, prsol_cw, vrhdr_w, B_wbkse, B_gsch, B_sabte, tnse_w
*   **Vehicle Configuration/Sensors:** LV_VAR_4WD, top_w, Dspl_bHoodOprnNoDeb, B_hoodopnok

**2. Function Call Triggers (to `fc_InI` block):**
These signals are typically discrete events or function calls that initiate specific system actions:
*   fc_RST (Reset)
*   fc_IGKON (Ignition On)
*   fc_IGKOFF (Ignition Off)
*   fc_NVMini (Non-Volatile Memory Initialization)
*   fc_NVMRES (Non-Volatile Memory Restore)
*   fc_NVMSTO (Non-Volatile Memory Store)
*   fc_CLRFMY (Clear Failure Memory)

## Outputs

The system generates a set of output signals, primarily from the "Signal Manager" block and the Non-Volatile Memory (NVM) management blocks.

**1. Coordinated Control/Status Signals (from Signal Manager, 26 signals):**
These outputs reflect the determined state or required control action for the fuel pump system:
*   anzhrdynaw, B_aekptk, B_dhbks, B_edbks, B_ebks, B_efahr, B_ekpdh, B_ekpooksa, B_ekponbks, B_ekpshg, B_erdbksy, B_pddiswuc, B_pdekp, B_sshev, B_switchbks, flafrbks_w, ktflafrin_w, lepwmbks_w, pbksinp_w, PspCil_stFIPmpAct, B_bksspa, B_flafobks, B_hrdynaw, B_pbksprof, tpdbks_w, LV_EFP_WKU

**2. Non-Volatile Memory Status/Control:**
*   NVMY_INI (Status of NVM initialization)
*   NVMY_STO (Status of NVM store operation)
*   NVMY_RES (Status of NVM restore operation)
*   CLRFMY (Status of clear failure memory operation)

**3. Operational Management Signals:**
*   OPM_20MS (Output from 20ms periodic task, likely a status or processed signal)
*   OPM_100MS (Output from 100ms periodic task, likely a status or processed signal)

## Logic Flow

The logical flow of this system can be broken down into several interconnected areas:

1.  **Initialization and Function Calls (Top Left):**
    *   The `fc_InI` block receives function call signals such as `fc_RST` (reset), `fc_IGKON` (ignition on), `fc_IGKOFF` (ignition off), and various Non-Volatile Memory (NVM) related triggers (`fc_NVMini`, `fc_NVMRES`, `fc_NVMSTO`, `fc_CLRFMY`).
    *   The output of `fc_InI` (labeled `INI`, block X.1) triggers the NVM handling subsystems.

2.  **Non-Volatile Memory (NVM) Management (Top Middle):**
    *   `NVMY_INI` (X.2), `NVMY_STO` (X.4), `NVMY_RES` (X.3), and `CLRFMY` (X.5) are function-call subsystems.
    *   `NVMY_INI` is likely activated during system initialization to load previously stored data.
    *   `NVMY_STO` saves critical parameters to non-volatile memory, often triggered by `fc_NVMSTO` or system shutdown conditions.
    *   `NVMY_RES` restores parameters from NVM, typically during startup, triggered by `fc_NVMRES`.
    *   `CLRFMY` clears fault memory, triggered by `fc_CLRFMY`.
    *   The interconnections between these blocks (`CLRFMY` output to inputs of `NVMY_STO` and `NVMY_RES`) suggest a coordinated sequence of NVM operations or status dependencies.

3.  **Periodic Operational Management (Bottom Middle):**
    *   `OPM_100MS` (X.6) and `OPM_20MS` (X.7) are function-call subsystems responsible for executing tasks at specific recurrence rates (100 milliseconds and 20 milliseconds, respectively).
    *   `OPM_100MS` likely performs less frequent, background tasks or state updates.
    *   `OPM_20MS` likely handles more time-critical control logic.
    *   The output `Out_OPM_100MS` feeds into `In_OPM_20MS`, indicating a hierarchical or sequential data flow where the 100ms task may set up conditions or provide processed data for the 20ms task. These blocks serve as timers and schedulers for the main control logic.

4.  **Signal Management and Core Logic (Central "Signal Manager" Block):**
    *   The "Signal Manager" block (V.6.5) is the core processing unit. It receives all 57 raw input signals from the left side of the diagram.
    *   Internally, this block implements the complex logic for fuel pump low-pressure control coordination. This likely involves:
        *   **Input Processing:** Filtering, debouncing, and conversion of raw input signals.
        *   **Condition Evaluation:** Determining the current operating mode or state of the fuel pump based on the combination of vehicle inputs (e.g., ignition status, engine running, safety interlocks, driver requests, fault conditions).
        *   **Control State Determination:** Based on the evaluated conditions, it decides the desired state or action for the fuel pump (e.g., run, stop, prime, fault-off).
        *   **Output Generation:** Producing a set of 26 coherent output signals that represent the coordinated control commands and status information to other vehicle systems.
    *   The explicit "Recurrence" settings (20MS, 100MS always) imply that the logic within the Signal Manager is executed periodically, synchronized with the `OPM_20MS` and `OPM_100MS` tasks.

In summary, the system initializes, manages non-volatile data, and then continuously processes a vast array of vehicle inputs through a central "Signal Manager" block, operating at specific time intervals to output coordinated control signals for the low-pressure fuel pump, ensuring its safe and efficient operation under diverse vehicle conditions.


--- Page 293 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, labeled "43.18.1 Initialization," represents an initialization subsystem (`INI`) within a larger "Fuel pump low pressure control coordination" (FUSL) system. Its primary function is to process various system reset, ignition (on/off), and critical vehicle state signals to determine and output an initialized state for the fuel pump control, including a specific wake-up signal for the low-voltage electric fuel pump and an overall initialization status.

## Inputs
The subsystem receives the following input signals:

*   **`INI` (Port 1)**: The primary input port representing the start or trigger for this initialization subsystem.
*   **`<fc_RST>`**: Fuel Control Reset signal.
*   **`<fc_IGKON>`**: Fuel Control Ignition On signal.
*   **`<fc_IGKOFF>`**: Fuel Control Ignition Off signal.
*   **`<BKS_SY>`**: Brake System Status.
*   **`<SY_STASTO>`**: Start-Stop System Status.
*   **`<SY_HEV>`**: Hybrid Electric Vehicle System Status.
*   **`<B_airbag>`**: Airbag Deployment Status (boolean).
*   **`<top_w>`**: Convertible Top Status (e.g., indicating roof position).
*   **`<B_hoodopnok>`**: Hood Open Status (boolean).
*   **`Dspl_bHoodOpnNoDeb`**: Debounced Hood Open Status, likely intended for display or less critical logic.
*   **`In` (Port 2)**: An unlabeled input port connected to a signal bus that feeds into the main logic block.

## Outputs
The subsystem generates the following output signals:

*   **`LV_EFP_WKU`**: Low Voltage Electric Fuel Pump Wake-Up signal.
*   **`Out` (Port 1)**: The primary output port of this initialization subsystem, representing the computed overall initialized state or a key control signal derived from the core initialization logic.

## Logic Flow

The logical flow within the "43.18.1 Initialization" subsystem proceeds as follows:

1.  **Reset and Ignition Signal Processing for Wake-Up:**
    *   The `INI` input and the `<fc_RST>` signal are directed into a `V.6.1` block (likely a selector or a specific version of a logic block).
    *   Separately, `<fc_IGKON>` and `<fc_IGKOFF>` signals, along with an input from the internal bus, are processed through a `V.6.4` block.
    *   Another `<fc_RST>` signal is also fed into a different `V.6.4` block.
    *   The outputs from these `V.6.4` blocks are then combined by a `Merge` block.
    *   The final output of this `Merge` block is the `LV_EFP_WKU` signal, indicating that the Electric Fuel Pump Wake-Up signal is generated based on a combination of reset and ignition state conditions, potentially incorporating version-specific logic (`V.6.1`, `V.6.4`).

2.  **Collection of Vehicle State Inputs:**
    *   Multiple vehicle state signals crucial for safe and proper fuel system operation are gathered: `<BKS_SY>` (Brake System), `<SY_STASTO>` (Start-Stop System), `<SY_HEV>` (Hybrid Electric Vehicle System), `<B_airbag>` (Airbag Status), `<top_w>` (Convertible Top Status), `<B_hoodopnok>` (Hood Open Status), and `Dspl_bHoodOpnNoDeb` (Debounced Hood Open Status).
    *   These signals are aggregated onto a signal bus before being fed into the main logic block.

3.  **Core Initialization Logic Subsystem:**
    *   The aggregated vehicle state signals, along with internal control signals (implied by the `fc()` label and connections from the upper processing path, including the `<fc_RST>` and `<fc_IGKON>` variants), are directed as inputs into the central green subsystem block named "RST_and_IGKON X.1.1".
    *   This "RST_and_IGKON X.1.1" block encapsulates the core complex logic responsible for evaluating all incoming reset, ignition, and vehicle state conditions. It determines the necessary internal states, parameters, or control commands required for the fuel pump system to properly initialize.

4.  **Overall Subsystem Output Generation:**
    *   The main output from the "RST_and_IGKON X.1.1" subsystem is then processed through another `V.6.1` block.
    *   The final output of this `V.6.1` block becomes the primary `Out` (Port 1) for the entire "43.18.1 Initialization" subsystem. This `Out` signal likely represents the overall readiness, status, or a key control value resulting from the comprehensive initialization logic.


--- Page 294 ---

This page contains a Simulink diagram representing a control logic module.

## Function
This Simulink diagram, titled "43.18.1.1 Reset and Ignition ON" and associated with "FUSL, Fuel pump low pressure control coordination," primarily defines conditions for enabling or coordinating low-pressure fuel pump operation and related ignition/reset states. It integrates various safety checks (e.g., hood status, airbag deployment) and product feature configurations to determine specific operational signals.

## Inputs
The system receives a wide array of inputs, predominantly status flags and control signals:

*   **Boolean Status Flags (many prefixed `B_`):**
    *   `B_efahr`, `B_erdbksy`, `B_ebks`, `anzhrdynaw`, `B_aekptk`, `B_dhbks`
    *   `B_ekpdh`, `B_ekponbks`
    *   `B_nll`, `B_tgsabks`, `B_ekposfr`, `B_flafobks`, `B_edbks`
    *   `B_ekpshg`, `B_pdekp`
    *   `B_airbag`: Airbag deployment status.
    *   `B_hoodopnok`: Hood open/not OK status.
    *   `B_switchbks`, `B_sshev`: Inputs to dedicated sub-blocks for switch and HEV (Hybrid Electric Vehicle) states.
    *   `zzgbkse_init`, `tstartekp_init`: Initialization flags.
*   **Control Words/Signals:**
    *   `flafbks_w`, `kfflafin_w`, `pbksinp_w`
    *   `lepwm_w`: Low-pressure fuel pump PWM/state (also an output).
    *   `PspCil_stFlPmpAct`: Fuel pump active state (appears as both an input and the primary output).
*   **Feature Flags:**
    *   `NLC_EFP_PROD_FEAT_ON`: A product feature enablement flag.
*   **Multi-bit Signals:**
    *   `TEONEKPENA`: Used for bit extraction.
*   **System Inputs (for sub-blocks):**
    *   `SY_BKS_SY`, `SY_STASTO`, `SY_HEV`

## Outputs
The diagram explicitly defines several outputs:

*   **PspCil_stFlPmpAct (Out 1):** The primary output, indicating the calculated or passed-through status/command for the fuel pump low pressure system.
*   **B_ekpoksa:** A boolean output whose value depends on the `NLC_EFP_PROD_FEAT_ON` feature flag.
*   **lepwm_w:** A signal potentially representing a Pulse Width Modulation (PWM) value, derived from conditional logic.
*   **B_switchbks:** Output from the "Switchbks" subsystem.
*   **B_sshev:** Output from the "sshev" subsystem.

Many of the input `B_` signals on the left also appear as unlabeled outputs on the right, suggesting they are either directly passed through the subsystem or are made available as local variables for other parts of the system.

## Logic Flow

The logical flow can be broken down into several parallel and interconnected paths:

1.  **Direct Signal Pass-Through:** A large number of boolean (`B_`) and word-level inputs on the left side (e.g., `B_efahr`, `B_erdbksy`, `flafbks_w`) are shown directly connected to output-like representations on the right, implying they are either passed through this specific subsystem without modification or are made available for other components.

2.  **Fuel Pump Active State (`PspCil_stFlPmpAct`):**
    *   The input `PspCil_stFlPmpAct` is directly routed to an output block labeled `Out 1`, which itself outputs `PspCil_stFlPmpAct`. This indicates that within the scope of this particular diagram, the fuel pump active state is passed through. The actual logic determining its value might reside in an upstream or parallel subsystem, and this block is responsible for making that final state available.

3.  **Fuel Pump PWM/State Calculation (`lepwm_w`):**
    *   A significant portion of the logic determines the `lepwm_w` signal, which is consolidated by a `Merge` block.
    *   **Conditional Selection based on `NLC_EFP_PROD_FEAT_ON`:** An `IF` block evaluates the state of `NLC_EFP_PROD_FEAT_ON`.
        *   If `NLC_EFP_PROD_FEAT_ON` is active (true), the signal `PWMINBKS` is selected.
        *   If `NLC_EFP_PROD_FEAT_ON` is inactive (false), the signal `TVOBKS` is selected.
    *   The output of this conditional selection feeds into the `Merge` block for `lepwm_w`. The other input to this `Merge` block is not explicitly shown but originates from an unspecified upstream connection.

4.  **Safety and Activation Conditions (Hood, Airbag, Engine Runtime):**
    *   **Engine Runtime Check:** A block labeled "Total engine runtime activation condition" processes inputs to determine an activation status.
    *   **Hood Status Check:** The `TEONEKPENA` signal undergoes bit extraction using a "GET BIT" block. The extracted bit, along with `Dspl_bHoodOpnNoDeb` and `B_hoodopnok`, feeds into an `AND` gate to form a combined hood status check (`Check`). A switch block then evaluates if `Check` is non-zero (`Check ~= 0`). This entire path likely determines if the hood is in a safe/closed state.
    *   **Airbag Status:** The `B_airbag` signal is compared using a `<` operator, likely checking if the airbag status is below a certain threshold (e.g., not deployed or OK).
    *   **Combined Safety Condition:** The output of the "hood status check" (`Check ~= 0`) and the "airbag status" condition (`B_airbag < constant`) are combined using an `OR` gate. This gate's output feeds into the "Total engine runtime activation condition" or another part of the logic, suggesting a critical safety interlock.

5.  **Conditional Output `B_ekpoksa`:**
    *   Another `IF` block evaluates `NLC_EFP_PROD_FEAT_ON`.
    *   If `NLC_EFP_PROD_FEAT_ON` is active, the comment "At NLC_EFP_PROD_FEAT_ON==1, the variable B_ekpoksa will not be produced" indicates that `B_ekpoksa` is set to a default/inactive state (shown as `0`).
    *   If `NLC_EFP_PROD_FEAT_ON` is inactive, the input `B_ekpoksa` is passed through.

6.  **Subsystem Processing (Switchbks, sshev):**
    *   Inputs `B_switchbks` and `B_sshev`, along with system-level signals (`SY_BKS_SY`, `SY_STASTO`, `SY_HEV`), are processed by dedicated subsystems named "Switchbks" and "sshev." These subsystems produce corresponding outputs `B_switchbks` and `B_sshev`, likely representing refined or processed states related to vehicle switches and hybrid-electric vehicle functionalities.


--- Page 295 ---

This page contains two Simulink diagram snippets.

## Function

These Simulink diagrams represent logical conditions and bit-wise operations related to automotive system states, likely within the context of "Fuel pump low pressure control coordination" (as indicated by "FUSL" in the title).

**Figure 43.18.4 (Top Diagram):** This sub-system determines a boolean output `B_switchbks` based on a specific bit from `CWBKS4` and two comparison conditions involving `BKS_SY`. It effectively acts as a conditional logic selector.

**Figure 43.18.5 (Bottom Diagram):** This sub-system determines a boolean output `B_sshev` based on whether either `SY_STASTO` or `SY_HEV` (or both) are active (i.e., greater than zero).

## Inputs

**For Figure 43.18.4:**
*   **CWBKS4:** A numerical or bit-packed input signal (likely an integer representing a status word).
*   **BKS_SY:** A numerical input signal, likely representing a system status or value related to a brake or general system.

**For Figure 43.18.5:**
*   **SY_STASTO:** A numerical input signal, likely indicating the status of a Start/Stop system or similar functionality.
*   **SY_HEV:** A numerical input signal, likely indicating the status of a Hybrid Electric Vehicle (HEV) system or a related component.

## Outputs

**For Figure 43.18.4:**
*   **B_switchbks:** A boolean output signal (0 or 1), indicating a specific switch or system condition.

**For Figure 43.18.5:**
*   **B_sshev:** A boolean output signal (0 or 1), indicating the combined status of Start/Stop and HEV systems.

## Logic Flow

**For Figure 43.18.4 (Path: FUSL_M908U/INI/Switchbks):**

1.  **Extract Bit from CWBKS4:** The `GET BIT` block extracts the bit at index `0` (as indicated by the constant `0` connected to `bit_sel`) from the input signal `CWBKS4`. The result, `bits`, is a boolean (0 or 1).
2.  **Compare BKS_SY (Greater Than):** The input `BKS_SY` is compared to the constant `1` using a 'greater than' (`>`) operator. This produces a boolean result (`true` if `BKS_SY > 1`, `false` otherwise).
3.  **Compare BKS_SY (Equal To):** The input `BKS_SY` is compared to the constant `1` using an 'equal to' (`=`) operator. This produces a boolean result (`true` if `BKS_SY == 1`, `false` otherwise).
4.  **Conditional Selection (Switch Logic):** A switch block selects one of the two comparison results from steps 2 and 3. The `bits` signal extracted from `CWBKS4` (from step 1) acts as the control input for this switch.
    *   If `bits` is `1` (i.e., `bits > 0`, assuming a standard Simulink Switch block with threshold 0), the output of the `BKS_SY > 1` comparison (from step 2) is passed through.
    *   If `bits` is `0` (i.e., `bits <= 0`), the output of the `BKS_SY == 1` comparison (from step 3) is passed through.
5.  **Output Assignment:** The selected boolean result from the switch is assigned to the output `B_switchbks`.

**For Figure 43.18.5 (Path: FUSL_M908U/INI/sshev):**

1.  **SY_STASTO Condition Check:** The input `SY_STASTO` is compared to the constant `0` using a 'greater than' (`>`) operator. This produces a boolean output (`true` if `SY_STASTO > 0`, `false` otherwise).
2.  **SY_HEV Condition Check:** The input `SY_HEV` is compared to the constant `0` using a 'greater than' (`>`) operator. This produces a boolean output (`true` if `SY_HEV > 0`, `false` otherwise).
3.  **Logical OR Operation:** The boolean results from both condition checks (steps 1 and 2) are fed into a logical `OR` gate. The output of the `OR` gate is `true` (1) if either `SY_STASTO > 0` or `SY_HEV > 0` (or both) are true. Otherwise, the output is `false` (0).
4.  **Output Assignment:** The boolean result from the `OR` gate is assigned to the output `B_sshev`.


--- Page 296 ---

This page contains three Simulink diagram snippets, not a single large diagram.

## Function

The primary function of these Simulink diagrams is to manage the lifecycle (initialization, restoration/reading, and storage) of a single non-volatile memory (NVM) variable named `B_pddiswuc`. This variable is likely a boolean flag or a single-bit value (indicated by `size: 1`) critical for the "Fuel pump low pressure control coordination" (FUSL) system in an automotive context. These operations ensure the persistence of this critical variable across power cycles.

## Inputs

*   **43.18.2 NVMY_INI (Initialization):** No explicit input signals are shown for this subsystem. It operates by reading from NVM or using a default initialization.
*   **43.18.3 NVMY_RES (Restoration):** No explicit input signals are shown for this subsystem. It operates by reading from NVM or using a fallback value.
*   **43.18.4 NVMY_STO (Storage):**
    *   `In (1)`: An input signal carrying the value to be stored into NVM, explicitly labeled `<B_pddiswuc>`.

## Outputs

*   **43.18.2 NVMY_INI (Initialization):**
    *   `Out (1)`: The initialized or read value of `B_pddiswuc`.
*   **43.18.3 NVMY_RES (Restoration):**
    *   `Out (1)`: The restored or read value of `B_pddiswuc`.
*   **43.18.4 NVMY_STO (Storage):**
    *   The `NVMY[store]` block has an `out` port, but it is not connected to a subsystem output `Out (1)`. This output likely represents an internal status of the NVM write operation or is consumed internally within the broader function `f()`.

## Logic Flow

The diagrams represent three distinct function-call triggered subsystems (indicated by the `f()` symbol in the top-right corner of each frame), which are executed at specific points in the system's operation:

1.  **43.18.2 NVMY_INI (Initialization):**
    *   This subsystem is invoked, typically during the very first system startup or when the NVM variable needs to be explicitly initialized.
    *   The `NVMY[read/init]` block attempts to read the `B_pddiswuc` variable from non-volatile memory.
    *   If the read is successful, the stored value is retrieved.
    *   If the read fails (e.g., NVM is empty or corrupted, first-time boot), the variable `B_pddiswuc` is initialized to its specified default value of `0` (`init:0`).
    *   The resulting value (either read or initialized) is then passed through a buffer/gain block (V.6.1) and presented as the subsystem's output `Out (1)`.

2.  **43.18.3 NVMY_RES (Restoration/Resume):**
    *   This subsystem is invoked, likely during subsequent system startups or after a power-down event, to restore the last known persistent state of the variable.
    *   The `NVMY[read/init]` block attempts to read the `B_pddiswuc` variable from non-volatile memory.
    *   If the read is successful, the stored value is retrieved.
    *   If the read fails, the variable `B_pddiswuc` is initialized/set to the *current* volatile value of `B_pddiswuc` (`init:B_pddiswuc`), implying a fallback to the most recently used value in RAM if the NVM read operation is unsuccessful. This differs from `NVMY_INI` which uses a fixed `0` on failure.
    *   The resulting value (either read or restored) is then passed through a buffer/gain block (V.6.1) and presented as the subsystem's output `Out (1)`.

3.  **43.18.4 NVMY_STO (Storage):**
    *   This subsystem is invoked whenever the current volatile value of `B_pddiswuc` needs to be persistently saved to non-volatile memory.
    *   The `In (1)` port receives the current value of `B_pddiswuc` that is to be stored.
    *   This input value is fed into the `NVMY[store]` block.
    *   The `NVMY[store]` block performs the write operation, saving the received value of `B_pddiswuc` into non-volatile memory.
    *   The `out` port of the `NVMY[store]` block may provide status information about the write operation (e.g., success/failure), which is then handled within the broader context of this function-call subsystem.


--- Page 297 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram, labeled "CLRFMY" and associated with "FUSL, Fuel pump low pressure control coordination," implements a conditional logic flow with a feedback mechanism. Its primary function appears to be to process an input signal, apply specific conditional logic based on a "production feature" enablement and an internal state or condition, and produce a coordinated output for fuel pump low pressure control. The module's operation is state-dependent due to the feedback loop.

## Inputs

*   **In (Port 1):** The main input signal to the subsystem, representing a value or status requiring processing.
*   **NLC_EFP_PROD_FEAT_ON (V.6.4):** A boolean signal or flag that acts as a condition for the initial If-Else logic. It likely stands for "No-load Control, Electric Fuel Pump Production Feature On," indicating whether a specific production feature for the electric fuel pump is active.
*   **<feedback>:** An internal feedback signal derived from a previous iteration or state of the system, influencing the current processing.

## Outputs

*   **Out (Port 1):** The primary output signal of the subsystem, labeled `B_ekpoksa`, which likely represents a coordinated control value or status for the fuel pump low pressure system.
*   **Terminator:** The output of the `#if` branch of the first If-Else block goes to a Terminator block. This implies that when `NLC_EFP_PROD_FEAT_ON` is TRUE, the signal path through this particular branch is explicitly not used or is discarded within this subsystem's scope.
*   **<feedback>:** While also an input, it's an internal output of a multiplexer/switch block that is then fed back.
*   **<B_switchbks>:** An intermediate signal representing the output of the first feedback and selection stage.
*   **B_ekpoksa (to Out):** The final intermediate signal before being output as `Out`.

## Logic Flow

The logical flow of the diagram can be broken down into the following steps:

1.  **Initial Input Reception:** The module receives an input signal at the 'In' port.

2.  **Production Feature Evaluation (If-Else Subsystem):**
    *   The `NLC_EFP_PROD_FEAT_ON` signal is evaluated as the condition for an If-Else Subsystem (the blue block with `#if` and `#else`).
    *   **If `NLC_EFP_PROD_FEAT_ON` is TRUE (the `#if` branch):** The control signal is routed to a Terminator block. This implies that when the Electric Fuel Pump Production Feature is ON, this particular module's processing path leading to the primary output is disabled or ignored.
    *   **If `NLC_EFP_PROD_FEAT_ON` is FALSE (the `#else` branch):** The control signal (derived from `In`, potentially經過some implicit processing through the If-Else block) proceeds to the next stage of logic. This means the module is active and processes its input when the production feature is OFF.

3.  **Feedback and Input Selection (First Multiplexer-like Block):**
    *   The signal from the `#else` branch, along with a `<feedback>` signal (which is a delayed or previous output of this same block), enters a multiplexer-like block (the vertical bar).
    *   This block typically selects between its inputs based on an implicit or explicit condition (not shown, but common for feedback loops to select between current input and previous state).
    *   The output of this selection is named `<B_switchbks>`, indicating a switched or conditioned signal that might represent the current state or relevant input for the next stage, incorporating historical data via feedback.

4.  **Second Conditional Logic (`cond_if` Subsystem):**
    *   The `<B_switchbks>` signal then enters another conditional subsystem named `cond_if` (V.6.0). This block evaluates an internal condition.
    *   **If the `cond_if` condition is TRUE (the `if` branch):** The signal is routed to a block labeled '0' (V.6.4). This '0' block could represent setting the value to zero, or applying a specific transformation that results in a default value.
    *   **If the `cond_if` condition is FALSE (implicitly, the `else` or direct path):** The `<B_switchbks>` signal is passed directly (or through a different internal path) to the next selection stage without passing through the '0' block.

5.  **Final Signal Selection and Output Generation:**
    *   The two potential signal paths from the `cond_if` block (either from the '0' block or the direct path) converge into another multiplexer-like block.
    *   This final selection or merge block produces the signal `B_ekpoksa`.
    *   The `B_ekpoksa` signal is then routed to the 'Out' port, which is the final output of the `CLRFMY` subsystem.


--- Page 298 ---

This page contains a Simulink diagram.

## Function

The primary function of this Simulink diagram, titled "FUSL, Fuel pump low pressure control coordination" and named "OPM_100MS", is to manage and coordinate the operational states and control of the low-pressure fuel pump in an automotive system. It handles pre-drive enablement conditions, incorporates diagnostic feedback, processes various system states (like ignition, wake-up, airbag status), and ultimately generates the control signal(s) for the fuel pump. The "_100MS" suffix suggests this module executes at a 100-millisecond interval.

## Inputs

The diagram takes a comprehensive set of inputs, mostly through an initial input bus that is then de-multiplexed by a `Bus Selector` block. Key inputs include:

*   **`<B_kl15>`**: Ignition status (Terminal 15).
*   **`<feedback>`**: A generic feedback signal, likely indicating the current state or status from other modules.
*   **`<E_erdbksy>`**: Enable/request signal, possibly related to diagnostic error states.
*   **`<E_edbks>`**: Another enable/request signal.
*   **`<E_ebks>`**: Another enable/request signal.
*   **`<B_tmbkser>`**: Timer or time-based request signal.
*   **`<zzgbkse_init>`**: Initialization status for a specific module or state.
*   **`EKP ausschalten`**: Direct request to disable the electric fuel pump (German for "Fuel pump disable").
*   **`CWBKS3`**: A control word or byte from which a specific bit is extracted for control.
*   **`<B_wuc>`**: Wake-Up condition.
*   **`<B_stend>`**: Stand-by or End state signal.
*   **`<B_airbag>`**: Airbag deployment status (critical safety input for fuel cut-off).
*   **`AuxHtg_bFlPmpReq`**: Request from an auxiliary heating system for fuel pump operation.
*   **`pbksadr_w`**: Password or address-related word.
*   **`Dspl_bDrvDoorOpn`**: Driver door open status (likely for display or interlock).
*   **`pkebskr_w`**: Password or request-related word.
*   **`LV_VAR_4WD`**: Low Voltage Variable for 4WD system variant.
*   **`LV_EFP_WKU`**: Low Voltage Electric Fuel Pump Wake-Up signal.
*   **`<B_pddiswuc_prev>`**: Previous state of power-down/wake-up disable.
*   **`<B_nll_prev>`**: Previous state of null/inactive mode.
*   **`<top_w>`**: A top-level status or control word.
*   **`<B_hoodopnok>`**: Hood status (Not OK, i.e., open).
*   **`Dspl_bHoodOpnNoDeb`**: Hood open status (for display, without debounce).
*   **`<B_diag_dly>`**: Diagnostic delay status.
*   **`<B_wuc_bks>`**: Wake-up condition status from a block.
*   **`<B_nll_bks>`**: Null state status from a block.

## Outputs

The diagram generates two primary outputs:

*   **`Out_OPM_100MS` (Output Port 1):** This is a bus output, consolidating several related signals into a single interface. It contains `B_pddiswuc`, `B_ekpshg`, and the unnamed main output signal from the `PRE_POST_DRIVE` subsystem.
*   **`Out` (Output Port 2):** This is a scalar output, specifically the main control signal generated by the `PRE_POST_DRIVE` subsystem. It is also part of the `Out_OPM_100MS` bus, indicating it's a key direct output.

## Logic Flow

The logical flow of the diagram can be broken down into several stages:

1.  **Input Demultiplexing:** All external inputs are initially passed through a `Bus Selector` block (`In`), which extracts individual signals required by various subsystems.

2.  **Ignition-Based Conditional Logic:**
    *   The `<B_kl15>` (Ignition Terminal 15) signal controls an `If` block (V.5.3).
    *   If ignition is ON (`if` branch), a set of signals (including `<B_switchbks>`) is routed to the `CONDPRDRVENA` and `PREDRIVE_ENABLE` subsystems.
    *   If ignition is OFF (`else` branch), potentially default or power-off values are routed instead.

3.  **Diagnostic and Error Handling (`DIAGBKS` X.6.1):**
    *   This subsystem takes inputs related to enable/request signals (`<E_erdbksy>`, `<E_edbks>`, `<E_ebks>`), timer (`<B_tmbkser>`), and initialization (`<zzgbkse_init>`).
    *   It processes these to output diagnostic-related status signals (`B_erdbksy`, `B_edbks`, `B_ebks`, `B_tmbkser`), which are then used by other parts of the system, particularly the `PRE_POST_DRIVE` logic.

4.  **Fuel Pump Disable Logic:**
    *   A bit-selection block (`GET BIT` V.7.0) extracts a specific bit from `CWBKS3` based on `EKP ausschalten` (Fuel Pump disable) and a `bit_sel` input.
    *   A `NOT` block (V.6.3) inverts this bit. The inverted signal controls a second `If` block (V.6.0). This ensures the pump is enabled only if the "disable" bit is NOT set.
    *   The output of this `If` block feeds into the `PREDRIVE_ENABLE` subsystem, providing a critical override or enable condition.

5.  **Pre-Drive Enablement Logic (`CONDPRDRVENA` V.5.4 & `PREDRIVE_ENABLE` X.6.2):**
    *   `CONDPRDRVENA` (Conditional Pre-Drive Enablement) evaluates inputs like wake-up conditions (`<B_wuc>`), stand-by status (`<B_stend>`), and feedback, alongside the output from the `B_kl15` conditional path. It determines if the fundamental conditions for pre-driving are met.
    *   `PREDRIVE_ENABLE` builds upon this, taking the outputs from `CONDPRDRVENA`, the fuel pump disable logic, and other wake-up/stand-by signals. It orchestrates the conditions necessary to enable the fuel pump during the pre-drive phase. It outputs `B_pddiswuc` (power-down/wake-up disable status) and `B_ekpshg` (electric fuel pump enable signal).

6.  **Core Fuel Pump Drive Logic (`PRE_POST_DRIVE` X.6.3):**
    *   This is the central decision-making unit for the fuel pump's operation. It receives a vast array of inputs including the diagnostic outputs (`B_edbks`), critical safety inputs (`<B_airbag>`, hood status), system state information (`<B_kl15>`, `LV_EFP_WKU`, `B_pddiswuc_prev`, `B_nll_prev`), various requests (`AuxHtg_bFlPmpReq`), and display-related signals.
    *   It processes all these inputs to determine the precise operational state and output control for the low-pressure fuel pump, covering pre-drive, actual drive, and post-drive scenarios. Its output is the main fuel pump control signal.

7.  **Output Generation:**
    *   The `BusMerge` block (V.6.0) combines the `B_pddiswuc` and `B_ekpshg` signals from `PREDRIVE_ENABLE` with the main fuel pump control signal from `PRE_POST_DRIVE`.
    *   This merged bus forms the `Out_OPM_100MS` output (Port 1).
    *   The main fuel pump control signal from `PRE_POST_DRIVE` is also directly routed to the `Out` port (Port 2), likely serving as the primary control line for the actual fuel pump actuator.


--- Page 299 ---

This page contains two Simulink diagrams related to fuel pump low-pressure control coordination.

## Diagram 1: DIAGBKS (Diagnostic Low-Pressure Sensor)

### Function
This diagram evaluates diagnostic states related to the fuel low-pressure sensor, wake-up inputs, and high-pressure system components. Its primary function is to generate error flags that inform and coordinate the fuel pump's behavior, potentially leading to controller deactivation, wake-up function deactivation, or setting the pump's delivery rate to maximum.

### Inputs
*   **E_erdbksy** (Port '2'): Low-pressure sensor electrical diagnostic error. (From the `ZZGBKSE` block, implying an input to a diagnostic function).
*   **zzgbkse_init** (Port '6'): Initialization status for the low-pressure sensor diagnostic module. (Input to `ZZGBKSE`).
*   **x_in**: Raw input signal for low-pressure sensor diagnosis. (Input to `ZZGBKSE`).
*   **TurnOffDelayTime**: Configurable time delay parameter for switching off the pump upon sensor error. (Input to `ZZGBKSE`).
*   **E_edbks** (Port '3'): Error related to a wake-up input or CAN wake-up message. (Labeled as "Wakeup-relevante Fehler").
*   **E_ebks** (Port '4'): Error related to high-pressure system components (e.g., final stage MSV, high-pressure control, final stage KPE, high-pressure sensor). (Labeled as "Hochdrucksystem Komponentenfehler").
*   **B_tmbkser** (Port '5'): Error related to a temperature sensor. (Labeled as "Fehler eines Temperatursensors").

### Outputs
*   **B_erdbksy** (Outport '1'): Boolean flag indicating a detected low-pressure sensor error. This error causes the controller to switch off, and the EKP (electric fuel pump) to run in a controlled/fallback manner.
*   **B_edbks** (Outport '2'): Boolean flag indicating a wake-up related error. This error leads to the deactivation of the wake-up function in the next pre-drive call.
*   **B_ebks** (Outport '3'): Boolean flag indicating a high-pressure system component error OR a temperature sensor error. This condition results in the EKP's delivery rate being set to maximum.

### Logic Flow
1.  **Low-Pressure Sensor Error Detection (Top Path):**
    *   The `ZZGBKSE` block (a custom diagnostic module, likely for a low-pressure sensor) receives `E_erdbksy`, `zzgbkse_init`, `x_in`, and `TurnOffDelayTime`. It outputs `y1` and a boolean switching signal `B_switchbks`.
    *   A `Switch` block uses `B_switchbks` as its control input. If `B_switchbks` is true (1), the signal `y1` from `ZZGBKSE` is passed. If `B_switchbks` is false (0), a constant `0` (false) is passed.
    *   The output of the `Switch` then passes through a `f()` (Function-Call Subsystem) block, which likely performs further processing or filtering.
    *   The final output of this path is `B_erdbksy`, indicating an active low-pressure sensor fault.
2.  **Wake-up Relevant Error Detection (Middle Path):**
    *   The input `E_edbks` (Wake-up relevant error) is directly propagated to the output `B_edbks`.
3.  **High-Pressure System / Temperature Sensor Error Detection (Bottom Path):**
    *   Inputs `E_ebks` (High-pressure system component error) and `B_tmbkser` (Temperature sensor error) are fed into an `OR` logic gate.
    *   If either `E_ebks` or `B_tmbkser` is true, the `OR` gate outputs true.
    *   This result is then directly propagated to the output `B_ebks`.

## Diagram 2: PREDRIVE_ENABLE (Pre-drive Enable)

### Function
This diagram controls the enablement of a pre-drive function and the electric fuel pump (EKP) based on the wake-up condition, engine stand/stop status, and potentially diagnostic switching signals. It manages the initial activation states for the fuel system.

### Inputs
*   **B_wuc** (Port '1'): Wake-up condition (boolean).
*   **u**: Input signal to the hysteresis block (V.5.3), likely representing a raw or pre-processed wake-up signal.
*   **B_switchbks** (Port '3'): A boolean switch signal, potentially from the `DIAGBKS` module or another diagnostic evaluation.
*   **B_stend** (Port '2'): Engine stand/stop condition (boolean).

### Outputs
*   **B_pddiswuc** (Outport '1'): Boolean flag indicating that pre-drive is disabled due to the wake-up condition or other logical paths.
*   **B_ekpshg** (Outport '2'): Boolean flag enabling the electric fuel pump.

### Logic Flow
1.  **Pre-drive Disable Logic (Top Path):**
    *   The `B_wuc` signal and `u` are fed into a Hysteresis block (V.5.3), which outputs `y`. This block likely filters or debounces the wake-up signal to prevent rapid state changes.
    *   The signal `y` then enters a `cond_if` block (V.6.0), which evaluates a specific condition based on `y`.
    *   The output of `cond_if` is routed to the data input of a `Switch` block. The control input for this `Switch` is `B_switchbks`. If `B_switchbks` is true, the output of `cond_if` is passed through. If `B_switchbks` is false, a constant `0` (false) is passed.
    *   The output of the `Switch` block then goes into a "Check ~= 0" block (V.6.6), which likely converts any non-zero input to a true boolean value and zero to false.
    *   The final output of this path is `B_pddiswuc`, indicating the pre-drive disable state.
2.  **Electric Fuel Pump Enable Logic (Bottom Path):**
    *   A constant `0` is fed into the `SET` input of an `FF` (Flip-Flop, V.5.5) block. This effectively ensures the `SET` input is inactive.
    *   The `B_stend` (engine stand/stop) signal is fed into the `RST` (Reset) input of the `FF` block.
    *   Assuming a standard active-high `RST` input for the flip-flop: if `B_stend` is true (e.g., engine is stopped or in a standby state), the flip-flop is reset, causing its `Q` output to be false and its `Q_bar` output to be true.
    *   The `Q_bar` output of the `FF` block directly becomes `B_ekpshg`, the electric fuel pump enable signal. This implies that when the engine is in a "stand" or "stopped" state, the EKP is enabled (e.g., for priming the fuel system before engine start).


--- Page 300 ---

This page clearly displays a Simulink diagram.

## Function

The primary function of this Simulink diagram, titled "PRE_POST_DRIVE" and belonging to "FUSL, Fuel pump low pressure control coordination", is to coordinate and manage various conditions and states related to the low-pressure fuel pump during the pre-drive (engine start-up preparation) and post-drive (engine shutdown/after-run) phases. It integrates numerous sensor inputs, system statuses, and timing signals to determine the operational readiness, safety, and control parameters for the fuel pump, outputting a comprehensive set of status flags and control signals.

## Inputs

The key inputs to this system are:

*   `LV_EFP_WKU` (Electric Fuel Pump Wake-Up signal)
*   `CWPRDRVENA` (Pre-Drive Enable Condition)
*   `100msPreDrive` (100ms Pre-Drive Timer/Flag, likely a bit-encoded signal)
*   `NLC_EFP_PRGD_FEAT_ON` (EFP Purge Feature ON status)
*   `Total engine runtime activation condition`
*   `top_w` (Engine speed or load related signal)
*   `TECNBXPEKA` (A control or status flag)
*   `CWPDRDRV` (Pre-Drive related status, likely bit-encoded)
*   `bit_sel`, `num_dec` (Parameters for bit extraction from `CWPDRDRV` and `CWBKS2`)
*   `Dspl_bHoodOpnNoDeb` (Debounced Hood Open Status)
*   `LV_VAR_4WD` (4-Wheel Drive System Status)
*   `LV_EFP_WKU1` (Another Electric Fuel Pump Wake-Up signal)
*   `CWBKS2` (A control or status signal, likely bit-encoded)
*   `100msSwOff` (100ms Switch-Off Timer/Flag)
*   `Dspl_bDrvDoorOpn` (Driver Door Open Status)
*   `pkbsksr_w` (Brake System Sensor/Status)
*   `B_switchbks` (Brake Switch Status)
*   `B_pddiswuc_prev` (Previous state of `B_pddiswuc`)
*   `B_nli_prev` (Previous state of `B_nli`)
*   `LV_VAR_4WD1` (Another 4-Wheel Drive System Status)
*   `B_kl15` (Ignition Key Position 15, indicating ignition on)
*   `B_airbag` (Airbag System Status)
*   `AuxHtg_bFIPmpReq` (Auxiliary Heating Fuel Pump Request)
*   `pbksadr_w` (Brake System Address or detailed status)
*   `B_edbks` (Electronic Brake System Status)
*   `B_hoodopnok` (Hood Open Status: OK/Not OK)
*   `B_pddiswuc` (A primary control signal, also output from PREDRIVE)
*   `B_switchbks1` (Another Brake Switch Status)
*   `flatpbks_w` (Flat Tire Brake System Warning)
*   `PspCtl_stFIPmpAct` (Power Steering Control Fuel Pump Active Status)

## Outputs

The system produces a single bus output labeled `Out` (V.5.7), which consolidates various individual status and control signals. The key signals comprising this output bus are:

*   `B_pddiswuc` (Pre-Drive Disarm/Switch Control)
*   `B_ekpshq` (Electronic Key Position High Quality)
*   `lepwmbs_w` (Low Electric Pump PWM Base Signal)
*   `B_aekptk` (Active Electronic Key Position Take-over)
*   `B_aekpsh` (Active Electronic Key Position Status High)
*   `tpdbks_w` (Timing for Pre-Drive Brake System)
*   `B_shtpmppredrv` (Shutdown Pump Pre-Drive)
*   `B_pdekpha` (Pre-Drive Electronic Key Phase A)
*   `B_tekpotfk` (Take-over Electronic Key Position Torque Feedback)
*   `B_tekpoztfk` (Take-over Electronic Key Position Zero Torque Feedback)
*   `B_tekpozsh` (Take-over Electronic Key Position Zero Status High)
*   `B_shapekp` (Shape Electronic Key Position)
*   `flatpbks_w` (Flat Tire Brake System Warning, possibly passed through)
*   `B_pdekp` (Pre-Drive Electronic Key Position)
*   `PspCtl_stFIPmpAct` (Power Steering Control Fuel Pump Active Status, possibly passed through)
*   `B_edbks` (Electronic Brake System Status, possibly passed through)
*   `B_epdekp` (Electronic Pump Drive Electronic Key Position)
*   `B_nli` (No Load Input/Ignition Status)

## Logic Flow

The logical flow can be broadly categorized into initial condition evaluation, pre-drive processing, post-drive processing, and low-pressure fuel pump modulation logic, all culminating in a consolidated output.

1.  **Initial Pre-condition Evaluation (Top Left Area):**
    *   The system begins by evaluating fundamental enablement conditions. `LV_EFP_WKU` (EFP Wake-Up) is checked; if non-zero, it contributes to a primary `OR` condition. Similarly, `CWPRDRVENA` (Pre-Drive Enable) is checked.
    *   A `GET BIT` operation extracts a specific bit from `100msPreDrive` and combines it with `CWPRDRVENA` via an `OR` gate.
    *   `NLC_EFP_PRGD_FEAT_ON` (EFP Purge Feature) passes through a variant `if` block, likely selecting different logic based on a condition.
    *   `Total engine runtime activation condition` is compared with `top_w` using a less-than (`<`) operator.
    *   These intermediate results, along with inputs like `B_kl15` (Ignition) and `B_airbag` (Safety), are fed into a series of `OR` gates and `if` blocks to generate various preliminary status flags, some of which directly feed into the `PREDRIVE` subsystem or other logic paths (e.g., `B_pddiswuc` line, `lepwmbs_w` line).
    *   Specific bit extraction (`GET BIT`) from `CWPDRDRV` based on `bit_sel` and `num_dec` is also part of this initial evaluation.

2.  **PREDRIVE Subsystem (V.6.3.1):**
    *   This is a core subsystem responsible for evaluating numerous conditions required *before* the engine starts or the fuel pump operates fully.
    *   It takes a significant number of inputs including ignition status (`B_kl15`), safety system states (`B_airbag`, `B_hoodopnok`, `Dspl_bDrvDoorOpn`), various brake system statuses (`pkbsksr_w`, `B_switchbks`, `pbksadr_w`, `B_edbks`, `flatpbks_w`), auxiliary heating requests (`AuxHtg_bFIPmpReq`), power steering control (`PspCtl_stFIPmpAct`), and vehicle configuration (`LV_VAR_4WD`).
    *   It also receives processed signals from the initial enablement logic, such as `B_pddiswuc` and `lepwmbs_w`.
    *   The `PREDRIVE` block internally processes these inputs to determine a multitude of readiness and control flags (`B_ekpshq`, `B_aekptk`, `B_aekpsh`, `tpdbks_w`, `B_shtpmppredrv`, `B_pdekpha`, `B_tekpotfk`, `B_tekpoztfk`, `B_tekpozsh`, `B_shapekp`, `B_pdekp`, etc.) which are then outputted.

3.  **LEPWMOFF Control Logic (V.6.4):**
    *   This logic determines conditions for "Low Electric Fuel Pump Modulation OFF".
    *   It involves `LV_EFP_WKU1` (another EFP wake-up signal) fed into a `NOT` gate.
    *   A specific bit is extracted from `CWBKS2` using `GET BIT` and then also negated by a `NOT` gate.
    *   These two negated signals, along with `100msSwOff`, feed into an `if` block (`cond_if`).
    *   Depending on the `cond_if` outcome, either a value of `1` or `2` is selected and fed into the `LEPWMOFF` block.
    *   The `LEPWMOFF` block, also taking `lepwmbs_w` as an input, outputs `B_epdekp`, indicating the status of fuel pump modulation control.

4.  **POSTDRIVE Subsystem (V.6.3.2):**
    *   This subsystem handles conditions and flags relevant *after* the driving cycle, possibly during engine shutdown or idle-after-run.
    *   Its inputs include previous status flags (`B_nli_prev`), vehicle configuration (`LV_VAR_4WD1`), brake system status (`B_edbks`, `flatpbks_w`), and outputs from `PREDRIVE` (`B_aekpsh`) and `LEPWMOFF` (`B_epdekp`).
    *   Its primary output is `B_nli` (No Load Input/Ignition Status), which is critical for post-drive diagnostics or shutdown sequences.

5.  **Output Consolidation:**
    *   All the individual output signals generated by `PREDRIVE`, `POSTDRIVE`, `LEPWMOFF`, and other standalone logical paths (e.g., `B_pddiswuc` from the initial enablement chain) are routed to a series of `Merge` blocks.
    *   These `Merge` blocks collect these diverse signals and combine them into a single, structured output labeled `Out` (V.5.7), which likely functions as a bus containing the comprehensive status of the fuel pump control coordination for other interconnected systems.


--- Page 301 ---

This page contains two Simulink diagrams, Figure 43.18.14 and Figure 43.18.15, which are part of a larger automotive control system for "FUSL, Fuel pump low pressure control coordination."

## Function

The primary function of these Simulink diagrams is to control and coordinate the low-pressure fuel pump, specifically managing its "predrive" phase. This involves:
1.  **Wakeup Signal Processing:** Evaluating various vehicle states and input requests (e.g., ignition, door status, auxiliary heating) to determine if the fuel pump predrive should activate.
2.  **Predrive Activation Logic:** Determining if the predrive should be continuously active (`B_aekptk`) or active for a short pulse (`B_aekpsh`), incorporating timing and safety considerations.
3.  **Predrive Disablement Logic:** Establishing conditions under which the predrive function must be inhibited or disabled (`B_pddiswuc`), based on safety, vehicle status, and internal calculations.
4.  **Fuel Pump Control Parameter Generation:** Calculating specific control signals for the fuel pump, such as a Pulse Width Modulation (PWM) command (`lepwmbks_w`) and setting status bits indicating pump activity.

## Inputs

The system receives a wide array of boolean and signal inputs to make its control decisions:

*   **Vehicle State & Safety:**
    *   `B_airbag` (Boolean): Indicates airbag deployment status.
    *   `B_kl15` (Boolean): Ignition terminal 15 (ignition ON) status.
    *   `B_edbks` (Boolean): Status of an electronic brake system or similar safety-critical component.
    *   `Dspl_bDrvDoorOpn` (Boolean): Driver's door open status.
*   **Requests & Previous States:**
    *   `AuxHtg_bFiPmpReq` (Boolean): Request from the auxiliary heating system for fuel pump activation.
    *   `B_pddiswuc_prev` (Boolean): The previous state of the predrive disable condition, used for latching or historical logic.
*   **Timing & Control Parameters:**
    *   `B_tekpoptk`, `B_tekpozsk`, `B_shapekp`, `B_pdekp`: Internal/intermediate signals likely related to predrive timing, profiles, or enable conditions.
    *   `TPDBKSMKZ`: Constant or parameter for a predrive timer maximum value.
    *   `CWPRDRVENA`: Enable for continuous or pulse predrive, potentially for auxiliary heating.
    *   `TEZSHPDEKP`: Predrive activation time or condition related to auxiliary heating.
    *   `TEZTKPDEKP`: Predrive activation time or condition related to door contact.
    *   `CWPRDRV`: Selection for auxiliary heating procedure (continuous or pulse).
    *   `TEKPAPDSH`, `TEKPAPDTK`: Maximum time values used in delay or timeout logic.
    *   `TVOBKS`: Time value for a delay block or timer.
    *   `TEKPOZTK`: Position-related time value.
*   **Fuel Pump Specific Parameters:**
    *   `flatpbksy_w`, `flatpbks_w`: Values potentially related to fuel pressure, flow, or pump characteristics, often used in lookup tables.
    *   `POTKBKS`, `PGZUENDKBS`, `pbksadr_w`, `PGSHBKS`: Signals contributing to the fuel pump PWM calculation, possibly representing desired flow, pressure, or compensations.
    *   `LEPWMMX`, `LEPWMN`: Maximum and minimum allowable PWM values for the fuel pump.
*   **Lookup Table Data:**
    *   `KFFLAF4`, `LV_VAR_4WD`: Data or parameters for 1-D lookup tables used in calculations.

## Outputs

The system generates several boolean and signal outputs to control the fuel pump and communicate its status:

*   **Predrive Status:**
    *   `B_aekptk` (Boolean): Predrive is actively enabled (likely for continuous operation).
    *   `B_aekpsh` (Boolean): Predrive is actively enabled for a short or pulse operation.
    *   `B_pdekpha` (Boolean): Predrive function is actively enabled.
    *   `B_ekpshg` (Boolean): Predrive is active in a short/pulse mode.
    *   `B_pddiswuc` (Boolean): Predrive function is disabled due to a specific condition.
*   **Fuel Pump Control & Status:**
    *   `PspCtl_stFiPmpAct` (Bitfield/Signal): Fuel pump control status (e.g., Bit 0 for "EKP aktiv" - EKP active, Bit 1 for "EKP war aktiv" - EKP was active).
    *   `PspCtl_stAuxHtgPmpAct` (Bitfield/Signal): Auxiliary heating pump control status (similar bit structure to `PspCtl_stFiPmpAct`).
    *   `lepwmbks_w` (Signal): Commanded Pulse Width Modulation (PWM) value for the low-pressure fuel pump.
    *   `B_switchbks` (Boolean): General switch or state for the fuel pump system.
    *   `pksbksr_w` (Signal): A control signal related to the fuel pump, possibly indicating a required rate or pressure.
*   **Internal States:**
    *   `RSFlipFlop_4_res` (Boolean): Output of an internal RS flip-flop used for state latching.

## Logic Flow

The logical flow combines two main processing paths: "Predrive main part (processing of wakeup signals)" (Figure 43.18.14) and "DISABLE_PRDRV" (Figure 43.18.15), which interact with each other.

### 1. Predrive Activation and Status Determination (Figure 43.18.14)

*   **Initial Wakeup and Enable Logic:**
    *   Various input signals like `B_airbag`, `B_kl15`, `B_edbks`, `AuxHtg_bFiPmpReq`, `Dspl_bDrvDoorOpn`, and `B_pddiswuc_prev` are monitored.
    *   A primary predrive enable (`B_pdekpha`) is derived from `B_pdekp` and timed conditions from the `TPDBKSMKZ` counter/timer, managed by an RS Flip-Flop. This ensures `B_pdekpha` is set only when specific conditions are met for a sufficient duration.
    *   A separate short/pulse predrive active state (`B_ekpshg`) is set by another RS Flip-Flop, influenced by `CWPRDRVENA` and `flatpbksy_w`.
*   **Auxiliary Heating and Door Contact Logic:**
    *   `AuxHtg_bFiPmpReq` and `TEZSHPDEKP` directly influence the setting of bits within `PspCtl_stAuxHtgPmpAct`, indicating the auxiliary heating pump's operational status.
    *   `Dspl_bDrvDoorOpn` (driver door open) and `TEZTKPDEKP` are processed through timers (T-blocks, indicating delays or pulse generation) and an RS Flip-Flop. This logic likely handles predrive activation linked to door events.
*   **Final Predrive Active States (`B_aekptk`, `B_aekpsh`):**
    *   Multiple timer outputs (`TEKPAPDSH`, `TEKPAPDTK`), logical NOT gates, AND gates, and `Check == 0` blocks (likely comparing values to zero for specific conditions) are used to combine the various enable and disable conditions, including `B_pddiswuc` (from Figure 43.18.15), `B_pdekpha`, and `B_ekpshg`.
    *   This complex logic determines the final `B_aekptk` (continuous predrive active) and `B_aekpsh` (short/pulse predrive active) signals.
*   **Fuel Pump PWM Calculation:**
    *   Four input signals (`POTKBKS`, `PGZUENDKBS`, `pbksadr_w`, `PGSHBKS`) are summed. The result is then limited by the `LEPWMN` (minimum) and `LEPWMMX` (maximum) values using a Min/Max block, outputting the final `lepwmbks_w` (fuel pump PWM command).
*   **Pump Status Bitfield Generation:**
    *   Based on internal control states and requests, `SET BIT` blocks are used to compose the `PspCtl_stFiPmpAct` and `PspCtl_stAuxHtgPmpAct` output bitfields. For example, specific bits are set if the EKP (fuel pump) is active or was active.

### 2. Predrive Disablement Logic (Figure 43.18.15)

*   **Safety and Vehicle State Disable Conditions:**
    *   `B_airbag`, `B_kl15`, and `B_edbks` are individually inverted (NOT gates). If any of these critical signals are FALSE (e.g., ignition OFF, airbag not deployed), it contributes to the disable condition via an `OR` gate.
    *   `Dspl_bDrvDoorOpn` (driver door open) goes through a timer (T-block) and is OR-gated with `B_pddiswuc_prev`, meaning if the door has been open for a duration, or predrive was previously disabled, it contributes to disable.
*   **Predrive Activity-Based Disable:**
    *   `B_pdekpha` (predrive enable active) or `B_ekpshg` (predrive short/pulse active) are OR-gated, then passed through a timer (T-block) and inverted (NOT gate). This checks if predrive *should* be active but isn't, potentially leading to disable. This path is AND-gated with `CWPRDRV`.
*   **Lookup Table-Based Conditions:**
    *   `flatpbksy_w` is fed into a cascaded lookup table system (`KFFLAF4` then `LV_VAR_4WD`) to produce `flatpbks_w`. Conditions based on `flatpbks_w == 0` or `TVOBKS == 0` contribute to the disable logic.
*   **Final `B_pddiswuc` Derivation:** All the individual disable contributing paths (from safety, vehicle state, previous disable, predrive activity status, and lookup table results) are combined through a series of `AND` gates to determine the final `B_pddiswuc` signal. If all necessary disable conditions are met simultaneously (or a critical one is active), `B_pddiswuc` becomes TRUE.
*   **Additional Control Signals:**
    *   `B_switchbks` is derived from `B_pdekpha`, `B_ekpshg`, and the calculated `B_pddiswuc`, potentially after timing delays.
    *   `pksbksr_w` is generated from `flatpbks_w` and `TEKPOZTK` using timers, comparisons, and logic gates.

In essence, these diagrams describe a robust state machine with timing elements and lookup tables that govern the activation, deactivation, and control of a low-pressure fuel pump, ensuring proper operation based on complex vehicle and safety conditions.


--- Page 302 ---

This page contains two Simulink diagrams, Figure 43.18.16 "DISABLE_PRDRV" and Figure 43.18.17 "POSTDRIVE", which are components of a larger "Fuel pump low pressure control coordination" system (FUSL). The following analysis focuses primarily on the second diagram, Figure 43.18.17, as indicated by the section heading "1.6.3.2 POSTDRIVE".

## Function

The primary function of this Simulink diagram (Figure 43.18.17: POSTDRIVE) is to control the Electric Fuel Pump (EKP) during the "Postdrive" phase. This phase typically occurs after the engine has been switched off but conditions might still require the fuel pump to operate, for instance, to support auxiliary heating, maintain fuel pressure, or respond to specific system states. The logic determines the pump's activation, manages shutdown conditions, detects errors, calculates a Pulse Width Modulation (PWM) signal for its operation, and outputs a consolidated status word.

## Inputs

The key inputs to this POSTDRIVE logic are:

*   **`B_nll_prev`** (Boolean): A signal indicating the previous "not load" or "not idle" state, often used for latching conditions.
*   **`CWPRDRV`** (Bus/Integer): A control word for the pre-drive/post-drive phase, containing multiple bit flags that influence pump behavior (e.g., EKP active, EKP was active).
*   **`TEZSHPDEKP`** (Signal): A timer value, likely representing a countdown for EKP shutdown or a duration for EKP operation.
*   **`AuxHtg_bFIPmpReq`** (Boolean): A request signal from the auxiliary heating system, indicating if the fuel pump is needed.
*   **`pbksadr_w`** (Signal): Measured fuel pressure from the low-pressure fuel system.
*   **`PGSHBKS`** (Signal): A threshold value for fuel pressure, used for comparison.
*   **`B_airbag`** (Boolean): Status of airbag deployment (true if deployed).
*   **`B_KI15`** (Boolean): Ignition status (true if ignition terminal 15 is active).
*   **`B_edbks`** (Boolean): An error status flag, potentially from a brake system or a related component.
*   **`flafpbks_w`** (Signal): Filtered or processed pressure feedback value, possibly for advanced pump control.
*   **`TVOBKS`** (Signal): Another time or value-based input, likely a timer or a condition for pump operation.
*   **`PSPSACTIVE_BP`** (Boolean): A base parameter indicating whether the post-run pump should be active.
*   **`HEATERRUN_BP`** (Boolean): A base parameter indicating whether the heater is currently running.
*   **`LEPWMMX`** (Signal): Maximum allowed PWM value or duration for pump operation.
*   **`LEPWMMN`** (Signal): Minimum allowed PWM value or duration for pump operation.
*   **`PSPCTL_AUXH_V_0`** (Signal): An auxiliary heater control value, possibly an enable or target for pump operation.

## Outputs

The key outputs generated by this POSTDRIVE logic are:

*   **`B_nnll`** (Boolean): The calculated current "not load" or "not idle" state for the postdrive phase.
*   **`B_aekpsh`** (Boolean): A flag indicating if the Electric Fuel Pump (EKP) shutdown conditions are met.
*   **`B_epdekp`** (Boolean): An error flag indicating a detected fault condition for EKP operation during postdrive.
*   **`PspCtl_stFIPmpAct`** (Integer/Bitfield): A consolidated status word for the fuel pump's activity. It is composed of at least two bits:
    *   Bit 0: Indicates if the EKP is currently active (`Status 'EKP aktiv' setzen`).
    *   Bit 1: Indicates if the EKP was active or active due to heater (`Status 'EKP war aktiv' setzen`).
*   **`lepwm_w`** (Signal): The calculated Pulse Width Modulation (PWM) signal (duty cycle) used to control the electric fuel pump.

## Logic Flow

The logical flow of the POSTDRIVE diagram can be broken down into several interconnected parts:

1.  **Postdrive Pump Activation Latching (`B_nnll`):**
    *   The previous "not load" state (`B_nll_prev`) is inverted by a `NOT` block.
    *   This inverted signal feeds into a `cond_if` block (conditional if statement, likely based on `V.6.0`, a model version or condition).
    *   The output of the `cond_if` block acts as the `SET` input to an `FF` (Set-Reset Flip-Flop).
    *   The `RST` input of the `FF` is driven by `CWPRDRV` (likely a reset bit from the control word).
    *   The `Q` output of the `FF` produces `B_nnll`, effectively latching the "not load" condition for postdrive until a reset occurs.

2.  **EKP Postdrive Error Detection (`B_epdekp`):**
    *   An `OR` gate combines `B_airbag` (airbag deployed) and `B_KI15` (ignition on). This is usually a safety critical condition.
    *   The result of this `OR` gate is then negated by a `NOT` block.
    *   This negated signal is fed into another `OR` gate along with `B_edbks` (an external error).
    *   The final output, `B_epdekp`, indicates an error condition. This suggests that if an airbag is deployed, or if the ignition is on (and other specific conditions are not met via the NOT gate), or `B_edbks` is active, a postdrive EKP error is declared.

3.  **EKP Shut-off Conditions (`B_aekpsh`):**
    *   Bit 0 of `CWPRDRV` (representing "EKP active") is extracted by a `GET BIT` block.
    *   `TEZSHPDEKP` (a timer value) is compared against a threshold using a `T` (Threshold) block.
    *   These conditions, alongside auxiliary heating request (`AuxHtg_bFIPmpReq`) and other logic within `cond_if` and `AND` blocks, collectively determine `B_aekpsh`. This logic implements conditions for when the EKP should be commanded to shut off, possibly after a specific runtime or if auxiliary heating is no longer required.

4.  **Pressure-Dependent Pump Control Logic:**
    *   The measured fuel pressure `pbksadr_w` is compared against a threshold `PGSHBKS` using a `<` (less than) block.
    *   The result of this comparison, along with an implicit X-value (potentially `pbksadr_w` itself or another related variable), feeds into a `KFFLAF` block (likely a 2D lookup table or filter, e.g., `KF_FLAF_A4`). This block maps pressure values to an internal control value.
    *   The `y_val` output from `KFFLAF` is then checked (`Check ~= 0`), meaning a non-zero output from this pressure-based control is significant.
    *   This condition is combined with `flafpbks_w` and a `Check ~= 0` result from `TVOBKS` (another timer or status value) through `AND` gates. This section drives the pump activation based on maintaining fuel pressure and potentially other time-dependent factors.

5.  **PWM Generation for Fuel Pump (`lepwm_w`):**
    *   A `cond_if` block selects between `LEPWMMX` (maximum PWM) and `LEPWMMN` (minimum PWM) based on the value of `PSPCTL_AUXH_V_0` (auxiliary heater control). This suggests that the allowed operating range of the pump's PWM can be adjusted based on the auxiliary heater's requirements.
    *   The selected PWM value, along with other enable/disable conditions (including outputs from `Check ~= 0` blocks from the pressure logic and `TVOBKS`), feeds into a `LEPWMSK` block (Pulse Width Modulation Scaling/Generation).
    *   The output `lepwm_w` represents the calculated PWM duty cycle to drive the physical fuel pump, effectively controlling its speed or flow.

6.  **Final Fuel Pump Status Output (`PspCtl_stFIPmpAct`):**
    *   A `SET BIT` block sets bit 0 of the output (`PspCtl_stFIPmpAct`) to 1 if `PSPSACTIVE_BP` (post-run pump active base parameter) is true. This signifies that the EKP is currently considered active.
    *   Another `SET BIT` block sets bit 1 to 1 if `HEATERRUN_BP` (heater run base parameter) is true. This signifies that the EKP was active or is active due to heater operation.
    *   These two bit-setting operations are merged to form `PspCtl_stFIPmpAct`, providing a compact, bit-encoded status word for the fuel pump's overall activity state during postdrive.


--- Page 303 ---

This page clearly contains a Simulink diagram. It represents a complex control system for coordinating a fuel pump's low-pressure operation, likely within an automotive context, as indicated by the title "FUSL, Fuel pump low pressure control coordination" and the file path "FUSL_M908U/OPM_20MS". The "FUSL" prefix often denotes Functional Safety Low Pressure, implying a safety-critical system.

## Function

The primary function of this Simulink diagram is to **coordinate and control the low-pressure fuel pump operation** based on various vehicle states, safety requirements, driver demands, and interactions with other vehicle systems. It dynamically selects operational modes, processes numerous sensor inputs and feedback signals, and generates appropriate control commands and status flags for the fuel pump. The extensive use of status flags, feedback loops, and subsystems with names suggesting safety and system checks indicates a robust and fault-tolerant design, typical for safety-critical automotive applications.

## Inputs

The system takes a wide array of inputs, reflecting the need to integrate information from diverse vehicle subsystems for precise and safe fuel pump control. Key inputs observed include:

*   **Primary System Triggers/Modes:**
    *   `In`, `In1`, `In2`, `In3`: General input signals, likely representing activation or mode requests.
    *   `<B_kli15>`: Ignition status (Terminal 15), indicating whether the ignition is on.
    *   `<B_kli15_dly>`: Delayed ignition status, used for transient handling.
    *   `B_switchbks`, `SY_SGANZ`: System switch status and overall system health/gain status.
*   **Feedback & Status Signals:**
    *   `feedback`: A generic feedback signal, likely representing the current state or response of the controlled system or other modules.
    *   `<B_sshev>`, `<B_tgsabks_prev>`, `<B_dhbks_prev>`, `<B_flafbks_prev>`, `<B_timeondh>`, `treflahr_w`: Various previous state or feedback flags, indicating history or prior conditions.
    *   `<B_ekpoksa>`, `<B_ekposfr>`, `repambks_w`: Electric fuel pump status and feedback signals.
    *   `B_tlistok`: Time status OK flag.
    *   `B_fltcank`, `tfts`, `bdnd`, `prsolind_w`, `stendz`, `ebks`: Various system and diagnostic flags.
*   **Pressure & Hydraulic Systems:**
    *   `prsol_w`, `prdiff_w`: Pressure setpoint and pressure differential values.
    *   `masternaw`, `hrdynaw`, `pbksaw_w`, `pbkssum_w`, `pbksollmod_w`: Master, hydraulic, and braking system actual/sum/setpoint values, possibly influencing fuel demand or safety cut-offs.
*   **Engine & Vehicle Dynamics:**
    *   `nmot`: Engine speed.
    *   `LV_VAR_4WD`: Load Variable for 4-wheel drive system, indicating vehicle load or traction conditions.
*   **Safety & Diagnostics:**
    *   `airbag`, `B_sa`: Airbag deployment status and general safety-related status signals.
    *   `dmkhdev_w`: Driver's desired value (e.g., accelerator pedal position).
    *   `B_sabte`, `rnse_w`, `tktm`, `ubsq`: Safety-related sensor inputs, runtime, or vehicle speed/torque signals.
    *   `B_ekp`, `prist_w`, `pbkist_w`, `erdlbkay`, `tal`, `tmt`, `rqtbks`, `arqtbks_w`: Electric pump and various system status/requests, potentially for diagnostics or readiness.
*   **Auxiliary Systems:**
    *   `AuxHtg_BFlFpmqReq`: Auxiliary heating (parking heater) fuel pump motor request.
    *   `top_w`, `B_hoodopnok`: Top (e.g., convertible roof) status, hood open status (potentially for safety interlocks).

## Outputs

The system generates a range of outputs, primarily control commands and status flags, which are aggregated into a main output or used by other modules:

*   **Main Coordinated Output:**
    *   `Out`: The primary aggregated output of the fuel pump control system, likely a bus containing various control commands, setpoints, and operational statuses for the low-pressure fuel pump.
*   **Specific Control & Status Signals (examples from various blocks):**
    *   `B_pbksprof`, `anzhrdynaw`, `B_hrdynaw`, `B_prdlflw`: Processed profiles, actual/desired hydraulic values, and pressure differential flags.
    *   `B_bkspa`: Brake system related status or control.
    *   `flafbks_w`, `fsalbks`, `fskbks`, `flafuesbks_w`, `fftkbks`, `flafcbks_w`, `flafebks_w`, `flafahr_w`: Various feedback and activity flags indicating operational states or faults.
    *   `B_ekpdh`, `B_ekpkosa`, `B_epdfr`: Electric pump control signals or detailed status.
    *   `B_htg`, `shrtmp100`: Auxiliary heater related status or control parameters.
    *   `B_epdekp`, `FlpCtl_sfFpmqAct`: Electric pump status and functional safety fuel pump motor request active flag.
    *   `ptbksinp_w`, `flafbksy_w`: Processed brake system input and feedback.
    *   `B_pkbksrg`, `B_ekpstbks`, `B_dbvhdo`, `B_btsbksn`, `B_dstkasset`, `B_bkspae`, `B_ekpoksaa`, `ik15bks`, `B_rqtbksvld`: Various specific control signals and diagnostic statuses related to the pump, braking (if applicable), and safety system integration.

## Logic Flow

The logical flow of the diagram can be described in a hierarchical, multi-stage process:

1.  **Input Conditioning and Mode Selection (Top Left):**
    *   The system begins with main inputs (`In`, `B_kli15`).
    *   A `T V.5.3` block introduces a discrete time delay (0.02 units, likely seconds) to a signal `u`, generating `<B_kli15_dly>`. This delayed ignition status is crucial for stable operation and avoiding erratic behavior during ignition transients.
    *   A `cond_if V.6.0` block, which likely represents a conditional subsystem or an `If-Else If-Else` logic, uses `<B_kli15>` and `<B_kli15_dly>` to select one of seven possible execution paths, labeled `ACTIVE_1` through `ACTIVE_7`. This suggests the system operates in different modes or processes different sets of logic depending on the ignition state and its stability.

2.  **Parallel Processing in Active Modes:**
    *   Each `ACTIVE_X` block (e.g., `ACTIVE_1`, `ACTIVE_2` (CHK_HEV_STST), `ACTIVE_3`, `ACTIVE_4` (KORBKS), `ACTIVE_5` (KORBKS2), `ACTIVE_6` (Standheizung), `ACTIVE_7` (ONOFBKS)) represents a distinct subsystem or functional block. These blocks process specific subsets of inputs relevant to their designated function.
    *   **`ACTIVE_1`** likely handles initial system setup or basic status checks based on generic feedback and previous states.
    *   **`ACTIVE_2` (CHK_HEV_STST)** appears to process general system status (`SY_SGANZ`), switch states, and various pressure/hydraulic values to check for HEV-specific conditions and output processed profiles and hydraulic values.
    *   **`ACTIVE_3`** focuses on pump unit operation (`pu_w`) and interactions with brake system actual/setpoint values, generating `B_bkspa`.
    *   **`ACTIVE_4` (KORBKS)** and **`ACTIVE_5` (KORBKS2)** are complex blocks receiving numerous feedback, safety, and operational signals. They likely perform correlation, correction, or validation logic, generating a variety of feedback and status flags (`flafbks_w`, `fsalbks`, `B_ekpdh`, etc.). Their names suggest "correction" or "coordination" functions, potentially reacting to brake system states or safety interlocks.
    *   **`ACTIVE_6` (Standheizung)** integrates auxiliary heater requests (`AuxHtg_BFlFpmqReq`), safety signals, and engine speed to control fuel pump behavior when the auxiliary heater is active, producing flags like `FlpCtl_sfFpmqAct`.
    *   **`ACTIVE_7` (ONOFBKS)** processes a very wide range of inputs, including system switches, engine speed, safety signals, electric pump statuses, and ignition states, to determine the ON/OFF state and readiness of the fuel pump system.

3.  **Cross-Subsystem Coordination and Feedback:**
    *   Many signals from one `ACTIVE_X` block feed into other `ACTIVE_Y` blocks or other major subsystems like `EDBCONTR`, `VSTBKS`, `ONOFBKS`, `KORBKS`, `KORBKS2`. This indicates a highly interconnected and coordinated system where the output of one functional block influences the processing in others.
    *   For example, `EDBCONTR` (Electronic Brake Distribution Control?) and `VSTBKS` (Pre-control Brake Booster?) receive various system flags and environmental conditions, suggesting the fuel pump control is integrated with vehicle dynamic control systems. The "feedback" lines are prominent, indicating closed-loop control or continuous state monitoring.

4.  **Output Aggregation:**
    *   Finally, the processed signals from all these major subsystems are channeled towards a central aggregation point, ultimately leading to the `Out` block (`V.5.7`). This signifies that the final output is a comprehensive, coordinated set of commands and status indicators derived from the entire logic flow, tailored for controlling the low-pressure fuel pump.


--- Page 304 ---

This page contains a Simulink diagram.

## Function
This Simulink diagram, titled "CHK_HEV_STST" (Check Hybrid Electric Vehicle Status), is a critical component within the "Fuel pump low pressure control coordination" (FUSL) system. Its primary function is to determine and output a control signal (`kfflafin_w`) that enables or disables specific hybrid electric vehicle (e-drive) functionalities. It evaluates a set of safety, operational, and system health conditions to allow e-drive functions, incorporating a latching mechanism to maintain the enabled state once established, and further gating the final output based on specific fuel system health status.

## Inputs
1.  **B_stendz (4):** A boolean signal indicating a vehicle standstill or a state ready for operation.
2.  **B_nwmot (5):** A boolean signal indicating the status of the internal combustion engine (e.g., TRUE if active, FALSE if not active). Used to fulfill the "Verbrennungsmotor nicht aktiv" (internal combustion engine not active) condition.
3.  **B_kl15_dly (9):** A boolean signal indicating if ignition (Terminal 15) is on, possibly after a delay. Used for the "Klemme15=ein" (Terminal 15=on) condition.
4.  **CWBSKS3:** A data bus or word from which specific bits are extracted. Bit 2 is used to check for "EKP-Vorlauf abgeschlossen" (Electric Fuel Pump pre-run completed).
5.  **B_hd_nbf_bks (10):** A data bus or word containing high-pressure system fault status bits. Bit 0 is used to check for "kein HD-Fehler" (no High-Pressure fault).
6.  **B_airbag (6):** A data bus or word containing crash detection status bits. Bit 0 is used to check for "kein Crash" (no Crash detected).
7.  **dmkrmpi_w (8):** A numerical signal, likely an error counter or status word related to Multi-Point Injection (MPI) or other fuel system components.
8.  **dmkrhdev_w (3):** Another numerical signal, possibly an error counter or status word, related to fuel system diagnostics or device status.
9.  **CWBSKMPI:** A subsystem or data word that processes `dmkrmpi_w` and `dmkrhdev_w` and provides a status output. Bit 0 of this output is used as a gating condition for `kfflafin_w`.

## Outputs
1.  **B_sshev (1):** A boolean flag indicating immediate readiness for e-drive functions, based on the real-time fulfillment of a set of critical conditions.
2.  **B_efahr (2):** A boolean flag indicating that e-drive functions are generally allowed. This signal incorporates a latching mechanism, meaning it stays TRUE once `B_sshev` becomes TRUE, effectively remembering the enabled state.
3.  **B_sa (7):** An unused output in the visible scope of this diagram.
4.  **kfflafin_w (1):** The final boolean output, representing the active enable signal for fuel pump low-pressure control coordination (or a related e-drive function). Its state is determined by `B_efahr` and further gated by specific fuel system health checks from `CWBSKMPI`.

## Logic Flow

The diagram's logic can be broken down into three main stages:

1.  **E-drive Readiness Evaluation (`B_sshev`):**
    *   This stage gathers inputs related to vehicle state, engine status, ignition, and critical system health checks. These inputs correspond to the German conditions: "E-Fahrbetriebsfunktionen nur zulassen, wenn:" (Allow e-drive functions only if:).
    *   **Vehicle Ready/Standstill:** `B_stendz` (4) is directly fed to an `AND` gate.
    *   **Engine Not Active:** `B_nwmot` (5) (which is assumed TRUE if the engine *is* active, and FALSE if *not* active) is passed through a `NOT` gate. The output (TRUE when the engine is not active) is fed to the `AND` gate.
    *   **Ignition ON:** `B_kl15_dly` (9) is directly fed to the `AND` gate.
    *   **EKP Pre-run Completed:** Bit 2 from the `CWBSKS3` input is extracted using a `GET BIT` block and fed to the `AND` gate.
    *   **No High-Pressure Fault:** Bit 0 from `B_hd_nbf_bks` (10) (assumed TRUE for a fault, FALSE for no fault) is extracted using `GET BIT` and then inverted by a `NOT` gate. The output (TRUE for no fault) is fed to the `AND` gate.
    *   **No Crash Detected:** Bit 0 from `B_airbag` (6) (assumed TRUE for no crash, FALSE for crash) is extracted using `GET BIT` and directly fed to the `AND` gate.
    *   All six of these signals are combined by an `AND` gate. The output, `B_sshev` (1), is TRUE only if all six conditions are met simultaneously, indicating the immediate readiness and safety for e-drive operation.

2.  **E-drive Function Enable Latch (`B_efahr`):**
    *   `B_sshev` (1) is connected to an `OR` gate.
    *   The output of this `OR` gate is `B_efahr` (2).
    *   `B_efahr` itself is fed back to the control port of a Multiport Switch. This switch has two data inputs: a constant `0` and `B_efahr`.
        *   If the control input (`B_efahr`) is FALSE (0), the switch selects the constant `0`.
        *   If the control input (`B_efahr`) is TRUE (1), the switch selects `B_efahr`.
    *   The output of this switch is then fed as the second input to the `OR` gate. This configuration creates a latch: once `B_sshev` becomes TRUE, `B_efahr` becomes TRUE. This TRUE state of `B_efahr` is then fed back through the switch and the `OR` gate, causing `B_efahr` to remain TRUE even if `B_sshev` later becomes FALSE. `B_efahr` effectively "remembers" that e-drive functions have been allowed.

3.  **Final Output Gating (`kfflafin_w`):**
    *   Two numerical inputs, `dmkrmpi_w` (8) and `dmkrhdev_w` (3), are summed together. These likely represent diagnostic or status values from the fuel system.
    *   The sum is passed to a `CWBSKMPI` block, which is indicated in red, suggesting it's a critical subsystem, possibly for fault monitoring or safety checks within the fuel/MPI system.
    *   Bit 0 of the `CWBSKMPI` output is extracted using a `GET BIT` block. This bit serves as a final enabling/disabling condition for the main output.
    *   This extracted bit controls a Multiport Switch that produces the final output `kfflafin_w` (1).
        *   If the control bit (`GET BIT(CWBSKMPI output, bit 0)`) is FALSE (0), the switch outputs a constant `0`.
        *   If the control bit is TRUE (1), the switch outputs the value of `B_efahr` (2).
    *   Therefore, `kfflafin_w` is only TRUE if both `B_efahr` is TRUE (i.e., e-drive functions have been allowed based on the initial conditions and latch) AND the specific status bit from `CWBSKMPI` indicates a healthy or permissible state for the fuel system. This ensures that even if e-drive is generally enabled, specific fuel system issues can prevent the activation of fuel pump low-pressure control coordination.


--- Page 305 ---

This page contains a Simulink diagram.

## Function
The primary function of this Simulink diagram, labeled "43.18.7.2 HDCONTR" (likely High-Pressure Control/Monitoring), is to monitor various parameters of an automotive high-pressure fuel system for anomalies and generate corresponding diagnostic flags or warning indicators. It specifically focuses on:
1.  Detecting deviations in desired vs. actual fuel pressure differences.
2.  Monitoring for dynamic anomalies or instabilities in the high-pressure regulator.
3.  Assessing the health of the high-pressure regulator based on its velocity/rate.
4.  Integrating various system statuses (e.g., brake system, engine speed, ignition) to qualify these anomaly detections.

The overall goal is to provide inputs for "Fuel pump low pressure control coordination" (FUSL), suggesting these flags influence the operation of the low-pressure fuel pump to ensure the integrity and safety of the fuel system. The German text translates to "Number of high-pressure regulator events with impermissibly high values or dynamics outside the wobbling in this cycle," confirming the diagnostic nature of the `anzhrdynaw` output.

## Inputs
The key inputs to this system are:

*   **`SY_SGANZ` (3):** System overall status or diagnostic counter.
*   **`prsolli_w` (4):** Desired working pressure value.
*   **`prdiff_w` (5):** Actual working pressure difference.
*   **`B_masterhw` (6):** Master hardware enable/status (boolean).
*   **`B_kl15_dly` (19):** Delayed Ignition (Klemme 15) status (boolean).
*   **`prsolli_cw` (7):** Desired cold pressure value.
*   **`prdiff_cw` (8):** Actual cold pressure difference.
*   **`B_switchbks` (20):** Brake system switch status (boolean).
*   **`B_ebks`:** Electric brake system status (boolean).
*   **`B_wbkse`:** Unknown boolean signal.
*   **`B_sabte`:** Unknown boolean signal.
*   **`tnse_w`:** Unknown numerical value.
*   **`B_gsch`:** Unknown boolean signal.
*   **`nmot_w`:** Engine speed (numerical).
*   **`vdaavst_w`:** Unknown numerical value.
*   **`dmkrhdef_w`:** Unknown numerical value.
*   **`B_msvkma`:** Unknown boolean signal.
*   **`vrhdr_w` (9):** High-pressure regulator velocity.
*   **`vrhdrf_w` (10):** Filtered high-pressure regulator velocity.
*   **`B_flatobks_prev` (2):** Previous state of a "flat out brake system" condition (boolean).
*   **`VNDNTSYN`:** Input indicating "no synchronization" (boolean).
*   **`VNDNTHD`:** Input indicating "no high pressure" (boolean).
*   **`B_prdifffc`:** A condition that sets the pressure difference failure latch (boolean).
*   **`Z_FF`:** Reset signal for a latch/flip-flop.
*   **`FF`:** Set signal for a latch/flip-flop.

## Outputs
The key outputs generated by this system are:

*   **`B_prdiffw` (4):** Boolean flag indicating an anomaly in the working pressure difference.
*   **`anzhrdynaw` (2):** Numerical counter for high-pressure dynamic anomalies/events.
*   **`B_hrdynaw` (3):** Boolean flag indicating a high-pressure dynamic warning.
*   **`B_pbksprof` (1):** Boolean flag potentially related to pressure build-up or brake system profiling.
*   **`B_prdiffcw` (5):** Boolean flag indicating an anomaly in the cold pressure difference.
*   **`B_vhdrbks` (6):** Boolean flag indicating an issue with the high-pressure regulator's velocity, potentially in conjunction with brake system operation.

## Logic Flow

The logical flow can be broken down into several interconnected monitoring paths:

1.  **Working Pressure Difference Monitoring (Top Left):**
    *   The `prsolli_w` (desired working pressure) is fed into a 1D lookup table (`KLPRDIFMX`) to determine an allowed tolerance (`IP_val`).
    *   This `IP_val` is added to `prdiff_w` (actual working pressure difference).
    *   The sum is then evaluated by a hysteresis block (`PRDIFHYS`) to determine if the deviation exceeds acceptable limits, generating a boolean signal.
    *   A comparison of `SY_SGANZ` with `1` (`cond_if`) acts as a selector in an `if` block, possibly enabling or disabling this monitoring based on a system status.
    *   The output `B_prdiffw` is set if a working pressure difference anomaly is detected under the specified conditions.

2.  **Cold Pressure Difference Monitoring (Middle Left):**
    *   A parallel path exists for "cold" conditions using `prsolli_cw` (desired cold pressure) and `prdiff_cw` (actual cold pressure difference).
    *   Similar lookup table (`KLPRDIFMX`), summation, and hysteresis logic (`PRDIFHYS`) are applied.
    *   The output `B_prdiffcw` flags cold pressure difference anomalies.

3.  **High-Pressure Dynamic Anomaly Monitoring (Top Right):**
    *   `B_masterhw` and `B_kl15_dly` (ignition status) are combined using an `AND` gate, generating `B_pbksprof`, likely an enable for pressure profiling or diagnostics.
    *   Further logical gates (`OR`, `NOT`, and specific `V.5.3` blocks which might represent edge detection, thresholds, or specialized boolean logic) process `B_masterhw`, `B_kl15_dly`, and other internal signals.
    *   These operations detect dynamic instabilities or unacceptable rate-of-change in the high-pressure system, setting the boolean flag `B_hrdynaw`.
    *   An `anzhrdynaw` counter increments each time such a dynamic anomaly is detected. A `Switch` block, controlled by `B_switchbks`, can reset this counter to `0` if the brake system status dictates.

4.  **High-Pressure Regulator Velocity/Rate Monitoring (Lower Left):**
    *   `vrhdr_w` (regulator velocity) is processed by `VRHDRSTAT` block, and `vrhdrf_w` (filtered regulator velocity) by `VRHDRDYN` block. These blocks likely evaluate the regulator's behavior against static and dynamic thresholds.
    *   The outputs of `VRHDRSTAT` and `VRHDRDYN` are combined with comparison results (e.g., `nmot_w > X`) using `OR` gates and `AND` gates, indicating various fault conditions.
    *   Further processing through `ZTHDCTRBKS` and a threshold/hysteresis block (`V.5.3`) leads to the `B_vhdrbks` flag, which indicates an issue with the high-pressure regulator's velocity, possibly in contexts related to the brake system (`bks`).

5.  **System Condition Aggregation and Latching (Bottom Middle/Right):**
    *   Several boolean inputs (`B_switchbks`, `B_ebks`, `B_wbkse`, `B_sabte`, `B_gsch`, `B_msvkma`) and comparison results from numerical inputs (`tnse_w`, `nmot_w`, `vdaavst_w`, `dmkrhdef_w`) are fed into a `BBHDCTR` subsystem (likely a collection of OR gates).
    *   These conditions are combined with `B_vhdrbks` using `AND` gates to create more complex diagnostic conditions.
    *   A Flip-Flop (`FF`) block is used to latch a state (`B_tndh`) based on `B_prdifffc` (set input) and reset signals (`Z_FF`, `FF`). This ensures a fault condition remains active until explicitly reset.
    *   The latched signal (`B_tndh`), `B_flatobks_prev`, `B_vhdrbks`, and negated `VNDNTSYN` and `VNDNTHD` signals are combined through a series of `OR` and `AND` gates. This final complex logic aggregates various fault and status conditions to inform downstream systems about the overall high-pressure system's health. The ultimate output of this aggregated logic (the rightmost `AND` gate) isn't explicitly labeled as an overall output, but it represents a crucial internal status.


--- Page 306 ---

This page contains two Simulink-like diagrams (Figure 43.18.21 and Figure 43.18.22), which represent control logic within an automotive system. I will analyze Figure 43.18.21 in detail as it appears to be a self-contained functional block, and briefly describe Figure 43.18.22.

## Function (Figure 43.18.21)

Figure 43.18.21 describes a control logic module responsible for generating two boolean outputs, `B_hdctbks1` and `B_hdctbks2`, which likely represent the activation or readiness status of two independent hydro-control brake system channels. The logic is highly conditional, relying on various brake system states, engine and vehicle speed, differential pressure, and a system configuration bit. It incorporates signal inversion, logical AND operations, comparative analysis, and time delays to produce robust control signals.

## Inputs (Figure 43.18.21)

1.  **B_ebks**: Boolean, status of electronic brake system.
2.  **B_wbkse**: Boolean, status of a wheel brake sensor.
3.  **B_sabte**: Boolean, status related to ABS or stability control (e.g., anti-lock brake system enabled/active).
4.  **B_gsch**: Boolean, general switch or gear shift signal.
5.  **nmot_w**: Numeric, engine speed.
6.  **NMOTHDGCS**: Numeric, threshold for engine speed.
7.  **vdaavst_w**: Numeric, vehicle speed.
8.  **VDAAGWBKS**: Numeric, threshold for vehicle speed.
9.  **dmkrhdef_w**: Numeric, differential pressure value.
10. **DMKRGWBKS**: Numeric, threshold for differential pressure.
11. **B_msvkma**: Boolean, master cylinder switch or specific brake mode status.
12. **CWBKS3**: Integer/Bitfield, a system configuration word from which bit 0 is extracted.
13. **ZT1HDCTBKS**: Boolean, an external or fallback signal for hydro-control system 1.
14. **ZT2HDCTBKS**: Boolean, an external or fallback signal for hydro-control system 2.

## Outputs (Figure 43.18.21)

1.  **B_hdctbks2**: Boolean, activation status for hydro-control brake system 2.
2.  **B_hdctbks1**: Boolean, activation status for hydro-control brake system 1.

(Internal signals like `B_switchbks`, `B_hdctrbks1`, `B_hdctrbks2` are intermediate results, not primary module outputs.)

## Logic Flow (Figure 43.18.21)

The logic flow can be broken down into several stages:

### Stage 1: Primary Brake System Status (`B_switchbks`)
1.  **Inversion of Brake States**: `B_ebks`, `B_wbkse`, and `B_sabte` are each inverted using `NOT` gates. This implies the logic is looking for the *inactivity* or "not active" state of these signals.
2.  **Combined Brake Inactivity**: The three inverted signals are fed into an `AND` gate. The output, `B_switchbks`, becomes true only if `B_ebks` is false AND `B_wbkse` is false AND `B_sabte` is false. This indicates a general "brake system not actively engaged" state.

### Stage 2: Complex Operating Condition (`cond_if`)
1.  **Engine Speed Check**: `nmot_w` (engine speed) is compared to `NMOTHDGCS` (engine speed threshold) using a `>` (greater than) comparator.
2.  **Vehicle Speed Check**: The absolute value of `vdaavst_w` (vehicle speed) is compared to `VDAAGWBKS` (vehicle speed threshold) using a `<` (less than) comparator.
3.  **Differential Pressure Check**: `dmkrhdef_w` (differential pressure) is compared to `DMKRGWBKS` (differential pressure threshold) using a `<` (less than) comparator.
4.  **Master Cylinder Status Inversion**: `B_msvkma` is inverted using a `NOT` gate.
5.  **Intermediate AND Combinations**:
    *   The result of `(nmot_w > NMOTHDGCS)` and `B_gsch` are combined with an `AND` gate.
    *   This result is then combined with `(|vdaavst_w| < VDAAGWBKS)`, `(dmkrhdef_w < DMKRGWBKS)`, and `(NOT B_msvkma)` using another `AND` gate. This final `AND` output is an internal signal labeled `cond_if`, representing a composite condition for hydro-control activation.

### Stage 3: Conditional Signal Selection and Output Generation

This stage determines the final output signals (`B_hdctbks1` and `B_hdctbks2`) based on the extracted bit `CWBKS3` (bit 0), effectively switching between a normal operating mode and fallback modes.

1.  **Configuration Bit Extraction**: Bit 0 is extracted from the `CWBKS3` signal using a `GET BIT` block. This bit acts as the control signal for two identical Simulink Switch blocks.
2.  **First Switch (for `B_hdctbks2`)**:
    *   The top input to this switch is `AND(B_switchbks, cond_if)`.
    *   The control input is `GET BIT (CWBKS3, bit_sel=0)`.
    *   The bottom input is `ZT1HDCTBKS`.
    *   If `GET BIT (CWBKS3, bit_sel=0)` is 0 (false), the switch selects `ZT1HDCTBKS`.
    *   If `GET BIT (CWBKS3, bit_sel=0)` is 1 (true), the switch selects `AND(B_switchbks, cond_if)`.
3.  **Second Switch (for `B_hdctbks1`)**:
    *   The top input to this switch is `AND(B_switchbks, cond_if)`.
    *   The control input is `GET BIT (CWBKS3, bit_sel=0)`.
    *   The bottom input is `ZT2HDCTBKS`.
    *   If `GET BIT (CWBKS3, bit_sel=0)` is 0 (false), the switch selects `ZT2HDCTBKS`.
    *   If `GET BIT (CWBKS3, bit_sel=0)` is 1 (true), the switch selects `AND(B_switchbks, cond_if)`.
4.  **Signal Delay**: The output from each switch is passed through a `Transport Delay` block (V.5.3). This introduces a time delay in the signal propagation, crucial for real-world control systems. The delayed outputs are `B_hdctrbks2` and `B_hdctrbks1`.
5.  **Final Inversion and Output**: Each delayed signal (`B_hdctrbks1`, `B_hdctrbks2`) is then inverted by a `NOT` gate. The result of this inversion is passed through a `cond_if` block (V.6.0), which then sets the final boolean outputs `B_hdctbks1` and `B_hdctbks2`. The `cond_if` block likely ensures valid conditional assignment or further processing before output.

**Overall Summary**: The module coordinates the activation of two hydro-control braking channels. In a "normal" operating mode (controlled by `CWBKS3` bit 0 = 1), both channels activate if the general brake system is inactive and a set of complex operational conditions (engine speed, vehicle speed, pressure, master cylinder status, general switch) are met. In an "alternative" or "fallback" mode (controlled by `CWBKS3` bit 0 = 0), the channels are controlled by independent external signals `ZT1HDCTBKS` and `ZT2HDCTBKS`. All activation signals are delayed and then inverted before becoming the final outputs.

---

**Figure 43.18.22 Overview**

Figure 43.18.22, titled "VSTBKS", appears to be a logic block for calculating various brake pressure setpoints or correction factors. It takes ambient pressure (`pu_w`), nominal pressure (`Normdruck`), multiple system configuration bits (e.g., from `CWBKS`, `CWBKS2`, `CWBKS4`), boolean status signals (`B_ftstok`, `B_fstcanok`, `B_stendz`), and calibration values (`kfflafln_w`) as inputs. It utilizes lookup tables (`KFFLAF`, `KFFLAF4`) and arithmetic operations (sum, max) to determine outputs such as `pbkssum_w`, `prsollind_w`, `pbksinp_w`, and `flafrbks_w`. This diagram's primary function is likely to dynamically calculate and adapt target brake pressures based on environmental conditions and system states.


--- Page 307 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram implements a sophisticated control and coordination logic for a fuel pump (EKP - Elektrokraftstoffpumpe) within a low-pressure fuel system, likely in an automotive application. Its primary function is to calculate various correction factors or compensation values to ensure stable and efficient fuel delivery, particularly addressing transient conditions and environmental influences. The diagram specifically highlights mechanisms to counteract overshoots during system transitions (e.g., startup, operational mode changes, or voltage fluctuations) and to adjust for the fuel pump's efficiency dependence on tank temperature. The output signals represent these individual correction factors that would typically be applied to a base fuel pump demand or duty cycle.

## Inputs

The following are the key input signals to this system:

*   **B_sabte (Boolean)**: A binary signal, possibly indicating an enable or disable state, or a "sabotage" detection as per the German root word.
*   **CWBKS2 (Numeric/Configuration)**: A configuration word or register value used to extract a specific bit (bit 0 in this case) to enable or disable certain logic paths.
*   **tnse_w (Numeric)**: A value likely related to engine speed or a time-dependent signal, used as an input to a lookup table for start overshoot correction.
*   **CWBKS4 (Numeric/Configuration)**: Another configuration word, used similarly to CWBKS2 for bit extraction to enable/disable specific correction paths. Appears twice.
*   **ubsg (Numeric)**: A signal representing a voltage or a duty cycle, used in the voltage correction path.
*   **CWBKS (Numeric/Configuration)**: Another configuration word, used for bit extraction to enable/disable specific correction paths.
*   **UBSOLL (Numeric)**: A target or setpoint value, likely for voltage or fuel pressure, used as an input to a lookup table for efficiency/temperature correction.
*   **tktm (Numeric)**: Tank internal temperature, used as an input to a lookup table for efficiency/temperature correction.
*   **Lookup Table Data (Implicit)**: The internal data (breakpoints and values) for the `KLSKBKS`, `KLUSKBKS`, `KLTTHKBS`, and `KLTTKBKS` lookup tables are also implicit inputs to the system's behavior.

## Outputs

The diagram produces several output signals, which are likely individual correction factors or status flags:

*   **tnsabte (Numeric, Port 2)**: An intermediate value from the anti-overshoot lookup table (`KLSKBKS`), potentially indicating the magnitude of the overshoot.
*   **fsakbks (Numeric, Port 3)**: A fuel pump correction factor, possibly for the anti-overshoot mechanism.
*   **fusbks (Numeric, Port 4)**: A fuel pump correction factor, likely related to the start overshoot correction.
*   **flafabks_w (Numeric, Port 1)**: A conditioned correction factor, derived from `fsakbks`.
*   **flafrbks_w (Numeric, Port 6)**: A conditioned correction factor, derived from `fusbks`.
*   **flafsuesbks_w (Numeric, Port 5)**: A conditioned correction factor, derived from the voltage correction path.
*   **flafrbks_w (Numeric, Port 7)**: Another conditioned correction factor, derived from the efficiency/temperature correction path (note: same name as Port 6 output, but originating from a different source path).
*   **flafubks_w (Numeric, Port 8)**: A conditioned correction factor, also derived from the efficiency/temperature correction path.

## Logic Flow

The system's logic can be broken down into multiple parallel correction paths, each addressing a specific operational aspect of the fuel pump:

1.  **Anti-Overshoot Correction (KLSKBKS Path):**
    *   The `B_sabte` input is inverted by a `NOT` gate.
    *   A bit (bit 0) is extracted from the `CWBKS2` configuration word using a `GET BIT` block.
    *   These two signals (`NOT B_sabte` and the extracted bit from `CWBKS2`) act as an enable signal `E` for a timer block (V.5.5).
    *   The output `y` of the timer, representing an elapsed time or a timed state, becomes `x_val` for the `KLSKBKS` lookup table.
    *   The `KLSKBKS` table (V.7.3) then produces `IP_val`, which is output as `tnsabte` (Port 2) and also multiplied by a constant `1` (implicitly) to yield `fsakbks` (Port 3).
    *   `fsakbks` is finally passed through a "Check ~= 0" block (V.6.6) to produce `flafabks_w` (Port 1).
    *   *Purpose:* This path calculates a correction to reduce fuel pump delivery during a specific transition (e.g., to "SA" mode), preventing an overshoot in the fuel system by potentially modulating the pump output based on time.

2.  **Start Overshoot Correction (KLUSKBKS Path):**
    *   The `tnse_w` signal (from Port 3) serves as `x_val` for the `KLUSKBKS` lookup table (V.7.3), which outputs an `IP_val`.
    *   Separately, a bit (bit 0) is extracted from the `CWBKS4` configuration word.
    *   The `IP_val` from `KLUSKBKS` and the extracted bit from `CWBKS4` are multiplied (V.7.3), resulting in an intermediate signal (labeled `Schubabschaltungskorrektur` - overrun cutoff correction).
    *   This intermediate signal is then multiplied by another factor (likely from the `tnsabte` path via an internal connection not fully detailed), producing `fusbks` (Port 4).
    *   `fusbks` is then processed by a "Check ~= 0" block (V.6.6) to generate `flafrbks_w` (Port 6).
    *   *Purpose:* This path addresses overshoots in the fuel system that can occur after engine start due to the generator pulling up the on-board power supply voltage. It generates a correction factor, possibly based on engine speed or time from start.

3.  **Voltage Correction Path:**
    *   The `ubsg` signal (from Port 5) is multiplied by an intermediate signal (labeled `Spannungskorrektur` - voltage correction) and `tktm`.
    *   A bit (bit 0) is extracted from the `CWBKS` configuration word.
    *   The output of the multiplication (from `ubsg`) and the extracted bit from `CWBKS` are multiplied (V.7.2).
    *   The result is fed into a "Check ~= 0" block (V.6.6), producing `flafsuesbks_w` (Port 5).
    *   *Purpose:* This section computes a correction based on voltage, potentially to compensate for voltage fluctuations affecting pump performance.

4.  **Efficiency/Temperature Correction (KLTTKBKS Path):**
    *   The `UBSOLL` input is provided as `x_val` to the `KLTTKBKS` lookup table (V.7.3).
    *   The `tktm` (tank temperature, from Port 4) is fed as `IP_val` to the same `KLTTKBKS` lookup table. This suggests a 2D lookup table or a way to parameterize the lookup based on temperature.
    *   The output of the `KLTTKBKS` table (`fttkbks`) is then multiplied (V.7.3) by a bit extracted from `CWBKS4` (bit 0). The result is labeled `fttkbks` (Port 6).
    *   This `fttkbks` signal is processed by two separate "Check ~= 0" blocks (V.6.6).
        *   One block outputs `flafrbks_w` (Port 7).
        *   The other block outputs `flafubks_w` (Port 8).
    *   *Purpose:* This path adjusts the fuel pump operation based on its efficiency, which is known to be dependent on the internal tank temperature.

The "Check ~= 0" blocks (V.6.6) generally act as conditional pass-through or filtering mechanisms. They likely output the input signal if it's non-zero (meaning a correction is active and significant) and possibly zero or a default value otherwise. They might also incorporate additional enable conditions or saturation logic depending on their specific implementation.


--- Page 308 ---

This page contains two interconnected Simulink-like diagrams (Figure 43.18.24 and Figure 43.18.25), which are typical for automotive embedded software development. Figure 43.18.25, labeled "HOLDPRES", is a subsystem within Figure 43.18.24, which is part of the "FUSL, Fuel pump low pressure control coordination" module.

## Function

The primary function of this system is to coordinate and control the low-pressure fuel pump operation in a vehicle, specifically focusing on managing conditions for "pressure holding" (`HOLDPRES`) and handling various system states and fault conditions. This includes determining when the fuel pump should be active to maintain pressure, especially in scenarios like engine stop-start, electric-only driving modes (E-drive), and during transitions, while also incorporating safety interlocks (e.g., airbag deployment) and diagnostics for fuel system errors.

## Inputs

The following are the key inputs identified across both diagrams:

*   **`B_sshev`**: System Start/Stop Halted (active/true when the engine is in a stop-start condition).
*   **`B_stendz`**: Standstill End Zone (indicates vehicle is at standstill or leaving it).
*   **`B_nmot`**: Engine Speed Not Zero (indicates engine is running or requested to run).
*   **`B_kl15_dly`**: Ignition (Terminal 15) Delayed (status of ignition, possibly with a delay).
*   **`B_tgsabks`**: Fuel Cut-off Active (indicates an active fuel cut-off request).
*   **`B_airbag`**: Airbag Deployment Status (safety critical input).
*   **`B_ebks`**: Electrically Controlled Braking System Status (may influence fuel pump operation, especially in hybrid/EVs).
*   **`B_dhbks_prev`**: Previous state of Fuel Pressure Holding (for latching or state machine logic).
*   **`B_lgsabks_prev`**: Previous state of Low Pressure Fuel Pump Activation Request (for feedback/latching).
*   **`B_efahr_w`**: E-Drive Active (indicates the vehicle is in electric-only driving mode).
*   **`IP_val`**: An intermediate process value, likely a sensor reading or internal calculation.
*   **`CWBKS3`, `CWBKS`, `CWBKS5`**: Configuration Word/Bit Stream (used to extract specific flags or parameters for diagnostics and control logic, e.g., error handling, E-drive corrections).
*   **`TDHSET`**: Time Delay Hold Setpoint (timer threshold for pressure holding initiation).
*   **`TDHWAIT`**: Time Delay Hold Waitpoint (timer threshold for pressure holding duration/termination).
*   **`flafehdr_w`**: Error Flag from Driving Dynamics (indicates an error related to vehicle dynamics).
*   **`anzvrdynaw`**: Display Front Dynamics Active (likely a request or status for front-end dynamic control).
*   **`B_pbksprof`**: Pressure Profile Selection (related to different pressure holding characteristics).
*   **Constants**: -1, 0, 100 (numerical constants used in lookup tables or scaling).

## Outputs

The following are the key outputs generated by the system:

*   **`B_lgsabks`**: Low Pressure Fuel Pump Activation Request (the primary output to activate the fuel pump).
*   **`B_dhbks`**: Fuel Pressure Holding Status (indicates if the pressure holding function is active).
*   **`B_timeondh`**: Time On Delay Hold (the current value of the pressure holding timer).
*   **`B_ekpdh`**: Fuel Pump Pressure Holding Enable (an enable signal for the fuel pump specific to pressure holding).
*   **`flafebks_w`**: Error Flag Fuel System Electric Pump Control (indicates errors related to the electric fuel pump control).
*   **`flafobks_w`**: Fuel Pump Active Flag from Error State (indicates fuel pump activation due to an error).
*   **`flafdhbks_w`**: Error Flag from Pressure Holding (indicates errors during the pressure holding function).
*   **`flafahr_w`**: Error Flag from Start-up (indicates errors during engine start-up).
*   **`oflafbks_w`**: Offset Fuel Pump from Error State (an offset or corrected value derived from error conditions).
*   **`tno_val`**: Timer No Value (a general timer output).
*   **`x_x_val`**: An x-axis value, possibly for a lookup table or diagnostic output.

## Logic Flow

The system's logic can be broken down into the overall coordination (Figure 43.18.24) and the detailed pressure holding (Figure 43.18.25 - HOLDPRES subsystem).

### 1. Overall Coordination (Figure 43.18.24 - KORBKS2)

*   **Initialization and Pre-conditions**: Various inputs like `B_efahr_w` (E-drive active), `B_dhbks_prev` (previous pressure hold state), and `B_ebks` (e-brake status) are processed through logical gates (NOT, OR) to set up enabling conditions for internal timers and logic.
*   **Pressure Holding Subsystem (`HOLDPRES`)**: This critical subsystem processes a set of fundamental conditions (see Step 2 below) and outputs `B_lgsabks` (low pressure pump request) and `B_dhbks` (pressure holding status).
*   **Error and Configuration Processing**:
    *   Multiple `CWBKSx` blocks (Configuration Word/Bit Stream) are used with `GET BIT` blocks to extract specific bits (`bit_sel = 0`) from configuration words. These bits often represent error flags, diagnostic status, or control parameters.
    *   For example, one branch extracts a bit from `CWBKS3` and checks if it's non-zero (`Check ~= 0`) to generate `flafebks_w` (Error Fuel Pump Control).
    *   Another branch uses `CWBKS` to identify "fuel system relevant errors" and apply "E-drive operation correction for pressure holding", feeding into a `max` block and ultimately `flafobks_w`.
    *   Further error handling and dynamic corrections are implemented using `anzvrdynaw` (front dynamics) and `B_pbksprof` (pressure profile) with `FLAFEBKS` blocks, contributing to `oflafbks_w` and `B_flafobks`.
*   **Timer and State Management**:
    *   A timer block (V.5.5, with clock symbol) is enabled by an `OR` gate (V.6.3) which combines `NOT B_efahr_w` and a `NOT` of the timer's output (`tno_val`). The `R` input (reset) of the timer is controlled by a separate branch, suggesting it's a "timer-on delay" or "timer-off delay" with reset capability.
    *   A lookup table (V.5.4, with 'T' and 'L' axes) is used to map an input (`u`) to an output (`y`), possibly for dynamic pressure values or operational thresholds.
*   **Final Output Determination**: The outputs from the `HOLDPRES` subsystem, error flags, and timer states are combined through logical operations and switches to determine the final operational commands for the fuel pump. For instance, `B_lgsabks` is influenced by `B_dhbks` (from `HOLDPRES`) and other error/enable conditions.

### 2. Pressure Holding Subsystem (Figure 43.18.25 - HOLDPRES)

This subsystem meticulously calculates the `B_lgsabks` (low pressure pump activation request) and `B_dhbks` (pressure holding status).

*   **Initial Pressure Holding Conditions**:
    *   A series of conditions are evaluated and combined by a large `AND` block (V.5.4):
        *   `B_sshev` (Start/Stop active) is TRUE.
        *   `B_stendz` (Standstill End Zone) is FALSE (meaning vehicle is moving or about to move).
        *   `B_nmot` (Engine Speed Not Zero) is FALSE (meaning engine is off).
        *   `B_kl15_dly` (Ignition Delayed) is TRUE.
        *   `B_tgsabks` (Fuel Cut-off Active) is FALSE.
        *   `B_ebks` (E-Braking Active) is FALSE.
        *   `B_airbag` (Airbag Deployed) is FALSE (safety interlock).
    *   The output of this `AND` block forms a core condition for enabling pressure holding.

*   **Pressure Holding State Latch/Timer**:
    *   The core condition from the `AND` block feeds into a Set-Reset Latch-like block (V.5.3, with `u` and `y` inputs/outputs).
    *   `B_dhbks` (the previous pressure holding state) feeds into an `OR` gate (V.6.3) whose output controls the `R` (reset) input of this latch/timer. This implies that the pressure holding state can be latched on and reset under specific conditions.
    *   The output `y` from this block influences `B_lgsabks`.

*   **Time-based Control for `B_timeondh`**:
    *   A timer block (V.5.3, with clock symbol) is enabled (`E` input) by an `OR` gate. This `OR` gate's inputs include the output `y` from the latch and a combination of `NOT B_efahr_w` and `B_dhbks_prev`.
    *   The timer's output (`y`) is then compared with `TDHSET` and `TDHWAIT` values using `<` and `>` blocks.
    *   These comparisons, combined with other logical conditions, determine the final `B_timeondh` output, which signals the duration for which pressure holding is active.

*   **Error Management for Pressure Holding**:
    *   `CWBKS3` and `CWBKS` (configuration words) are used with `GET BIT` blocks (`bit_sel = 0`) to derive specific flags.
    *   `FLAFDH` (Error from Pressure Holding) and `FLAFAR` (Error from Start-up) blocks process these flags along with other inputs (`flafehdr_w`, `B_efahr_w`) to generate error signals `flafdhbks_w` and `flafahr_w`.
    *   An `AND` block combines these error-related signals and other conditions (including a switch `Check ~= 0` for `FLAFDL`) to determine `B_ekpdh` (Fuel Pump Pressure Holding Enable).

*   **Final Output Generation**: The `B_lgsabks` (low pressure pump activation request) is the result of intricate logical combinations involving the initial pressure holding conditions, the latched pressure holding state, timer logic, and various error flags. `B_dhbks` reflects the current state of pressure holding based on these evaluations.


--- Page 309 ---

This page contains a Simulink diagram.

## Function

The primary function of this Simulink diagram is to control and coordinate the operation of the Electric Fuel Pump (EKP) specifically for the auxiliary heater (Standheizung) system in an automotive application. It evaluates a multitude of conditions, including driver requests, vehicle states (e.g., ignition, engine status, hood status, brakes, airbag), safety interlocks, and feature enables. The system ensures the fuel pump is activated only when all prerequisites are met and handles handshake signals and status updates for diagnostic and control purposes. The lower subsystem, "CHKHTG," is responsible for generating the core auxiliary heater request signal.

## Inputs

The diagram takes numerous inputs, reflecting the complex interdependencies in an automotive system:

*   **CWPRDRVENA**: Auxiliary heater pump enable/request signal.
*   **AuxHtg_bFIPmpReq**: Auxiliary heater fuel pump request (generated by the CHKHTG subsystem and used by the main logic).
*   **B_edbks (10)**: Brake active status (Boolean).
*   **B_htg (3)**: Auxiliary heater active status (Boolean, output from CHKHTG subsystem).
*   **B_airbag (6)**: Airbag deployment status (Boolean).
*   **B_kl15_dly (8)**: Delayed ignition (KL15) status (Boolean).
*   **B_nmot (5)**: Engine not running status (Boolean).
*   **Hood Open (13)**: Hood open sensor status (Boolean).
*   **B_hoodopnok (12)**: Hood open not OK status (Boolean).
*   **NLC_EFP_PROD_FEAT_ON**: Feature enable for the Electric Fuel Pump (Boolean).
*   **TEONEKPENA**: Total engine runtime activation condition for EKP (Boolean).
*   **CWPRDRV**: (Input to GET BIT blocks) Likely a status word or configuration related to driving conditions.
*   **TEZSHADEKP**: Time for EKP shade/delay (for CHKHTG subsystem).
*   **TEKPAPSDH**: EKP activation period for auxiliary heater (for CHKHTG subsystem).
*   **pbksadr_w (4)**: Some weighted input related to braking.
*   **flafobks_w (9)**: Another weighted input, possibly related to braking or fuel level.
*   **PSPCTL_PSPACTIV**: Previous state of EKP activity.
*   **PSPCTL_AUXHEATERRO**: Auxiliary heater error status.
*   **PspCtl_stFIPmpAct (6)**: Current status word for fuel pump activity (used for reading and updating bits).
*   **KF_EK_SH (X_val, Y_val)**: Lookup table inputs for EKP characteristic curves.
*   **KFFLAF4WD (X_val, Y_val)**: Lookup table inputs for specific curves, possibly 4WD-related or fuel level.

## Outputs

The diagram generates several outputs that indicate the status, control activation, and provide handshake signals:

*   **B_epdekp (5)**: EKP disable/enable status (Boolean).
*   **B_shtmp100 (4)**: Handshake signal for auxiliary heater temporary condition (Boolean).
*   **B_ekpoksn15 (1)**: EKP status related to N15 (likely an internal EKP state or component).
*   **B_ekposf (2)**: EKP status related to 'F' (likely an internal EKP state or component).
*   **tvadbks_w (7)**: A computed value, likely related to braking or throttle valve adaptation.
*   **flafhbks_w (2)**: A computed value, possibly related to fuel level or a specific braking function.
*   **PspCtl_stFIPmpAct (6)**: Updated status word for fuel pump activity, with bits indicating EKP active and EKP previously active states.
*   **B_htg (1)**: Auxiliary heater active signal (Boolean, output from CHKHTG subsystem).

## Logic Flow

The logical flow can be broken down into two main parts: the CHKHTG subsystem (which generates the core request) and the main "Standheizung" logic (which processes this request and other conditions).

**Part 1: CHKHTG Subsystem (1.7.6.1 CHKHTG)**

1.  **Request Generation**:
    *   The `AuxHtg_bFIPmpReq` (likely an internal trigger or CAN request) and `TEZSHADEKP` are fed into a Timer block (`T`), which might implement a delay or pulse generation.
    *   The output of this timer, along with status bits retrieved from `CWPRDRV` via `GET BIT` blocks, acts as set (`S`) and reset (`R`) inputs for a Flip-Flop (`FF`) block. This creates a latched request for the auxiliary heater.
    *   Another timer (`T`) and an `E` block use `TEKPAPSDH` to create a timed condition.
2.  **Output Gating**:
    *   The `Q` output of the Flip-Flop is negated (`NOT`) and combined with the timed condition from `TEKPAPSDH` and other status bits (from `GET BIT` blocks) in an `AND` gate.
    *   The result then passes through a conditional switch (`Check ~= 0`) to produce the final `B_htg` output, indicating if the auxiliary heater is actively requesting operation.

**Part 2: Main Standheizung Logic (43.18.7.6 Standheizung)**

1.  **Initial Enable Check**:
    *   The `CWPRDRVENA` signal (auxiliary heater pump enable) is compared to 0. If `CWPRDRVENA` is greater than 0, it sets a condition (`cond_if`) that influences subsequent logic, potentially enabling the entire control path.
2.  **Safety Interlocks & Operational Conditions**:
    *   **Brake/Heater Condition**: `B_edbks` (brakes active) OR `B_htg` (auxiliary heater active, from CHKHTG) is negated (`NOT`). This means *neither* brakes nor heater should be active for certain paths, or a specific condition must be met.
    *   **Vehicle Status Interlocks**: `B_airbag`, `B_kl15_dly`, and `B_nmot` are all negated (`NOT`) and combined in an `AND` gate. This enforces conditions like "airbag NOT active", "ignition (KL15) NOT delayed", and "engine NOT running" for activation.
    *   **Hood Status**: `Hood Open` and `B_hoodopnok` are checked, likely to ensure the hood is closed.
    *   **EKP Feature Enable**: `NLC_EFP_PROD_FEAT_ON` acts as a master enable for the electric fuel pump.
    *   **Engine Runtime Enable**: `TEONEKPENA` provides a condition based on total engine runtime.
    *   These numerous conditions, along with signals derived from `CWPRDRV` (via `GET BIT` blocks), are intricately combined using `AND` gates and switches.
3.  **Fuel Pump Request Integration**:
    *   The `AuxHtg_bFIPmpReq` signal (generated by the CHKHTG subsystem) is a key input into this complex decision-making tree, determining if a fuel pump request from the auxiliary heater is present.
4.  **Handshake and Status Signals**:
    *   `B_epdekp` (EKP disable/enable) and `AuxHtg_bFIPmpReq` are used to generate `B_shtmp100`, which serves as a handshake signal, likely acknowledging or coordinating the auxiliary heater request with the EKP.
    *   Further logic, involving `PSPCTL_PSPACTIV` (previous EKP active status) and `PSPCTL_AUXHEATERRO` (auxiliary heater error), determines specific EKP control signals like `B_ekpoksn15` and `B_ekposf`.
5.  **Lookup Table Operations**:
    *   Inputs `pbksadr_w` and `flafobks_w`, possibly combined with other values, are fed into 2D lookup tables (`KF_EK_SH`, `KFFLAF4WD`). These tables likely define desired EKP characteristics or values based on operating points.
    *   The outputs of these lookup tables (`tvadbks_w`, `flafhbks_w`) are passed through conditional switches (`Check ~= 0`).
6.  **Status Bit Management**:
    *   The system reads the current state of `PspCtl_stFIPmpAct` (fuel pump activity status) using `GET BIT` blocks.
    *   Based on current conditions, specific bits in `PspCtl_stFIPmpAct` are updated using `SET BIT` blocks: Bit 0 is set for "EKP active," and Bit 1 is set for "EKP was active."
    *   These updated bits are merged back into `PspCtl_stFIPmpAct`, providing a persistent status for the EKP.


--- Page 310 ---

This page clearly contains a Simulink diagram.

## Function
The primary function of this Simulink diagram, titled "FUSL, Fuel pump low pressure control coordination" and featuring the "PROTECTEKP" subsystem, is to manage the operation and protection of the Electric Fuel Pump (EKP) within a vehicle's low-pressure fuel system. It determines when the EKP should be activated (turned ON/OFF) and controls its output (likely speed or pressure via PWM), based on various vehicle operating conditions, safety interlocks, driver inputs (e.g., brake), and internal protection mechanisms. The "PROTECTEKP" subsystem specifically suggests implementation of fault monitoring and safe operating envelopes for the EKP.

## Inputs
The system receives a wide range of inputs, including:

**Boolean/Status Inputs:**
*   `B_nmot`: Engine running status (e.g., engine speed > 0).
*   `B_rqt_bks`: Request from brake system.
*   `B_switchbks`: Brake switch status.
*   `B_kl15_dly`: Delayed ignition (KL15) signal.
*   `B_stend`: Engine standstill detection.
*   `B_ekp`: Current status/command of the Electric Fuel Pump.
*   `B_erdbksy`: Ground status for the brake system.
*   `B_kl15`: Ignition (KL15) signal.
*   `efp_prod_feat_off`: Feature flag for EFP production feature being OFF.
*   `NLC_EFP_PROD_FEAT_ON`: Feature flag for EFP production feature being ON.
*   `Hood Open`: Status of the hood (open/closed).
*   `Dspl_bHoodOprnNoDeb`: Debounced hood open signal.
*   `tkl15bks_prev`: Previous state of KL15 for brake system (likely for edge detection or delay).
*   `tmsst`: Timer for motor start.

**Numeric/Analog Inputs:**
*   `ubsq`: Engine speed or similar rotational input.
*   `pksbskr_w`: Brake system pressure or related measured value.
*   `pbkist_w`: Actual pressure value.
*   `B_tal`: Ambient temperature or fluid temperature.
*   `CWPRDRV`: Calibration word or bitmask for drive conditions.
*   `tstart_ekp_init`: Timer for EKP initialization during engine start.
*   `KLUBSTBKS`: Calibration value for EKP start operation.
*   `T_P_val`: Temperature/pressure value for EKP control.
*   `PWM_MMN`: Minimum Pulse Width Modulation (PWM) value for EKP control.
*   `prist_w`: Actual pressure value (similar to pbkist_w, possibly redundant or distinct purpose).

## Outputs
The system produces several outputs that indicate status, protection state, and control commands for the EKP:

**Boolean Outputs:**
*   `B_ekponbks`: (Output 5) Main command to enable/disable the Electric Fuel Pump.
*   `B_ekpsv`: (Output 4) EKP protection status or validity.
*   `B_aekpsh15`: (Output 18) EKP active at KL15 status.
*   `B_rqtbksvld`: (Output 17) Validity of the brake system request.
*   `B_tgskbks`: (Output 15) Status related to "TGS" (possibly "TeilGetriebeSteuerung" - partial transmission control, or similar) brake system.
*   `B_ekpstbks`: (Output 13) EKP start condition for brake system.

**Numeric Outputs:**
*   `lepwmbs_w`: (Output 3) Pulse Width Modulation (PWM) control value for the Electric Fuel Pump.
*   `flafcbks_w`: (Output 4) Flow activation factor or similar, related to brake system. (Note: Output 4 is used for both a boolean and numeric value, suggesting either a bus or distinct signals for different contexts).
*   `arqtbks_w`: (Output 15) Requested brake torque for EKP operation.
*   `flafs_bks_w`: (Output 14) Flow activation factor or similar, related to brake system.
*   `flafhbks_w`: (Output 19) Flow activation factor for heating or start-up.

## Logic Flow

The logical flow of the system can be broadly divided into two main control paths: one for enabling/disabling the EKP and another for controlling its PWM output.

**1. EKP Enable/Disable Logic (`B_ekponbks`):**
*   **Feature Management:** The `NLC_EFP_PROD_FEAT_ON` flag and `efp_prod_feat_off` determine if specific production features for the EKP control are active. This leads to conditional logic paths.
*   **Overall Activation:** A "Total engine runtime activation condition" (`TECNEKPEAN`) is generated, possibly based on engine running time and other criteria. This is a crucial enabling condition.
*   **Safety Interlocks and Driver Demands:**
    *   The hood status (`Hood Open`, `Dspl_bHoodOprnNoDeb`) is checked. An open hood might disable the EKP for safety.
    *   Ignition status (`B_kl15`, `B_kl15_dly`) is monitored to ensure the EKP only operates when the vehicle is powered on. `tkl15bks_prev` provides historical ignition data.
    *   Brake system requests (`B_rqt_bks`, `B_switchbks`) and engine speed (`B_nmot`, `ubsq`) are evaluated through logical AND/OR gates, potentially to validate brake requests or ensure EKP operation under specific braking/engine conditions (e.g., engine off, brakes applied). A `B_rqtbksvld` signal is derived.
    *   The `PGZUENDKBS` block processes pressure and brake switch signals, providing an output indicative of certain brake system states. The `TGSARBKS` block processes KL15 states for brake system related logic.
*   **Protection Subsystem Integration:** The `PROTECTEKP` subsystem processes a wide array of inputs (brake switch, pressures, engine standstill, temperatures, KL15 delay) to generate several boolean outputs (`B_dbvhdo` through `B_dsbsks`). These outputs likely represent various protection states or fault flags for the EKP (e.g., overheating, overpressure, sensor faults).
*   **Final EKP ON/OFF Decision:** All these conditions (total activation, safety interlocks, driver demands, and protection states) are combined through a series of logical OR and AND gates. Many "Check ~= 0" blocks are used to convert numerical states to boolean "true" if non-zero. The outputs from `PROTECTEKP` are merged, some potentially inverted (using NOT gates), and then logically combined with other signals. The final AND gate determines the `B_ekponbks` output, meaning the EKP is enabled only if all essential conditions are met and no critical protection fault is active.

**2. EKP PWM Control Logic (`lepwmbs_w`):**
*   **Start-Up Demand:** `tstart_ekp_init` (EKP start timer) and `KLUBSTBKS` (EKP start conditions) contribute to the initial demand for the EKP. `KLUBSTBKS` also generates `flafhbks_w` and a P-value (likely a pressure setpoint or demand). A `MAX` block selects the higher of these two values, indicating the peak demand during start-up.
*   **Pressure/Temperature and Minimum PWM:** `T_P_val` (temperature/pressure) and `PWM_MMN` (minimum PWM) are inputs to this path. This suggests that the EKP's PWM is adjusted based on thermal/pressure requirements and has a calibrated minimum operating level.
*   **Request Signals:** `arqtbks_w` and `flafs_bks_w` are generated, likely representing requested brake torque and another flow activation factor, which feed into the PWM determination.
*   **Output Limiting:** The various demand signals are fed into a "Limit" block. This block clamps the calculated PWM value (`u`) between defined minimum (`MN`) and maximum (`MX`) limits, ensuring the EKP operates within its safe and effective operating range. The output of this block is `lepwmbs_w`, the final PWM command for the EKP. `flafcbks_w` is also generated here, possibly related to a specific flow demand for the brake system.


--- Page 311 ---

This page contains a Simulink diagram.

## Function

This Simulink diagram implements the "Fuel pump low pressure control coordination" logic. Its primary function is to monitor various vehicle system states and sensor inputs related to the brake system, ignition, and fuel system pressure/levels to generate critical control and safety signals for the electric fuel pump (EKP). It ensures the safe operation of the fuel pump by establishing interlocks, shutdown conditions, and enabling logic based on specific operational parameters and fault detections.

## Inputs

The key inputs to this system are:

1.  **`B_switchbks`**: Boolean, likely indicating the status of a brake system switch or safety switch.
2.  **`prist_w`**: Word, a pressure or status value, potentially an initial or reference state.
3.  **`PQGBVDHDO`**: Parameter/constant, a threshold value for comparison.
4.  **`pksbksr_w`**: Word, a pressure or status value related to the brake system.
5.  **`PGBTSBKS`**: Parameter/constant, a threshold value for comparison.
6.  **`pbkist_w`**: Word, a pressure or status value, possibly related to pump-brake interaction.
7.  **`PBKSESA`**: Parameter/constant, a threshold value for comparison.
8.  **`CWBKS2`**: Control Word for Brake System 2, a multi-bit status or command word.
9.  **`bit_sel`**: Integer, specifies which bit to extract from a control word.
10. **`num_dec`**: Integer, another parameter for the `GET BIT` block, possibly a bit count or offset.
11. **`B_kl15_dly`**: Boolean, a delayed ignition (Kl15) signal, indicating the engine is running or ignition is on.
12. **`TWKSABKS`**: Parameter/constant, likely a brake system status or threshold.
13. **`B_bkspae`**: Boolean, indicating "Brake System Pump Active Enable".
14. **`CWBDCH`**: Control Word, potentially related to a specific valve or component status.
15. **`B_erdbksy`**: Boolean, possibly an "earth brake system" or ground fault status.
16. **`B_tal`**: Boolean, likely related to fuel tank level or another tank-related status.

## Outputs

The key outputs generated by this system are:

1.  **`B_dbvhdo`**: Boolean, indicating detection of a fuel pump valve open/hold condition.
2.  **`B_stend`**: Boolean, representing a fuel pump "stand" or stable state.
3.  **`B_btsbksn`**: Boolean, related to brake system tank suction or status.
4.  **`B_dsbbksset`**: Boolean, a signal to set or disable the brake system.
5.  **`B_ekposfr`**: Boolean, the "Electric Fuel Pump Safety Shutdown Request," a critical safety signal.
6.  **`B_ekpoksa`**: Boolean, an intermediate "Electric Fuel Pump Operating Condition A".
7.  **`B_ekpoksaa`**: Boolean, the final "Electric Fuel Pump Operating Condition AA," likely the ultimate enable signal for the fuel pump.

## Logic Flow

The logic can be broken down into several parallel and sequential paths, each contributing to different output signals:

1.  **Path for `B_dbvhdo` (Fuel Pump Valve Open/Hold Detection):**
    *   The `B_switchbks` input is compared against `prist_w`.
    *   If `B_switchbks` is greater than `prist_w`, the output of this comparison triggers a "T" block (likely a pulse generator or rising-edge detector).
    *   The output of the "T" block directly produces `B_dbvhdo`.

2.  **Path for `B_stend` (Fuel Pump Standby/Stable State):**
    *   `B_switchbks` is compared against `PQGBVDHDO`.
    *   `pksbksr_w` is compared against `PGBTSBKS`.
    *   The results of these two comparisons (both `>`) are fed into an OR-like gate (`v` symbol). The output of this OR gate acts as the Set (`S`) input for an SR Flip-Flop (`FF`).
    *   `B_switchbks` directly controls the Reset (`R`) input of this `FF`.
    *   The Q output of this `FF` is `B_stend`. This logic creates a latched "standby" state based on two pressure/switch conditions, which can be reset by `B_switchbks`.

3.  **Path for `B_btsbksn` (Brake System Tank Suction/Status):**
    *   `pbkist_w` is compared against `PBKSESA`.
    *   If `pbkist_w` is less than `PBKSESA`, the output of this comparison triggers another "T" block.
    *   The output of this "T" block is `B_btsbksn`. This signal indicates a condition related to low pressure or a specific state in the pump/brake system.

4.  **Path for `B_dsbbksset` (Brake System Disable/Set):**
    *   A specific bit is extracted from `CWBKS2` using `bit_sel` and `num_dec` in a `GET BIT` block.
    *   This extracted bit feeds a "T" block.
    *   The output of this "T" block is then ANDed with the `B_kl15_dly` (delayed ignition) signal.
    *   The result of this AND operation is `B_dsbbksset`, indicating a command to set/disable the brake system under specific conditions.

5.  **Path for `B_ekposfr` (Electric Fuel Pump Safety Shutdown Request):**
    *   A specific bit is extracted from `CWBDCH` using `bit_sel` and `num_dec` in a `GET BIT` block.
    *   This extracted bit is inverted by a NOT gate.
    *   `B_switchbks` is checked to see if it is not equal to zero (`~= 0`).
    *   The inverted extracted bit and the result of `B_switchbks ~= 0` are ANDed together.
    *   The output of this AND gate is `B_ekposfr`. The nearby German comment confirms this is a "Safety shutdown of the EKP (electric fuel pump) if BDV opens and a fuel hose is torn off," implying the extracted bit from `CWBDCH` (after inversion) relates to BDV or hose status.

6.  **Path for `B_ekpoksa` (Electric Fuel Pump Operating Condition A):**
    *   This path combines conditions from two different sub-paths related to `B_dsbbks` logic:
        *   **Sub-path 6.1 (Leftmost `B_dsbbks` derivation):**
            *   The output of the "T" block (from the `CWBKS2` bit extraction, as described in point 4) is inverted by a NOT gate. This `NOT` signal resets (`R`) an SR Flip-Flop.
            *   `B_kl15_dly` (delayed ignition) acts as the Set (`S`) input for this FF.
            *   The Q output of this FF, labeled `B_dsbbks`, indicates a brake system disable status (latched by ignition, reset by CWBKS2 bit). This `B_dsbbks` signal is then delayed by `B_dsbbks_dly`.
        *   **Sub-path 6.2 (Lower Middle `B_dsbbks` derivation):**
            *   `TWKSABKS` is checked if it is not equal to zero (`~= 0`). This triggers a "T" block.
            *   The output of this "T" block is ANDed with the inverted `B_kl15_dly` (delayed ignition). This results in another signal *also* labeled `B_dsbbks`.
        *   **Combination for `B_ekpoksa`:**
            *   The delayed `B_dsbbks` (from Sub-path 6.1) and the `B_dsbbks` signal (from Sub-path 6.2) are fed into an OR-like gate (`v` symbol). This suggests `B_ekpoksa` is set if *either* of these brake system disable conditions are met. The output of this OR gate acts as the Set (`S`) input for another SR Flip-Flop.
            *   `B_ekposfr` (the safety shutdown request) acts as the Reset (`R`) input for this FF.
            *   The Q output of this FF is `B_ekpoksa`, indicating an operating condition for the fuel pump that is set by brake system states and reset by the overall safety shutdown.

7.  **Path for `B_ekpoksaa` (Electric Fuel Pump Operating Condition AA):**
    *   `B_erdbksy` is inverted by a NOT gate.
    *   `B_tal` is inverted by a NOT gate.
    *   `B_ekpoksa` (from the previous path), `NOT B_erdbksy`, and `NOT B_tal` are all ANDed together.
    *   The final output of this AND gate is `B_ekpoksaa`. This signal represents the ultimate enabling condition for the fuel pump, requiring `B_ekpoksa` to be true and both `B_erdbksy` and `B_tal` (e.g., ground fault or tank level issues) to be false.


--- Page 336 ---

This page contains a Stateflow diagram, which is a component commonly used within Simulink for designing and simulating state-based logic in automotive systems.

## Function

This Stateflow diagram implements a **Fuel Pump Low Pressure Diagnosis** system, specifically focusing on the detection and management of Short Circuit to Ground (SCG) failures in an Electric Fuel Pump (EFP) and the availability of feedback from its control unit. Its primary function is to track the diagnostic state of the EFP based on fault conditions and feedback status, leading to different `STATE_EFPWM_FB` values representing various stages of fault detection, recognition, and recovery.

## Inputs

The diagram implicitly uses several inputs and internal conditions to trigger state transitions and manage its operation:

*   **`reset` / `FMY reset`**: A system-wide reset signal that forces the state machine to its initial state.
*   **SCG Failure Detection Status**: A boolean input indicating whether a Short Circuit to Ground failure has been detected.
*   **EFP Control Unit Feedback Status**: A boolean input indicating whether failure feedback from the Electric Fuel Pump control unit is currently possible/available.
*   **`t_PWM` time reached**: A timer or timeout condition that triggers a state transition after a specified duration.
*   **`ACTION_FARM_GetPermission(NC_FID_EFPWM_FB)`**: A function call determining if permission is granted for the EFPWM feedback error, which influences the diagnostic system's activation.
*   **`VB` (System Voltage)**: The current system voltage, used to determine if it's above a minimum threshold.
*   **`C_VB_MIN_EFPWM_VB`**: A constant representing the minimum voltage threshold required for the diagnostic system to be active.
*   **Internal Timers/Flags**: Implied by the text (e.g., `T_EFPWM_ECU`, `T_EFPWM_FB`, `LV_EFPWM_FB_VLD`), which are initialized and likely used in transition conditions not explicitly shown on the arrows (T1-T9).

## Outputs

The main explicit output of this state machine is:

*   **`STATE_EFPWM_FB`**: An integer value (0, 1, 2, 3, or 4) representing the current diagnostic state of the Electric Fuel Pump.
    *   **0**: No SCG failure detected.
    *   **1**: SCG failure detected, EFP control unit feedback possible.
    *   **2**: No SCG failure detected, EFP control unit feedback still possible (likely a recovery or monitoring state).
    *   **3**: SCG failure detected or `t_PWM` time reached, failure feedback recognized.
    *   **4**: SCG failure detected, no EFP control unit feedback possible.
*   **`ERR_EFPWM_FB`**: An error status variable, initialized to `FFH` (hexadecimal), which likely reflects the detected fault status. Its value will be updated based on the `STATE_EFPWM_FB`.

## Logic Flow

The state machine operates with a recurrence of 20 ms and proceeds as follows:

1.  **Initialization:**
    *   Upon a `reset` or `FMY reset`, the system always transitions to `STATE_EFPWM_FB=0`.
    *   All relevant internal variables (`ERR_EFPWM_FB`, `STATE_EFPWM_FB`, `T_EFPWM_ECU`, `T_EFPWM_FB`, `LV_EFPWM_FB_VLD`) are reset to their default values (e.g., `STATE_EFPWM_FB` to `0H`).
    *   The diagnostic system is activated only when `LV_INH_ERR_EFPWM_FB` is false (meaning permission is granted via `ACTION_FARM_GetPermission`) AND the system voltage `VB` is above `C_VB_MIN_EFPWM_VB`. Upon deactivation, the state machine is initialized once.

2.  **State 0: No SCG Failure Detected (`STATE_EFPWM_FB=0`)**
    *   This is the initial and nominal operating state where no fault is present.
    *   **Transition to State 1 (T1):** If an SCG failure is detected AND feedback from the EFP control unit is possible, the system moves to `STATE_EFPWM_FB=1`.
    *   **Transition to State 4 (T8):** If an SCG failure is detected BUT no feedback from the EFP control unit is possible, the system moves to `STATE_EFPWM_FB=4`, indicating a more severe fault where communication is also affected.

3.  **State 1: SCG Failure Detected, Feedback Possible (`STATE_EFPWM_FB=1`)**
    *   In this state, an SCG fault is active, but the EFP control unit is still providing diagnostic feedback.
    *   **Transition to State 0 (T2):** If the SCG failure clears, the system can return to the normal operating state `STATE_EFPWM_FB=0`.
    *   **Transition to State 2 (T3):** If the SCG failure clears, it might transition to `STATE_EFPWM_FB=2`, possibly for continued monitoring after the fault.
    *   **Transition to State 3 (T4):** If the SCG failure persists OR a `t_PWM` timeout is reached, the system transitions to `STATE_EFPWM_FB=3` to officially "recognize" the failure feedback.
    *   **Transition to State 4 (T9):** If, while in State 1, the EFP control unit suddenly stops providing feedback (while SCG persists), the system moves to `STATE_EFPWM_FB=4`.

4.  **State 2: No SCG, Feedback Possible (`STATE_EFPWM_FB=2`)**
    *   This state seems to be a transient or monitoring state, typically reached after an SCG fault has cleared, but the system is still confirming stable operation.
    *   **Transition to State 1 (T3, T5):** If an SCG failure is detected again, the system transitions back to `STATE_EFPWM_FB=1`.
    *   **Transition to State 0 (T6):** If conditions remain clear (no SCG detected and feedback possible), the system fully recovers to `STATE_EFPWM_FB=0`.

5.  **State 3: SCG Detected, Feedback Recognition (`STATE_EFPWM_FB=3`)**
    *   In this state, the SCG failure has been detected and formally "recognized," potentially after a confirmation period (e.g., `t_PWM` timeout).
    *   **Transition to State 1 (T5):** If the SCG condition changes such that it's still detected but needs to be re-evaluated or handled as a persistent fault with feedback, it can transition back to `STATE_EFPWM_FB=1`.

6.  **State 4: SCG Detected, No Feedback Possible (`STATE_EFPWM_FB=4`)**
    *   This is a critical fault state where an SCG is detected, and the EFP control unit is unable to provide feedback, indicating a potentially more severe communication or hardware issue.
    *   **Transition to State 1 (T7):** If feedback from the EFP control unit becomes possible again, the system moves to `STATE_EFPWM_FB=1` to process the SCG fault with restored communication.
    *   **Self-loop (T8):** If the SCG failure persists and feedback remains impossible, the system stays in `STATE_EFPWM_FB=4`.

This state machine effectively manages the diagnostic process for an EFP's SCG faults, distinguishing between faults where feedback is available and those where it is not, and including pathways for recovery and formal recognition of faults.


--- Page 352 ---

This page contains a Simulink-like diagram, likely a code-generated representation from a model-based design environment, depicting a diagnostic function for a fuel pressure damper.

## Function

The primary function of this system is to **diagnose the health of a fuel pressure damper** by detecting deviations between the measured fuel pressure and its filtered (damped) value. It uses a digital low-pass filter to smooth the measured signal and then compares this smoothed value with the raw measured value. If the absolute difference exceeds a predefined threshold, a potential fault in the fuel pressure damper is identified, and an error status is set after an anti-bounce (debouncing) mechanism.

## Inputs

1.  **`FUP_EFP_MES` (V.6.4):** The raw, measured fuel pressure signal. (Connected to `u` input of the filter).
2.  **`FUP_EFP_DAMP_DET_in` (V.7.1):** The initial state or previous output state of the digital low-pass filter. (Connected to `x_in` input of the filter).
3.  **`C_CRLC_FUP_EFP_DAMP_DET`:** A calibratable constant representing the filter coefficient or time constant for the digital low-pass filter. (Connected to `m` input of the filter).
4.  **`C_FUP_EFP_DAMP_DEV_MAX`:** A calibratable threshold for the maximum allowed deviation between the measured and filtered fuel pressure values.

## Outputs

1.  **`FUP_EFP_DAMP_DET`:** The filtered (damped) fuel pressure signal, representing a smoothed version of `FUP_EFP_MES`. (Output `y` of the filter).
2.  **`LV_ERR_FUP_EFP_DAMP`:** A logical value (0 or 1) indicating the final debounced error status of the fuel pressure damper. (Set to 1 after debounce if a fault is detected).
3.  **`ERR_SYM_FUP_EFP_DAMP`:** A raw error symptom flag (e.g., 1H for hexadecimal 1) indicating that the deviation condition has been met, before debouncing.

## Logic Flow

The system operates in the following steps:

1.  **Fuel Pressure Filtering:**
    *   The raw measured fuel pressure (`FUP_EFP_MES`) is fed into a `DIGITALLOWPASS_RE` block (Digital Low-Pass Filter, identified as V.7.1).
    *   This filter also takes an input `FUP_EFP_DAMP_DET_in` (likely the previous filtered value or an initial state for recursive filtering) and a calibratable filter coefficient `C_CRLC_FUP_EFP_DAMP_DET`.
    *   The filter processes `FUP_EFP_MES` using these parameters to produce a smoothed output signal, `FUP_EFP_DAMP_DET`. The filter also outputs an internal state `x_out` (blue oval 3), which would likely be fed back as `FUP_EFP_DAMP_DET_in` in the next iteration for continuous filtering.

2.  **Deviation Calculation and Comparison:**
    *   The absolute difference between the raw measured fuel pressure (`FUP_EFP_MES`) and the newly filtered fuel pressure (`FUP_EFP_DAMP_DET`) is calculated.
    *   This absolute difference is then compared against a calibratable maximum deviation threshold, `C_FUP_EFP_DAMP_DEV_MAX`.

3.  **Symptom Activation and Debouncing:**
    *   **IF** the absolute difference calculated in step 2 is **greater than** `C_FUP_EFP_DAMP_DEV_MAX`:
        *   A symptom, "Fuel pressure damper error detected," is declared active.
        *   A debounce counter is incremented. This counter is part of an "anti-bounce filtering" mechanism, designed to prevent transient, short-duration deviations from triggering a permanent error.
        *   A raw error symptom flag, `ERR_SYM_FUP_EFP_DAMP`, is set (e.g., to `1H`).
    *   **THEN**, after the debounce counter reaches a certain pre-configured threshold (meaning the deviation has persisted for a sufficient duration), the final logical error status `LV_ERR_FUP_EFP_DAMP` is set to `1`. This indicates a confirmed fault in the fuel pressure damper.
    *   **ENDIF** (If the condition is not met, the counter would typically decrement or reset, and the error flags would remain unset or be reset).

In essence, the system monitors the fuel pressure signal for sudden, significant, and persistent fluctuations that are not adequately smoothed by the damper, indicating a potential defect.


--- Page 355 ---

This page does contain a Simulink-like block diagram.

## Function

The primary function of this system is to determine whether the diagnostic routine for the **fuel pressure damper (FUSL)** should be inhibited. It calculates a boolean flag, `LV_INH_ERR_FUP_EFP_DAMP`, which, when set to 'true' (or '1'), indicates that the diagnosis should not be performed due to specific operating conditions or system states. The system operates periodically, with a recurrence of 40 milliseconds.

## Inputs

The system takes various real-time signals and calibration values as inputs:

**Real-time Signals / Status Flags:**
*   `IGKON`: Ignition Key-On status (used for initialization triggers).
*   `fc_INI`: Function call signal for initialization.
*   `<LV IGK>`: Local variable representing the current ignition status (e.g., turned on/off).
*   `<N_32>`: Current engine speed.
*   `<MFF_SP_FUP_CTL>`: Fuel mass flow setpoint requested by the fuel control system.
*   `<LV_FRS>`: A permission flag (likely from a Fault Reaction Manager, indicated as LV_PRMS in the text) that dictates if the diagnosis is allowed.
*   `<T_AST>`: An ambient or engine temperature signal (e.g., Coolant Temperature).

**Calibration / Configuration Values:**
*   `C_ABC_INC_FUP_EFP_DAMP`: Calibration for increasing fuel pressure damper related logic.
*   `C_ABC_MAX_FUP_EFP_DAMP`: Calibration for maximum fuel pressure damper related logic.
*   `NC_IDX_ERR_FUP_EFP_DAMP`: Calibrated error configuration identifier in the Fault reaction manager.
*   `C_N32_MAX_FUP_EFP_DAMP`: Maximum allowable engine speed for diagnosis to be active.
*   `C_N32_MIN_FUP_EFP_DAMP`: Minimum allowable engine speed for diagnosis to be active.
*   `C_MFF_SP_MAX_FUP_EFP_DAMP`: Maximum allowable fuel mass flow setpoint for diagnosis to be active.
*   `C_MFF_SP_MIN_FUP_EFP_DAMP`: Minimum allowable fuel mass flow setpoint for diagnosis to be active.

## Outputs

*   `LV_INH_ERR_FUP_EFP_DAMP`: A boolean flag (Local Variable: Inhibit Error Fuel Pressure Electronic Fuel Pump Damper) which is 'true' (or '1') if the diagnosis is inhibited, and 'false' (or '0') otherwise.

## Logic Flow

The system's logic flow can be broken down into two main phases: Initialization and Continuous Operation.

1.  **Initialization Phase (Triggered by ECU Reset or Ignition Key-On):**
    *   As indicated by Figure 43.26.2 and the metadata `Init: RST, IGKON`, when the Electronic Control Unit (ECU) is reset or the ignition key is turned on, the system enters an initialization state.
    *   During this phase, the fuel pressure damper diagnosis is **unconditionally inhibited**. Figure 43.26.2 explicitly shows a constant value '1' (representing 'inhibited') being assigned to `LV_INH_ERR_FUP_EFP_DAMP`. This ensures that the diagnosis does not run during system startup or reset, allowing other systems to stabilize.
    *   The `INI` block (X.1) in Figure 43.26.1 likely handles this initialization logic and passes its status (`ini`) to the operational block.

2.  **Continuous Operational Phase (40ms Recurrence):**
    *   After initialization, and throughout normal operation, the main logic within the `OPM` (Operation Management) block (X.2) in Figure 43.26.1 continuously evaluates real-time conditions every 40 milliseconds to determine the inhibition status.
    *   The `OPM` block receives a bundled input of current system parameters and calibration limits.
    *   It internally processes these inputs using its `fc()` logic to check for various inhibition conditions. The diagnosis is inhibited (i.e., `LV_INH_ERR_FUP_EFP_DAMP` is set to 'true') if *any* of the following criteria are met:
        *   **Ignition Status:** The ignition is not turned on (`<LV IGK>` indicates off).
        *   **Engine Speed Range:** The current engine speed (`<N_32>`) is outside the permissible range defined by `C_N32_MIN_FUP_EFP_DAMP` and `C_N32_MAX_FUP_EFP_DAMP`.
        *   **Fuel Mass Flow Setpoint Range:** The fuel mass flow setpoint (`<MFF_SP_FUP_CTL>`) is outside the permissible range defined by `C_MFF_SP_MIN_FUP_EFP_DAMP` and `C_MFF_SP_MAX_FUP_EFP_DAMP`.
        *   **Fault Reaction Manager Status:** The function identifier (`NC_IDX_ERR_FUP_EFP_DAMP`) for this diagnosis contains a calibrated error configuration, AND the permission flag from the Fault Reaction Manager (`<LV_FRS>`) is zero, explicitly denying permission for the diagnosis.
    *   The output of the `OPM` block, `opm`, reflects the result of these inhibition calculations.

3.  **Final Output Assignment:**
    *   The `opm` signal from the `OPM` block is directly assigned to the `LV_INH_ERR_FUP_EFP_DAMP` output. This final signal communicates the current inhibition status of the fuel pressure damper diagnosis to other parts of the system.


--- Page 356 ---

This page contains a Simulink-like diagram, commonly used in automotive embedded software development for control and diagnostic logic.

## Function
The primary function of this diagram is to determine the conditions under which the diagnosis of a **Fuel Upstream Electric Fuel Pump Damper (FUP EFP DAMP)** error should be **inhibited**. This is crucial in automotive systems to prevent false error detections or unnecessary diagnostic attempts when the operating conditions are not suitable or stable, as highlighted by the text, especially concerning low fuel situations and engine start-up.

## Inputs
1.  **<ACTION_FARM_GetPermission_T3>**: A signal indicating whether a specific action or permission (e.g., to run a diagnostic) is granted by a "Fault Recognition & Management" (FARM) system.
2.  **NC_FID_ERR_FUP_EFP_DAMP**: Likely "No Confirmed Failure ID for Error FUP EFP Damper", a flag indicating if a confirmed fault for the EFP damper is currently absent or allowing diagnosis.
3.  **<LV_IGK>**: Ignition status, typically true when the ignition is ON.
4.  **C_N_32_MAX_FUP_EFP_DAMP**: A calibratable maximum engine speed (N_32) threshold for EFP damper diagnosis.
5.  **C_N_32_MIN_FUP_EFP_DAMP**: A calibratable minimum engine speed (N_32) threshold for EFP damper diagnosis.
6.  **<N_32>**: The actual engine speed.
7.  **C_MFF_SP_MAX_FUP_EFP_DAMP**: A calibratable maximum fuel mass flow setpoint (MFF_SP_FUP_CTL) threshold for EFP damper diagnosis.
8.  **C_MFF_SP_MIN_FUP_EFP_DAMP**: A calibratable minimum fuel mass flow setpoint (MFF_SP_FUP_CTL) threshold for EFP damper diagnosis.
9.  **<MFF_SP_FUP_CTL>**: The actual fuel mass flow setpoint for control.
10. **<LV_FRS>**: Fuel Reserve Status, likely true when the fuel tank is in reserve mode (low fuel).
11. **<T_AST>**: After Start Time, the time elapsed since the engine started.
12. **C_T_AST_INH_DIAG_EFP_DAMP**: A calibratable threshold for the After Start Time, below which diagnosis should be inhibited.

## Outputs
1.  **<LV_INH_ERR_FUP_EFP_DAMP>**: A Boolean flag (Level Inhibit Error Fuel Upstream Electric Fuel Pump Damper) which is TRUE if the diagnosis should be inhibited, and FALSE if it is permitted to run.

## Logic Flow

The diagram processes several conditions in parallel, and if **any** of these conditions for inhibition are met, the final output `LV_INH_ERR_FUP_EFP_DAMP` becomes TRUE, signaling that the EFP damper diagnosis should be inhibited. The logic flows as follows:

1.  **Permission Check:**
    *   The signal `<ACTION_FARM_GetPermission_T3>` is processed by an "ActionImport" block, yielding `PRM_OUT1`. This `PRM_OUT1` is likely TRUE if permission is granted.
    *   This `PRM_OUT1` signal is then inverted by a `NOT` gate.
    *   **Inhibition Condition:** If `PRM_OUT1` is FALSE (permission *not* granted), the `NOT` gate outputs TRUE, contributing to inhibition. If permission is granted, this branch outputs FALSE (no inhibition).

2.  **Failure ID Status Check:**
    *   The `NC_FID_ERR_FUP_EFP_DAMP` signal is inverted by a `NOT` gate. `NC_FID` typically means "No Confirmed Failure ID". If this signal is TRUE, it implies the system is clear to run diagnosis; if FALSE, a condition (e.g., existing fault) prevents it.
    *   **Inhibition Condition:** If `NC_FID_ERR_FUP_EFP_DAMP` is FALSE (meaning a confirmed failure ID exists or diagnosis is precluded), the `NOT` gate outputs TRUE, contributing to inhibition. If diagnosis is allowed (no confirmed FID, etc.), this branch outputs FALSE.

3.  **Ignition Status Check:**
    *   The ignition status `<LV_IGK>` is inverted by a `NOT` gate.
    *   **Inhibition Condition:** If `<LV_IGK>` is FALSE (ignition is OFF), the `NOT` gate outputs TRUE, contributing to inhibition. If ignition is ON, this branch outputs FALSE.

4.  **Engine Speed Range Check:**
    *   The actual engine speed `<N_32>` is fed into an `MX/MN` (Min/Max) block along with `C_N_32_MAX_FUP_EFP_DAMP` and `C_N_32_MIN_FUP_EFP_DAMP`. This block outputs TRUE if `<N_32>` is *within* the specified range [Min, Max].
    *   The output of the `MX/MN` block is then inverted by a `NOT` gate.
    *   **Inhibition Condition:** If `<N_32>` is *outside* the specified engine speed range, the `MX/MN` block outputs FALSE. The `NOT` gate then outputs TRUE, contributing to inhibition. If the engine speed is within the range, this branch outputs FALSE.

5.  **Fuel Mass Flow Setpoint Range Check:**
    *   The actual fuel mass flow setpoint `<MFF_SP_FUP_CTL>` is fed into another `MX/MN` block with `C_MFF_SP_MAX_FUP_EFP_DAMP` and `C_MFF_SP_MIN_FUP_EFP_DAMP`. This block outputs TRUE if `<MFF_SP_FUP_CTL>` is *within* the specified range [Min, Max].
    *   The output of this `MX/MN` block is then inverted by a `NOT` gate.
    *   **Inhibition Condition:** If `<MFF_SP_FUP_CTL>` is *outside* the specified fuel mass flow setpoint range, the `MX/MN` block outputs FALSE. The `NOT` gate then outputs TRUE, contributing to inhibition. If the setpoint is within the range, this branch outputs FALSE.

6.  **Fuel Reserve Status Check:**
    *   The `<LV_FRS>` signal (Fuel Reserve Status) directly feeds into the final `OR` gate.
    *   **Inhibition Condition:** If `<LV_FRS>` is TRUE (fuel is in reserve), this directly contributes TRUE to the `OR` gate, inhibiting diagnosis. This aligns with the text explaining pressure fluctuations in low fuel conditions.

7.  **After Start Time Check:**
    *   The `<T_AST>` (After Start Time) is compared with the calibratable threshold `C_T_AST_INH_DIAG_EFP_DAMP` using a "less than or equal to" (`<=`) comparison.
    *   **Inhibition Condition:** If `<T_AST>` is less than or equal to `C_T_AST_INH_DIAG_EFP_DAMP`, the comparison outputs TRUE, directly contributing to inhibition. This ensures that diagnosis is delayed until the engine system has stabilized after starting.

**Final Output Logic:**
All seven individual conditions (or their inverted results) are fed into a final `OR` gate. The output `<LV_INH_ERR_FUP_EFP_DAMP>` will be **TRUE** if **any** of these inhibition conditions are met. It will only be **FALSE** (diagnosis allowed) if **all** of these conditions for inhibition are simultaneously FALSE.


--- Page 412 ---

This page contains two related Simulink-like diagrams concerning fuel system pressure diagnosis.

## Function

**Overall Purpose:** The diagrams illustrate two key control logic components within a fuel system pressure diagnosis application:
1.  **Gradient Limiter (Figure 43.33.1):** To smooth and limit the rate of change of a specific fuel mass flow gradient signal (`MFF_SP_GRD_FUP_DIAG`). This prevents abrupt changes that could lead to unstable control or erroneous diagnosis.
2.  **Diagnosis Inhibition Timer (Figure 43.33.2):** To manage a time-based inhibition of a high-pressure system diagnosis. This inhibition is activated when the fuel mass flow is at its maximum limit and/or the fuel mass flow gradient is being limited, preventing false diagnosis during transient or extreme operating conditions.

## Inputs

**Common/External Inputs:**
*   `C_MFF_SP_GRD_FUP_DIAG_MAX`: Calibratable maximum positive gradient limit.
*   `C_MFF_SP_GRD_FUP_DIAG_MIN`: Calibratable minimum negative gradient limit.
*   `MFF_SP_GRD_FUP_DIAG_in`: Input signal for which the gradient is to be limited.
*   `C_T_MFF_MAX_H_PRS_DIAG_INH`: Calibratable time constant for high-pressure diagnosis inhibition due to maximum flow.
*   `C_MFP_OFS_H_PRS_DIAG_INH`: Calibratable offset for high-pressure diagnosis inhibition.
*   `MFP_MAX`: Maximum fuel mass flow achievable by the pump.
*   `MFF_SP_FUP_CTL`: Commanded fuel mass flow to the fuel pump.
*   `C_FAC_FUEL_PUMP_CTL`: Calibratable factor for fuel pump control (likely efficiency or scaling).

**Internal (shared/feedback) Inputs:**
*   `MFF_SP_GRD_FUP_DIAG`: Output of the gradient limiter, fed back as input for the next cycle and potentially used elsewhere.
*   `grl_B_min_tmp`: Intermediate lower bound calculated by the gradient limiter.
*   `grl_B_max_tmp`: Intermediate upper bound calculated by the gradient limiter.

## Outputs

**Primary Outputs:**
*   `MFF_SP_GRD_FUP_DIAG`: The gradient-limited fuel mass flow gradient signal.
*   `T_MFF_MAX_H_PRS_DIAG_INH`: The current value of the decrementing inhibition timer.
*   `L_T_MFF_MAX_H_PRS_DIAG_INH`: A Boolean flag indicating if the inhibition timer has reached zero, signifying that the high-pressure diagnosis should be inhibited.

**Intermediate/Temporary Outputs:**
*   `grl_B_min_tmp`: Temporary variable representing the dynamic lower rate limit.
*   `grl_B_max_tmp`: Temporary variable representing the dynamic upper rate limit.

## Logic Flow

The system comprises two main logical blocks, as depicted in the figures:

### 1. Gradient Limiter for `MFF_SP_GRD_FUP_DIAG` (Figure 43.33.1)

This block limits the rate of change of the input signal `MFF_SP_GRD_FUP_DIAG_in` to produce a smoothed output `MFF_SP_GRD_FUP_DIAG`.

1.  **Determine Dynamic Lower Rate Limit (`grl_B_min_tmp`):** The calibratable minimum negative gradient limit (`C_MFF_SP_GRD_FUP_DIAG_MIN`) is multiplied by the fuel pump control setpoint (`MFF_SP_FUP_CTL`). This result, `MFF_SP_FUP_CTL * C_MFF_SP_GRD_FUP_DIAG_MIN`, forms the dynamic lower rate limit `grl_B_min_tmp`.
2.  **Determine Dynamic Upper Rate Limit (`grl_B_max_tmp`):**
    *   The calibratable minimum negative gradient limit (`C_MFF_SP_GRD_FUP_DIAG_MIN`) is inverted by multiplying it by -1.
    *   This inverted minimum limit and the calibratable maximum positive gradient limit (`C_MFF_SP_GRD_FUP_DIAG_MAX`) are then multiplied by the fuel pump control setpoint (`MFF_SP_FUP_CTL`). This creates the dynamic upper rate limit `grl_B_max_tmp`.
3.  **Apply Rate Limiter:**
    *   The input signal `MFF_SP_GRD_FUP_DIAG_in` (u) is fed into a Rate Limiter block (V.7.4) with a sample time `dT = 0.02 sec`.
    *   The previously calculated output `MFF_SP_GRD_FUP_DIAG` (x_out) is fed back as the current state `x_in` to the Rate Limiter.
    *   The dynamic lower (`grl_B_min_tmp`) and upper (`grl_B_max_tmp`) rate limits are applied to the Rate Limiter as `B_min` and `B_max` respectively.
    *   The Rate Limiter block ensures that the rate of change of the output `y` (which becomes `MFF_SP_GRD_FUP_DIAG`) does not exceed `grl_B_max_tmp` or fall below `grl_B_min_tmp`.

### 2. Decrement Timer for Diagnosis Inhibition (Figure 43.33.2)

This block manages a timer that determines when a high-pressure diagnosis should be inhibited.

1.  **Check for Maximum Flow Limitation Condition:**
    *   Calculate a threshold for maximum flow: `MFP_MAX - C_MFP_OFS_H_PRS_DIAG_INH`.
    *   Calculate the effective requested fuel flow: `MFF_SP_FUP_CTL * C_FAC_FUEL_PUMP_CTL`.
    *   Compare these values: `(MFP_MAX - C_MFP_OFS_H_PRS_DIAG_INH > MFF_SP_FUP_CTL * C_FAC_FUEL_PUMP_CTL)`. This condition is true if the requested fuel flow is sufficiently below the maximum possible flow, indicating *no active maximum flow limitation*.
2.  **Check for Gradient Limitation Condition:**
    *   Compare the dynamically determined lower and upper gradient limits: `(grl_B_min_tmp < grl_B_max_tmp)`. This condition is generally true if the gradient limits are valid and not actively constraining the signal, indicating *no active gradient limitation*.
3.  **Combine Inhibition Reset Conditions:**
    *   The results of the two conditions above are fed into an OR gate.
    *   The output of the OR gate (`R`) is true if *either* there is no maximum flow limitation *or* no gradient limitation. This means `R` is true when conditions that *would typically cause inhibition* are *not* present.
4.  **Manage Decrement Timer:**
    *   A decrementing timer block (V.7.4) is used with a sample time `dT = 0.02 sec`.
    *   The calibratable time `C_T_MFF_MAX_H_PRS_DIAG_INH` is provided as the initial value (`IV`) for the timer.
    *   The timer decrements by 1 (`z=1`) at each sample step.
    *   The OR gate output (`R`) acts as a reset signal. If `R` is true (i.e., no significant limiting condition is active), the timer is reset to its initial value `C_T_MFF_MAX_H_PRS_DIAG_INH`.
    *   If `R` is false (meaning both maximum flow *and* gradient limitations are likely active), the timer is allowed to decrement.
5.  **Output Inhibition Flag:**
    *   The current value of the timer is `T_MFF_MAX_H_PRS_DIAG_INH`.
    *   An output `L_T_MFF_MAX_H_PRS_DIAG_INH` becomes true when the timer `T_MFF_MAX_H_PRS_DIAG_INH` reaches zero. This flag signifies that the persistent maximum flow and/or gradient limitation has lasted for the calibratable time, and therefore the high-pressure diagnosis should be inhibited to prevent false error detection.


--- Page 413 ---

This page contains a block diagram that is clearly a Simulink diagram (or a representation from a similar model-based development tool like TargetLink or ASCET, common in automotive engineering).

## Function

The primary function of this Simulink diagram is to implement a **time-based inhibition mechanism for the fuel system's high-pressure diagnosis**. Specifically, it tracks how long the actual fuel mass flow remains below a calibratable minimum threshold. If this low-flow condition persists for a predefined, calibratable duration, the high-pressure diagnosis is inhibited to prevent false error detections. The diagram manages a "decrement timer" that counts down when the low-flow condition is present and counts up (recovers) when the flow is sufficient.

## Inputs

1.  **`MFF_SP_FUP_CTL`**: Fuel Mass Flow Set Point / Actual Fuel Mass Flow (e.g., from direct injection system). This represents the current fuel flow.
2.  **`C_MFF_MIN_H_PRS_DIAG_INH`**: Calibratable constant representing the minimum fuel mass flow threshold. If `MFF_SP_FUP_CTL` falls below this value, it indicates a low-flow condition relevant for diagnosis inhibition.
3.  **`C_T_MFF_MIN_H_PRS_DIAG_INH`**: Calibratable constant representing the time threshold (in seconds, derived from `dT`) for which the low-flow condition must persist before the diagnosis is inhibited. This acts as the initial/maximum value for the timer.

## Outputs

1.  **`LV_T_MFF_MIN_H_PRS_DIAG_INH`** (labeled `1`): A boolean (Logical Value) flag. This output is TRUE when the low fuel mass flow condition has persisted for the duration specified by `C_T_MFF_MIN_H_PRS_DIAG_INH`, indicating that the high-pressure system diagnosis should be inhibited.
2.  **`T_MFF_MIN_H_PRS_DIAG_INH`** (labeled `2`): The current value of the decrement timer. This value typically represents the remaining time until inhibition (if counting down) or the recovery time (if counting up).

## Logic Flow

1.  **Fuel Mass Flow Condition Check:**
    *   The current fuel mass flow (`MFF_SP_FUP_CTL`) is continuously compared against the calibratable minimum flow threshold (`C_MFF_MIN_H_PRS_DIAG_INH`) using a "less than or equal to" (`<=`) relational operator.
    *   If `MFF_SP_FUP_CTL <= C_MFF_MIN_H_PRS_DIAG_INH` is TRUE, it signifies that the fuel flow is below the minimum required, and thus a potential condition for diagnosis inhibition is present.
    *   If the condition is FALSE, the fuel flow is considered sufficient.

2.  **Decrement Timer Management (Ramp/Hysteretic Timer Block):**
    *   The output of the flow comparison (TRUE/FALSE) feeds into the 'R' input of a dedicated timer block. This block operates in discrete time steps of `dT = 0.02 seconds`.
    *   The calibratable time threshold `C_T_MFF_MIN_H_PRS_DIAG_INH` is fed into the 'IV' (Initial Value or Upper Limit) input of the timer block.
    *   The timer output `T_MFF_MIN_H_PRS_DIAG_INH` (output `y`) is fed back into its own 'x_in' input via a Unit Delay (`1/z`) block, meaning the timer's previous value is used for the current step's calculation. The `Init = 0` on the `1/z` block implies the timer starts at 0 if no explicit initial value is provided to the timer block.
    *   **Behavior of the timer:**
        *   **If the low-flow condition is TRUE** (`MFF_SP_FUP_CTL <= C_MFF_MIN_H_PRS_DIAG_INH`): The timer `T_MFF_MIN_H_PRS_DIAG_INH` decrements by `dT` (0.02 seconds) in each time step. It effectively counts down from `C_T_MFF_MIN_H_PRS_DIAG_INH` towards 0, representing the time remaining until inhibition is active. The timer saturates at 0.
        *   **If the low-flow condition is FALSE**: The timer `T_MFF_MIN_H_PRS_DIAG_INH` increments by `dT` (0.02 seconds) in each time step. It counts up towards `C_T_MFF_MIN_H_PRS_DIAG_INH`, effectively 'recovering' and delaying the inhibition or releasing an active inhibition. The timer saturates at `C_T_MFF_MIN_H_PRS_DIAG_INH`.

3.  **Diagnosis Inhibition Flag Calculation:**
    *   The final output, `LV_T_MFF_MIN_H_PRS_DIAG_INH`, is a logical flag indicating the inhibition status.
    *   This flag becomes TRUE when the timer `T_MFF_MIN_H_PRS_DIAG_INH` reaches 0. This state signifies that the low fuel mass flow condition has persisted for the full calibratable duration, and therefore, the high-pressure system diagnosis must be inhibited.
    *   Conversely, if `T_MFF_MIN_H_PRS_DIAG_INH` is greater than 0, `LV_T_MFF_MIN_H_PRS_DIAG_INH` is FALSE, meaning the diagnosis is currently active or not inhibited.


